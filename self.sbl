* Copyright (c) 2017 dave shields

-include "lib.sbl"

	define('game(mode)players,player,opn,move,i,li,offset,open.word,open.score,n,tiles,moves,li,passed,board') :(game.end)

*	Play a game of fribble. *max* is the maximum number of moves.
*	Mode is one to let you play against fribble, two to let fribble play itself.

*GAME*
game

	pid = 2;* set to two so will become one when loop first entered
game.turn
	pid = (eq(pid,1) 2, 1)
	player = g.players[pid]

	g.turn = g.turn + 1

	out(ne(g.turnlimit) gt(g.turn,g.turnlimit) 
.			'Game over -- too many turns (' g.turnlimit ').') :s(game.over)
	out(gt(g.turn,g.lastmove + 5) 
.			'Game over - too many turns with no move.') :s(game.over)
	out(ne(g.maxmoves) gt(g.turn,g.maxmoves) 
.			'Game over -  too many turns.')  :s(game.over)

	eq(g.trace,g.turn) traceon()


	out('Move ' g.turn ' for player ' name(player) ', with tiles ' show.tiles(rack(player),'A') '.')
	out(ne(g.showscore) 'B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 ')

	ident(fribble(player))						:s(game.turn.solo)

game.turn.self
*	eq(mode,1) out('computing move...')
	move = find(pid,g.turn)
*	eq(mode,1) out('... computed')
								:(game.move)

game.turn.solo
	out("Your turn")

game.turn.solo.in
	out('enter your move')
	line = terminal						:f(end)
	move = eval(line)					:f(game.turn.solo.error)
	ident(datatype(move),'move')				:s(game.valid)
	out('need to enter a move')				:(game.turn.solo)
game.valid

*	See if move is valid, except no test needed for initial move.

	eq(g.turn,1)						:s(game.move)
	valid(move)						:s(game.move)

	out('invalid move - try again')				:(game.turn.solo.in)

game.turn.solo.error
	out('eval error ' &errtext)				:(game.turn.solo)

								:(game.fail)		
game.move
	points(move) = scoremove(move)
	show.play(makemove(pid,move))

*	Game over if no more tiles.

	out(eq(size(g.tiles)) 'Game over - no more tiles. ')	:s(game.over)

*	Remove tiles played on move and then replenish the rack.

	rack(player) = less(rack(player), lcase(text(move)))
	rack(player) = replenish(pid)				:(game.turn)

game.fail

*	Here if no move found.

	out('No move found.')

*	Here if no move found, in which case the return value is a set of swapped tiles. If *move* is null, then pass.

	differ(move)					:s(game.swap)
	passed = passed + 1
	out(gt(passed,6) ' Too many passed moves.')	:s(game.over)
	out('Player ' name(player) ' passes.')		:(game.turn)
	
game.swap
	rack(player) = swap(player,3)
	out('Player ' name(player) ' swapped tiles.')
	out('Player ' name(player) ' now has tiles ' show.tiles(rack(player))) :(game.turn)
game.over						
	endgame()					:(return)
game.end

*	Have fribble play itself.

	&stlimit = -1
	&anchor = &trim = 1

	init()


*	The program can now run in two modes.
*	s.mode = 1 for solo mode, where you play against fribble.
*	s.mode = 2 for self mode, where fribble moves for both players.
	
	s.mode = 2
	s.mode = 1


	options = host(0) ' '
*	output = 'host <' options '>'

options.loop
	options break(' ') . opt ' ' =			:f(options.loop.done)
	output = 'option ' opt
	s.mode = ident(opt,'self') 2			:s(options.loop)
	s.mode = ident(opt,'solo') 1			:s(options.loop)
	output = 'unknown option ' opt
							:(options.loop)
options.loop.done


	eq(s.mode,2)					:s(setup.2)

*	Setup for mode 1
	g.one = player(1,'You')
	g.two = player(2,'Fribble',1)
							:s(setup.done)
setup.2
	g.one = player(1,'Fribble I',1)
	g.two = player(2,'Fribble II',1)
setup.done
	g.players[1] = g.one; g.players[2] = g.two

*	Program manages the racks.

	g.dealer = 1
	rack(g.one) = take(7)
	rack(g.two) = take(7)

	g.turn = g.lastmove = total(g.one) = total(g.two) = 0
	g.turnlimit = 

*	g.trace = 22
*	eq(g.turn,22) traceon()
*	g.showscore = eq(g.turn,22) 1
*	eq(g.turn,23) traceoff()
*	g.showscore = eq(g.turn,23) 0

	game(s.mode)							:(end)
end
