* Copyright (c) 2017 dave shields

-include "lib.sbl"

	define('game(one,two)opn,move,players,i,li,offset,open.word,open.score,n,tiles,moves,li,passed,board') :(game.end)

*	Play a game of fribble. *one* and *two* are players. *max* is the maximum number of moves.

*GAME*
game
	players = array(2)
	players[1] = g.one
	players[2] = g.two
game.round
	i = 0
game.turn
	p = players[i = i + 1]				:f(game.round)

	g.turn = g.turn + 1
	output = ne(g.turnlimit) gt(g.turn,g.turnlimit) 'Game over -- too many turns (' g.turnlimit ').' :s(game.over)
	output = gt(g.turn,g.lastmove + 5) 'Game over - too many turns with no move.' :s(game.over)

	differ(g.trace) tracer()

	output = ne(g.maxmoves) gt(g.turn,g.maxmoves) 'Game over -  too many turns.'  :s(game.over)

	output = 'Move ' g.turn ' for player ' name(p) ', with tiles ' show.tiles(rack(p),'A') '.'
	output = ne(g.showscore) 'B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 '

	differ(fribble(p))				:s(game.fribble)

game.you.move

*	Here for you to make a move

	show.board(g.board)
	output = 'your tiles: ' show.tiles(rack(p))
	output = 'make your move '
	text = input					:f(game.eof)
	output = 'you entered ' text
	ident(text,'quit')				:s(game.over)
	ident(text,'resign')				:s(game.resign)
	move = eval(text)
	ident(datatype(move),'MOVE')			:s(game.validmove)
	output = 'evaluating ' text
	eval(text)
							:(game.you.move)
game.validmove
	show.move(move)
	validmove(move)					:s(game.scoremove)
	output = 'invalid move ' show.move(move)	:(game.you.move)

game.scoremove
	
	clines(move,1)
	show.clines()
*	g.showscore = 1
	points(move) = findscore()
	output = 'move is worth ' points(move) ' points.'
	output = 'do you want to make this move (y or just ENTER for yes, no otherwise)?'
	ans = input					:f(game.eod)
	ident(ans)					:s(game.moveon)
	ident(ans,'y')					:s(game.moveon)
							:(game.you.move)
game.fribble

*	Here to have fribble make a move
	move = (eq(g.turn,1) start(rack(p)), find(rack(p),limit(p))) :s(game.move)
game.move
game.moveon
	makemove(p,move)
	show.play(move)

*	Game over if no more tiles.

	output = eq(size(g.tiles)) 'Game over - no more tiles. '		:s(game.over)
	getrack(p,move)					:(game.turn)

game.fail

*	Here if no move found.

	output = 'No move found.'

*	Here if no move found, in which case the return value is a set of swapped tiles. If *move* is null, then pass.

	differ(move)					:s(game.swap)
	passed = passed + 1
	output = gt(passed,6) ' Too many passed moves.'	:s(game.over)
	output = 'Player ' name(g.one) ' passes.'		:(game.turn)
	
game.swap
	rack(p) = swap(rack(p),3)
	output = 'Player ' name(p) ' swapped tiles.'	
	output = 'Player ' name(p) ' now has tiles ' show.tiles(rack(p)) :(game.turn)
game.eof
	output = 'end of input - game over'		:(game.over)
game.resign
	output = 'player ' name(p) ' resigns'
game.over						
	endgame()					:(return)
game.end
	define('sw()')					:(sw.end)

*	Swap two tiles for player 'you'

*SW*
sw
	rack(g.two) = swap(g.two,2)			:(return)
sw.end

*	Have fribble play itself.

	&stlimit = -1
	&anchor = &trim = 1

	init()

*	Have Fribble go first, so we don't have worry about handling the first-move case for other player.

	one = player(1,'Fribble',1)
	two = player(2,'You')
	g.one = one
	g.two = two
	total(g.one) = total(g.two) = 0
	rack(g.one) = take(7)
	rack(g.two) = take(7)

	g.turn = g.lastmove = 0
	g.turnlimit = 

	game()							:(end)
end
