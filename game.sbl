	define('endgame()')				:(endgame.end)

*	Summarize results at end of game.

*ENDGAME*
endgame

	out(	name(g.players[1])  ' scored ' number(total(g.players[1])) ' points, '
.		'with a best move of ' cardinal(highest(g.players[1]),'point') '.')

	out(	name(g.players[2])  ' scored ' number(total(g.players[2])) ' points, '
.		'with a best move of ' cardinal(highest(g.players[2]),'point') '.')

	out(gt(thirty(g.players[1])) name(g.players[1]) ' had '
.		cardinal(thirty(g.players[1]),'move') ' of thirty or more points.')

	out(gt(thirty(g.players[2])) name(g.players[2]) ' had '
.		cardinal(thirty(g.players[2]),'move') ' of thirty or more points.')

	counters()
							:(return)
endgame.end

	define('game(mode)players,player,opn,move,i,li,offset,open.word,'
.		'open.score,n,tiles,moves,li,passed,board,lfn') :(game.end)

**	Play a game of fribble. MAX is the maximum number of moves.
*	Mode is
*		one to have fribble play a game with itself,
*		two to let you play against fribble, and
*		three to work with fribble to play with another person,
*		who may be using fribble themself, but good for them!

*GAME*
game

*	Test to see if log file needed. Even if not, we always call log()
*	function. It will do nothing if no log file. This avoids need
*	to test for presence of log file before each call to log().

	eq(g.log)					:s(game.setup)

*	Open log file.

	g.logfile.name = datename(g.date) '.fri'
	output(.g.logfile,g.logfile.channel,g.logfile.name)  :s(game.log)
	out('unable to open log file ',g.logfile.name)	     :(game.setup)

game.log

	log('* game ' mode)
	log('* version ' g.version)
	log('* time.start ' time())
	log('* date.start ' g.date)
	log.tiles()
	log.player(1)
	log.player(2)

game.setup

	pid = 2;* set to two so will become one when loop first entered

game.turn

	add1(.g.turn)
	log('turn ' g.turn)

*	ne(f.trace) out('g.turn=' g.turn ' g.maxmoves=' g.maxmoves)
	gt(g.turn,g.lastmove + 3)
.  	  out('Game over - too many turns with no move.') :s(game.over)

	gt(g.turn,g.maxmoves)
.		out('Game over -- too many turns ('
.		g.maxmoves ').') :s(game.over)

	pid = (eq(pid,1) 2, 1)

	player = g.players[pid]

	out('Move ' number(g.turn) ' for player ' name(player)
.		 (differ(g.tilemanager) ', with tiles "'
.		show.tiles(rack(player),'A'),'')	'".')

	turn(pid,mode)			:f(game.turn.fail)s(game.turn)

game.turn.fail

*	Here if turn failed because no move could be found.
*	Try to swap three tiles

	out('no move, swapping tiles.')
	rack(player) = swap(pid,3)			:(game.turn)

game.fail

*	Here if no move found.

	out('No move found.')

*	Here if no move found, in which case the return value is
**	a set of swapped tiles. If MOVE is null, then pass.

	differ(move)					:s(game.swap)
	add1(.passed)
	out(gt(passed,6) ' Too many passed moves.')	:s(game.over)
	out('Player ' name(player) ' passes.')		:(game.turn)

game.swap

	out('swapping tiles pid=',pid)
	rack(player) = swap(pid,3)
	out('Player ' name(player) ' swapped tiles.')
	out('Player ' name(player) ' now has tiles '
.		show.tiles(rack(player))) :(game.turn)

game.over

	endgame()

*	Complete log file.

	log('* total.1 ' total(g.players[1]))
	log('* total.2 ' total(g.players[2]))
	log('* date.finis ' date(2))
	log('* time.finis ' time())
	log('endgame')

	differ(logfile) endfile(g.logfile.channel)
							:(return)

game.end

	define('log.tiles()')				:(log.tiles.end)

*	Write tiles set to log file

log.tiles

	log('tiles  "' g.tiles '"')		:(return)

log.tiles.end

	define('log.player(pid)')			:(log.player.end)

*	Write player description to log file.

log.player
	log('player ' pid ' ' show.player(pid))
							:(return)

log.player.end

	define('isbest(move)')			:(isbest.end)

*	Test the score of a move to see if it the best yet seen in a turn.

*ISBERT*
isbest
	out(ne(f.showscore) 'Find points(move) ' points(move)
.		'  highest=' g.highest ' lowest=' g.lowest)

	lt(points(move),g.highest)			:s(freturn)
	gt(points(move),g.highest)			:s(isbest.new)

*	Here if points equal, look for lower cost

	lt(cost(text(move)),g.lowest)			:s(isbest.new)
	gt(cost(text(move)),g.lowest)			:s(freturn)

*	Here if same points and cost, see if one uses 's' and the
*	other doesn't.  Continue search if current best doesn't use 's'.

	text(find) ? break('s')				:f(freturn)

*	Here if current best uses an 's'.
*	Continue if new move also uses 's'.

	text(move) ? break('s')				:s(freturn)

isbest.new

*	Here to add the new best move.

	g.highest = points(move)
	g.lowest = cost(text(move))
*	out(ne(g.tracing) 'find NEW BEST move ' show.move(move))
							:(return)
isbest.end

	define('order(tiles)chars,ch,c1,c2,swaps,i,v1,v2') :(order.end)

**	Sort the tiles in TILES according to their value, with
*	least valuable first.  Though 's' has a nominal value of 1,
*	its actual value is greater, since almost a third of
*	the words in the dictionary are plurals. Give 's' a value
*	of 5 for the purpose of the sort.

*ORDER*
order
	order = le(size(tiles),2) tiles			:s(return)
	chars = unpack(tiles)
							:(order.loop)
order.next

	eq(swaps,0)					:s(order.done)
	swaps = i = 0

*	Loop through chars, swapping out of order characters,
*	 until all characters are properly ordered.

order.loop

	c1 = chars[add1(.i)]				:f(order.next)
	c2 = chars[i + 1]				:f(order.next)
	v1 = (ident(c1,'s') 5, g.value[c1])
	v2 = (ident(c2,'s') 5, g.value[c2])
	le(v1,v2)					:s(order.loop)
	ch = c2
	chars[i + 1] = c1
	chars[i] = ch
	add1(.swaps)					:(order.loop)

order.done
							:(return)
order.end

	define('playmove(move)i,p,r,c,ch')		:(playmove.end)

**	Play move MOVE, updating the board and related objects.

*PLAYMOVE*
playmove

	id = id(move)
*	out('enter playmove ' show.move(move))
*	out('free ' prototype(free(move)))

playmove.ch

	p = free(move)[add1(.i)]			:f(playmove.done)
	r = row(id,p)
	c = column(id,p)
	ch = substr(text(move),i,1)
*	out('playmove p=' p ' i=' i ' r=' r ' c=' c ' ch=' ch)
	g.board[r, c] = ch
*	out('playmove r=' r ' c=' c ' char=' g.board[r,c])
	g.used[r,c]   = 1
	g.bonus[r, c] = ' ' :(playmove.ch) ;* indicate bonus no longer available

playmove.done
*	out('playmove.done i=' i)
	out(ne(g.tracing) 'playmove returns')
							:(return)
playmove.end


*	One-time initialization for replay()

	str = 'date endgame game move play rack tiles total turn version '
	replay.ops = table(10)

replay.init
	str break(' ') . op ' ' =			:f(replay.init.done)
	replay.ops[op] = 1				:(replay.init)

replay.init.done

	define('replay(option)line,command'):(replay.end)

*	Replay commands from previous game.
**	If OPTION is an integer, replay that number of commands
**	from the replay file. If OPTION is a string not convertible
*	to an integer, prepare for replaying by reading in the lines
*	from that file.

*REPLAY*
replay
	g.replay.lines = reader(option)			:s(replay.lines)
	out('reader returned ' prototype(ops) ' commands.')
	out('error reading commands from ' option)	:(freturn)

replay.lines

	g.replay.i = 0;* set up for replaying.
	g.replay.n = commands[0]			:(return)


replay.next
	gt(add1(.g.replay.i), g.replay.n)		:s(replay.done)
	line = g.replay.lines[g.replay.i]		:f(replay.done)
	out('replaying line ' g.replay.i ' |' line '|')
	ident(line)					:s(replay.next)
	line '*'					:s(replay.next)
	line span(&lcase) . command =
	out('replay.op=' command)
	differ(replay.ops[command])			:s($('replay.' command))

	out('replaying unknown command ' command ', ignore.')	:(replay.next)

replay.endgame
							:(replay.done)
replay.move
	line span(' ') len(1) . pid span(' ') =
	out('replay.move evaluating |' line '|')
	move = eval(line)
	out('replaying move datatype=' datatype(move)  ','  show.move(move))
	show.play(makemove(pid,move))
							:(replay.next)
replay.player
	line '.' len(1) . pid span(' ') =
	g.players[pid] = eval(line)
							:(replay.next)
replay.rack
	line '.' len(1) . pid =
	line = ' rack(g.players[ ' pid '] = ' line
	out('replay.rack ' line)
	eval(line)
							:(replay.next)
replay.tiles
	line = ' g.tiles = ' line
	out('replay.tiles ' line)
	eval(line)
							:(replay.next)
replay.turn
	line span(' ') span('0123456789') . turn =
	g.turn = turn					:s(replay.next)

replay.done
							:(return)
replay.end

	define('replenish(pid)player,rack,s')		:(replenish.end)

*	Replenish a player's rack. Do this from the tiles is g.tilemanager is
*	set, or get the new tiles from the user otherwise.

*REPLENISH*
replenish

	player = g.players[pid]
	differ(g.tilemanager)				:s(replenish.auto)

replenish.manual

	out('enter rack for player: ' show.player(pid))
	replenish = lcase(input)			:f(replenish.eof)
	ident(replenish) out('no input - try again.')	:s(replenish.manual)
	gt(size(replenish),7) out('too many letters |' replenish
.			'|, try again.') :s(replenish.manual)
	s = replenish
	s span(&lcase) =
	differ(s) out('non-alphabetic character - try again.')
.							:s(replenish.manual)

							:(return)
replenish.eof

	out('end of data on input - bye ')		:(end)

replenish.auto

	replenish = rack(player)

	eq(size(replenish),7)				:s(return)

	replenish = replenish take(7 - size(replenish)) :(return)

replenish.end

	define('shuffle()tiles,n,passes,r1,r2,ch')	:(shuffle.end)

*	Shuffle the remaining tiles by randomly swapping.players[2]
*	tiles several times.

*SHUFFLE*
shuffle

	tiles = unpack(g.tiles)
	n = size(g.tiles)
	passes = random(1000) + 500

shuffle.next

	le(passes = passes - 1)				:s(shuffle.done)
	r1 = random(n); r2 = random(n)
	eq(r1,r2)					:s(shuffle.next)
	ch = tiles[r1]
	tiles[r1] = tiles[r2]
	tiles[r2] = ch					:(shuffle.next)

shuffle.done

	g.tiles = pack(tiles)
							:(return)
shuffle.end

	define('state.restore(saved)')		:(state.restore.end)

*	Restore the state of the game from a prior save.

state.restore

	g.grid = 	saved['grid']
	g.bonus = 	saved['bonus']
	g.tiles = 	saved['tiles']
	g.players[1] = 	saved['player.1']
	g.players[2] = 	saved['player.2']
							:(return)
state.restore.end

	define('state.save()')				:(state.save.end)

*	Save the state of the game.

state.save

	state.save = table(10)
	state.save['grid'] = 	copy(g.grid)
	state.save['bonus'] = 	copy(g.bonus)
	state.save['tiles'] = 	copy(g.tiles)
	state.save['player.1'] = copy(g.players[1])
	state.save['player.2'] = copy(g.players[2])
							:(return)
state.save.end



	define('swap(pid,n)player,tiles')		:(swap.end)

**	Swap N tiles from the first *n* characters in *tiles*
**	of player with id PID.  If fewer than *n* tiles remain,
**	set N to the size of the tiles.

*SWAP*
swap

	player = g.players[pid]
	tiles = rack(player)
	n = gt(n,size(tiles)) size(tiles)
	n = gt(n,size(g.tiles)) size(g.tiles)
	eq(n)						:s(freturn)

swap.next

	swap = substr(g.tiles,1,n)
	g.tiles = substr(g.tiles,n + 1)  substr(tiles,1,n)
							:(return)
swap.end

	define('take(n)')				:(take.end)

**	Take N tiles from the tiles, or taking all
**	the remaining tiles if fewer than N remain.

*TAKE*
take
	n = gt(n,size(g.tiles)) size(g.tiles)
	eq(n,0)						:s(return)
	take = order(substr(g.tiles,1,n))
	g.tiles = substr(g.tiles, n + 1)		:(return)

take.end

	define('turn(pid,mode)manual,state,points.player,'
.			'points.fribble') 	:(turn.end)

*	Play a turn in a game.

*	Steps are

*	1.	Replenish tiles before making move if managing tiles by hand.

*	2.	Find or enter the move to be played.

*	3.	Make the move by updating the data structures, scores, etc.

*	4.	If not managing tiles by hand, use fribble to update the rack.

*TURN*
turn

	player = g.players[pid]

	ne(f.trace) out('enter turn pid=' pid ' ' show.player(pid))

	eq(g.trace,g.turn) traceon()

*	Replenish tiles before making the move.

*	This is needed when playing in team mode.
*	need to enter your tiles from the wwf board.

	eq(f.mode,f.mode.auto)				:s(turn.auto)
	ne(kind(player),player.kind.team)		:s(turn.move)

	rack(player) = replenish(pid)
	ne(f.trace) out('rack pid=' pid '   now ' rack(player))
	ne(f.trace) out(show.player(pid))

turn.move

	log( 'rack ' pid ' "' rack(player) '"')

*	2.	Find or enter the move to be played.

*	Here to pick the next move.
*	You need to enter the foe's move when playing as a team,
*	and your own move when playing a solo game.

	eq(f.mode,f.mode.auto)				:s(turn.auto)
	eq(kind(player),player.kind.foe)		:s(turn.manual)

*	Enable next line to get 'enhanced' mode where Fribble reports
*	move it would have made

*	eq(kind(player),player.kind.solo)		:s(turn.solo)

	eq(kind(player),player.kind.solo)		:s(turn.manual)

turn.auto

*	Here to have fribble find the best move.

	ne(f.trace) out('fribble making move.')

*	ne(kind(player),player.kind.auto) out('computing move ...')

	g.move = find(pid,g.turn)			:f(turn.fail)

*	ne(f.trace) out('auto move ' show.move(g.move))

*	ne(kind(player),player.kind.auto) out('... computed')
							:(turn.make)

turn.manual

*	Here to enter the move manually

	ne(f.trace) out('getting move manually')

	manual = move.input()
	ident(datatype(manual),'move')			:f(turn.manual.nomove)
	g.move = manual					:(turn.validate)

turn.manual.nomove

*	Here if manual didn't return a move, so branch
*	to the corresponding handler.

	manual 'error'					:s(turn.manual.error)
							:($('turn.' move))
turn.solo
*HERE*

*	Here to when playing solo. Get the player's move, then
*	find what fribble would have played, and show the difference.

turn.solo.in

	ne(f.trace) out('getting move manually')

	manual = move.input()
	ident(datatype(manual),'move')			:f(turn.solo.nomove)
	out('solo player move ' show.move(manual))
	g.move = manual				:(turn.solo.fribble.havemove)

turn.solo.nomove

*	Here if manual didn't return a move, so branch
*	to the corresponding handler.

	manual 'error'				:s(turn.manual.error)
	target = $('turn.' manual)
	out('solo no move target datatype ' datatype(target) ' ' target)
	out('turn.solo.nomove ' manual)
						:($('turn.' manual))
turn.solo.move

	eq(g.turn,1) valid.start(manual)	:s(turn.solo.fribble.havemove)
	ne(g.turn,1) valid(manual)		:s(turn.solo.fribble.havemove)

	out('invalid move - try again')			:(turn.solo.in)

turn.solo.fribble.havemove

	g.move = manual

*	G.move is the player's valid move.
*	Save the state, find the move fribble would have made,
*	and report the results to the player.

	state = state.save()
	move = find(pid, rack)			:s(turn.solo.fribble.move)

*	Here if fribble couldn't find a valid move.

	out('Hmmm ... Fribble unable to find a valid move.')	:(turn.validate)

turn.solo.fribble.move

	points.fribble = scoremove(move)
	points.player = scoremove(g.move)

	out('You played the move ' show.move(g.move) ' for '
.		number(points.player) ' points.')

	out('Fribble would have played ' show.move(move) ' for '
.		number(points(move)) ' points.')

	show.play(makemove(pid,move));* display fribble's move.

	lt(points.player,points.fribble)
.		out('Fribble would have scored ' (points(move) - points.player)
.		 ' more points.')

	eq(points.player,points.fribble)
.		out('Fribble and you would have scored the same - '
.		'Congratulations!')

	gt(points.player,points.fribble)
.		out('You score more (' (points.player - points.fribble)
.		 		    ') points than Fribble.')

	gt(points.player,points.fribble)	out('You are a genius!')

*	Put things back where they were.

	state.restore(state)

turn.validate

	ne(f.trace) out('validating move ' show.move(g.move))

*	See if move is valid.

	eq(g.turn,1) valid.start(g.move)		:s(turn.make)
	ne(g.turn,1) valid(g.move)			:s(turn.make)

	out('invalid move - try again')			:(turn.manual)

turn.manual.error

	out('eval error ' &errtext)			:(turn.manual)

turn.make
*	3.	Make the move by updating the data structures, scores, etc.

	points(g.move) = scoremove(g.move)

	log.move(pid,g.move)

*	ne(f.trace) out('making move ' show.move(g.move))

	show.play(makemove(pid,g.move))

turn.replenish

*	4.	Replenish the tiles if managing the tiles automatically.


*	Replenish tiles if necessary. If doing this manually, don't do it here,
*	but at start of next turn.

	eq(g.tilemanager)				:s(turn.done)
*	out('DAVE')
*	out('replenishing pid= ' pid ' ' show.player(player))
	ne(f.trace) out('replenishing pid= ' pid )


*	Here to update rack when fribble is managing the tiles.
*	Remove tiles played on move and then replenish the rack.

	ne(f.trace) out('updating rack pid=' pid)
	rack(player) = less(rack(player), lcase(text(g.move)))
	rack(player) = replenish(pid)
	ne(f.trace) out('rack pid=' pid '   now ' rack(player))
							:(turn.done)

turn.pass

	log( 'pass ' pid)
							:(turn.done)
turn.resign

	out('player ' pid ' resigns.')
	log('resign ' pid)				:(turn.done)

turn.swap

*	Here in case foe swapped tiles. Report it as such and move on.


	log('swap ' pid)

	out('foe swapped tiles')			:(turn.done)

turn.done

	ne(f.trace) out('turn done')
							:(return)
turn.fail

	out('turn failed - unable to find move.')	:(freturn)

turn.end

	define('user.input()')				:(user.input.end)

*	Get a line from the user, usually from the terminal, or from
*	a user input file.

user.input

	user.input = terminal				:f(freturn)s(return)

user.input.end

	define('log.move(pid,move)')			:(log.move.end)

*	Write move description to log file.

log.move

	log('move ' pid ' ' show.move(move))		:(return)

log.move.end


	define('valid(move)num,i,pos')			:(valid.end)

*	Test if move is valid.

*VALID*
valid
valid.move

*	At least one cell to be occupied by this move must be
*	adjacent to a used cell.

	num = id(move)

valid.u

	gt(add1(.i),size(text(move)))			:s(freturn)
	pos = free(move)[i]
	adjacent(row(num,pos),column(num,pos)) 		:f(valid.u)s(valid.used)

*	Here if no adjacent cell found, fail.  *
							:(freturn)
valid.used

*	Test that line and all its crossing lines are valid.

	clines(move);* get line and its crossing lines
	i = 0

valid.i

	gt(add1(.i),g.cln)				:s(return)
	checkline(line(g.clines[i]))			:f(freturn)s(valid.i)

valid.end

