*	Copyright 2017, David Shields

* This file is part of the fribble project:
*		http://github.com/daveshields/fribble.
*
*	Fribble is free software: you can redistribute it and/or modify
*	it under the terms of the gnu general public license as
*	published by the free software foundation, either
*	version 2 of the license, or (at your option) any later version.
*
*	Fribble is distributed in the hope that it will be useful,
*	but without any warranty; without even the implied warranty of
*	merchantability or fitness for a particular purpose.  See the
*	gnu general public license for more details.
*
*	You should have received a copy of the gnu general public
*	license along with fribble.
*	If not, see <http://www.gnu.org/licenses/>.

*	Utility functions


	define('add1(name)exp')		:(add1.end)

*	Add one to argument, which must be a name.

add1

	exp = ' ' name ' = ' name ' + 1'
	add1 = eval(exp)
					:(return)
add1.end

	define('adjacent(r,c)')				:(adjacent.end)

**	Test if the cell in row R and column *c* is adjacent to one
*	that has been used.

*ADJACENT*
adjacent

	gt(r,1) differ(g.used[r - 1,c],' ')	:s(return) ;* cell to north
	lt(c,15) differ(g.used[r,c + 1],' ')	:s(return) ;* cell to east
	gt(c,1) differ(g.used[r,c - 1],' ')	:s(return) ;* cell to west
	lt(r,15) differ(g.used[r + 1,c],' ')	:s(return) ;* cell to south
						:(freturn)
adjacent.end

	define('append(str,w,ch)')				:(append.end)

**	Append word W to string *str*, prefixing with *ch* if *str* is not null,
**	or using space if CH is null.

*APPEND*
append

	append = (ident(str) w, str (ident(ch) ' ' , ch) w)	:(return)

append.end


	define('avail(pair)line,spaces,c,i,oi')	:(avail.end)

*	Return array containing the indexes of the avail (blank) cells in line.
*	Fail if no cells are available.

*AVAIL*
avail
	line = line(pair)
	spaces = spaces(line)
	eq(spaces,0)					:s(freturn)
	avail = array(spaces)
	i = ai = 0

avail.c

	c = substr(line, add1(.i), 1)			:f(avail.done)
	differ(c,' ')					:s(avail.c)
	avail[add1(.oi)] = +i				:(avail.c)

avail.done

	eq(g.tracing)					:s(return)
	i = 0; c =

avail.done.ch

	c = c lpad(avail[add1(.i)],3)		:s(avail.done.ch)
*		show.hex(line) '|  |' show.line(line) '| is ' c)
							:(return)
avail.end

	define('bonus.lines()i')			:(bonus.lines.end)

*BONUS.LINES*
bonus.lines

	bonus.lines = array(30)

bonus.lines.next

	gt(add1(.i),15)				:s(return)
	bonus.lines[i] = hline(g.bonus,i)
	bonus.lines[i + 15] = vline(g.bonus,i)		:(bonus.lines.next)

bonus.lines.end

	define('cardinal(n,word)')			:(cardinal.end)

*	If N is one, returns 'one' followed by WORD.
*	Otherwise returns NUMBER(N) followed by WORD and 'S'.

cardinal

	cardinal = (eq(n,1) 'one ' word, number(n) ' '  word 's') :(return)

cardinal.end

	define('checkline(line)word')			:(checkline.end)

*	Test if all the words in a line are in the dictionary.

*CHECKLINE*
checkline

	add1(.count.checkline)
	line span(' ') =
	empty(line)					:s(return)
	line = line ' ';* to simplify breaking out words.

checkline.1

	line span(' ') =
	line break(' ')  . word ' ' =			:f(return)
	eq(size(word),1)				:s(checkline.1)
	checkword(word)					:f(freturn)s(checkline.1)

checkline.end

	checkwordn = 0

	define('checkword(word)')			:(checkword.end)

*	Test if a word is in the dictionary.

*CHECKWORD*
checkword

	add1(.count.checkword)

*	Accept words of a single character since they can occur in crossing lines.

	eq(size(word),1)				:s(return)

	word = lcase(word);* in case upper case letters have wrongly crept it.
	differ(g.dict[size(word)][word])		:f(freturn)s(return)

checkword.end

	define('cline(lines,move,p,ch)c,line')		:(cline.end)

**	Return crossing line of p-th cell in move MOVE.
**	CH gives tile to be played.

*CLINE*
cline
	add1(.count.cline)

*	Cross line of row r, position p, is column p.
*	Cross line of column c, position p, is row p.

	c = (le(id(move),15) p + 15, p);* cross line id
	line = lines[c];* cross line
	p = (le(id(move),15) id(move), id(move) - 15);* position to insert
	line = substr(line,1,p - 1) ucase(ch) substr(line,p + 1)
	cline = pair(c,line)				:(return)

cline.end

	define('clines(move,upper)p,c,ch,line')		:(clines.end)

**	Update g.clines to contain the line for move MOVE and all
*	its crossing lines. Express the letters of the move in upper case
**	(for later scoring) if UPPER is not null.

*CLINES*
clines
	line = g.lines[id(move)]
	p = free(move)[1]

*	First entry is for the line containing the move

	g.cln = 1
	g.clines[1] = pair(id(move), insert(g.lines[id(move)],move,1))
	i = 1

*	On each pass through the loop, we compute the crossing line of the
*	i-th character in the move.

clines.i

	p = free(move)[i]


*	Cross line of row r, position p,  is column p.
*	Cross line of column c, position p, is row p.

	c = (le(id(move),15) p + 15, p);* cross line
	line = g.lines[c];* cross line
	p = (le(id(move),15) id(move), id(move) - 15);* position to insert
	ch = substr(text(move),i,1)
	line = (gt(p,1) substr(line,1,p - 1),'')
.		 (differ(upper) ucase(ch), ch) (lt(p,15) substr(line,p + 1),'')
	g.clines[add1(.g.cln)] = pair(c, (ident(upper) lcase(line), line))
	le(add1(.i), size(text(move)))			:s(clines.i)f(return)

clines.end

	define('column(num,pos)')			:(column.end)

**	Returns column corresponding to position POS in line *num*.

*COLUMN*
column

	column = ((gt(num,15) num - 15, pos))		:(return)

column.end

	define('cost(text)')				:(cost.end)

**	Return the cost of TEXT, defined as the sum of the
**	values of the tiles in TEXT.

*COST*
cost

	text len(1) . ch =				:f(return)
	cost = cost + g.value[ch]			:(cost)

cost.end

	define('counter(text,count)')			:(counter.end)

**	Output the descriptive text TEXT and value *n* of a counter.

*COUNTER*
counter

	out(lpad(text,26) lpad(count,12))		:(return)

counter.end

	define('counters()elapsed')			:(counters.end)

*	Output the collected counter metrics.

*COUNTERS*
counters

	out()
	out('Performance metrics:')
*	out('Time ',(time() - g.time) / 1000)
*	elapsed = (time() - g.time) / 1000
	counter('execution time (msec)'		, thousands(time()))
	counter('turns'				, thousands(g.turn))
	counter('placements found by scan'	, thousands(count.scanned))
	counter('permutations examined'		, thousands(count.perm))
	counter('cells examined'		, thousands(count.cells))
	counter('potential moves found'		, thousands(count.moves	))
	counter('lines checked'			, thousands(count.checkline))
	counter('words checked'			, thousands(count.checkword))
	counter('cross lines checked'		, thousands(count.cline))
	counter('valid moves found'		, thousands(count.valid))
	counter('total inserts'			, thousands(count.insert))
	counter('contiguous inserts'		, thousands(count.insert.contig))
	counter('split inserts'			, thousands(count.insert.split))
							:(return)
counters.end

	define('datename(date)s')				:(datename.end)

*	Convert date to form with no blanks, just dashes, to be
*	suitable for use as part of a file name.

datename

	datename = replace(date,' :/','---')
	datename = substr(datename,12,8) '-' substr(datename,1,10)
							:(return)
datename.end

	define('dt(obj)')				:(dt.end)

*	Shorthand for datatype(obj)

dt

	dt = (ident(obj) 'string',  datatype(obj))	:(return)

dt.end

	define('empty(line)')				:(empty.end)

*	Test if line is empty (null or all blanks).

*EMPTY*
empty

*	In most cases, the first character in line is not null.

	ident(line)					:s(return)
	differ(substr(line,1,1),' ')			:s(freturn)
	line span(' ') =
	ident(line)					:s(return)f(freturn)

empty.end

	define('endgame()')				:(endgame.end)

*	Summarize results at end of game.

*ENDGAME*
endgame

	out(	name(g.players[1])  ' scored ' number(total(g.players[1])) ' points, '
.		'with a best move of ' cardinal(highest(g.players[1]),'point') '.')

	out(	name(g.players[2])  ' scored ' number(total(g.players[2])) ' points, '
.		'with a best move of ' cardinal(highest(g.players[2]),'point') '.')

	out(gt(thirty(g.players[1])) name(g.players[1]) ' had '
.		cardinal(thirty(g.players[1]),'move') ' of thirty or more points.')

	out(gt(thirty(g.players[2])) name(g.players[2]) ' had '
.		cardinal(thirty(g.players[2]),'move') ' of thirty or more points.')

	counters()
							:(return)
endgame.end

	define('find(pid,turn)rack,num,inlines,line,moves,mi,m,perms,perm,'
.	 'permi,fline,tline,cline,highest,lowest,i,p,score,move,tried')
.							:(find.end)

*	Find all the valid moves and their scores given the current board
*	and the indicated rack. For each line, find the set of all
*	possible moves for that line. Then for each move check the options
*	(permutations) that can be played from the tiles.  For each
*	specific permutation, see if the resulting line contains only valid
*	words.  If not, go on to the next permutation. If true, then see if
*	all the lines affected by the move contain only valid words.
*	If not, go on to the next permutation. If so, then add up the
*	scores of all new words created by the move.

*	From amongst the valid moves determine the best move as follows.
*	If two moves have different scores, prefer the one with the
*	higher score.

*	The 'cost' of a move is the sum of the values of the tiles in the
	move; so want to keep cost low to save higher value tiles for
*	later moves. If two moves have the same score and different costs,
*	prefer the move with the lower cost.  If two moves have the same
*	score and cost, while one uses the letter 's' and the other doesn't,
*	prefer the move that doesn't use the letter 's'.

*	Find returns the best move as defined above, or null if it is unable
*	to find a valid move.

*FIND*
find

*	See if first move, in which case call start()

	find = eq(turn,1) start(pid)			:s(return)

	rack = rack(g.players[pid])
	lines = copy(g.lines)
	inlines = copy(lines)
	g.highest = 0;* highest score this turn
	g.lowest = 0;* lowest cost this turn
	num = 0

find.line

	gt(add1(.num),30)				:s(find.done)
	line = lines[num]
*	out(ne(g.tracing) 'Find.line ' lpad(lineid(num),3) ' ' show.line(line))
	moves = scan(pair(num,line),rack)		:f(find.line)
	mi = 0

find.move

	add1(.count.moves)
	move = moves[add1(.mi),2]			:f(find.line)
*	out(ne(g.tracing) 'Find.move mi ' mi ' ' show.move(move,'find'))
	points(move) =
	permi = 0

*	The rack will almost always have at least two, and sometimes three,
**	identical letters.  Use TRIED to track texts that have been tried,
*	to avoid duplicate testing for validity of the same text.

	tried = table(500)

	perms = g.permutations[text(move)]		:s(find.perm.next)

*	Something must be wrong with the requested permutation

	out('fatal permutation request ',text(move)) :(end)

find.perm.next

	perm = perms[add1(.permi)]			:f(find.move)
	ident(perm)					:s(find.move)
	find.perm(rack,perm,num,move,inlines,tried)	:f(find.perm.next)

find.score

	score = 0

*	out(ne(g.tracing) 'Found valid move ' show.move(move) ' in '
*.		show.pair(pair(num,line)))

*	Score the line by summing the scores of the lines saved in clines.

*	out(ne(g.tracing) 'valid move :' line '  move '  id(move) ' '
*.		size((text(move)) '  '
*.		free(move)[1] '...' free(move)[size(text(move))]
*.		' ' text(move))

	add1(.count.valid)
	move = copy(move)

*	out(ne(g.tracing) 'Find cross ' show.move(move) '  text=' text(move))
*	ne(g.tracing) show.move(move)
*	ne(g.tracing) show.play(move)
*	out(ne(g.tracing) 'Find calling scoremove')

	points(move) = +scoremove(move)
	g.cln = 0;* reset for next permutation
	find = isbest(move) copy(move)			:(find.perm.next)

find.done

	ident(find)					:s(find.fail)
							:(return)
find.fail

*	out('find failed ')

	output = ident(find) 'find FAILED, no move found.'

							:(freturn)
find.end

	define('find.perm(rack,perm,num,move,inlines,tried)'
.		'text,lines,iline,i,p,cline')	:(find.perm.end)

*	Assess effect of permutation, failing if it doesn't
*	produce a valid movel

find.perm

*	NOTE: THE LOOP BELOW IS THE CRITICAL INNER LOOP OF THIS PROGRAM.
*	TIME SPENT SPEEDING THINGS UP ELSEWHERE WILL HAVE LITTLE EFFECT.
*
*	For example, given a move of length 7 with a rack of 7 letters,
*	we need to account for the slightly over 5000 permutations of
*	the letters that can be used here. And note this is just
*	for one possible move ...
*
*	Since most racks will contain duplicate, or even triplicate,
**	instances of the same letter, the table TRIED is used below.
*	This cut the running time of the program by a factor of two
*	when first introduced.

	add1(.count.perm)
	count.cells = count.cells + size(perm)

	g.cln = 0

	text = place(perm,rack)

*	See if we have already tested this text.

	differ(tried[text])				:s(freturn)
	tried[text] = 1;* note that we have reviewed this text


	lines = copy(inlines);

*	Insert the letters from the tiles corresponding to the
*	permutation into the selected blank cells in the line.
*	The digit '1' selects the first tile, the digit '2' the second,
*	and so on.  Then see if the result gives a valid line. Move
*	to the next permutation if not.

	text(move) = perm
	iline = insert(lines[num],move)
	checkline(place(iline,rack))			:f(freturn)

*	Move is valid on this line, so check validity on crossing
**	lines.Save the valid lines in CLINES for scoring if move
*	proves valid.

*	We could use the clines() procedure for this, but in this loop
*	every statement counts, so in effect we build clines on the fly.
*	Since almost all permutations will result in junk, we want to
*	detect junk as soon as possible so we can move on without
*	needless effort.

	text(move) = text

*	out(ne(g.tracing) 'Find valid first '
*		show.move(move) ' ' show.line(line))

	g.clines[add1(.g.cln)]
.			= pair( id(move), insert(lines[num],move))
	i = 0

*	Check the crossing lines, constructing them as needed,
*	to make sure the move is valid.

find.perm.cross

*	out('find cross ')

*	If next assignment fails, we have finished checking the
*	permutation without finding a valid move, and so return failure.

	p = free(move)[add1(.i)]			:f(return)
	cline = cline(lines,move,p,substr(rack,substr(perm,i,1),1))
	checkline(line(cline))				:f(freturn)

*	out(ne(g.tracing) 'Find valid checkline ' line(cline))

	text(move) = place(text(move),ucase(rack))

*	out(ne(g.tracing) 'Find text ' text(move))

	g.clines[add1(.g.cln)] = cline			:(find.perm.cross)

find.perm.end

	define('game(mode)players,player,opn,move,i,li,offset,open.word,'
.		'open.score,n,tiles,moves,li,passed,board,lfn') :(game.end)

**	Play a game of fribble. MAX is the maximum number of moves.
*	Mode is
*		one to have fribble play a game with itself,
*		two to let you play against fribble, and
*		three to work with fribble to play with another person,
*		who may be using fribble themself, but good for them!

*GAME*
game

*	Test to see if log file needed. Even if not, we always call log()
*	function. It will do nothing if no log file. This avoids need
*	to test for presence of log file before each call to log().

	eq(g.log)					:s(game.setup)

*	Open log file.

	g.logfile.name = datename(g.date) '.fri'
	output(.g.logfile,g.logfile.channel,g.logfile.name)  :s(game.log)
	out('unable to open log file ',g.logfile.name)	     :(game.setup)

game.log

	log('* game ' mode)
	log('* version ' g.version)
	log('* time.start ' time())
	log('* date.start ' g.date)
	log.tiles()
	log.player(1)
	log.player(2)

game.setup

	pid = 2;* set to two so will become one when loop first entered

game.turn

	add1(.g.turn)
	log('turn ' g.turn)

*	ne(f.trace) out('g.turn=' g.turn ' g.maxmoves=' g.maxmoves)
	gt(g.turn,g.lastmove + 3)
.  	  out('Game over - too many turns with no move.') :s(game.over)

	gt(g.turn,g.maxmoves)
.		out('Game over -- too many turns ('
.		g.maxmoves ').') :s(game.over)

	pid = (eq(pid,1) 2, 1)

	player = g.players[pid]

	out('Move ' number(g.turn) ' for player ' name(player)
.		 (differ(g.tilemanager) ', with tiles "'
.		show.tiles(rack(player),'A'),'')	'".')

	turn(pid,mode)			:f(game.turn.fail)s(game.turn)

game.turn.fail

*	Here if turn failed because no move could be found.
*	Try to swap three tiles

	out('no move, swapping tiles.')
	rack(player) = swap(pid,3)			:(game.turn)

game.fail

*	Here if no move found.

	out('No move found.')

*	Here if no move found, in which case the return value is
**	a set of swapped tiles. If MOVE is null, then pass.

	differ(move)					:s(game.swap)
	add1(.passed)
	out(gt(passed,6) ' Too many passed moves.')	:s(game.over)
	out('Player ' name(player) ' passes.')		:(game.turn)

game.swap

	out('swapping tiles pid=',pid)
	rack(player) = swap(pid,3)
	out('Player ' name(player) ' swapped tiles.')
	out('Player ' name(player) ' now has tiles '
.		show.tiles(rack(player))) :(game.turn)

game.over

	endgame()

*	Complete log file.

	log('* total.1 ' total(g.players[1]))
	log('* total.2 ' total(g.players[2]))
	log('* date.finis ' date(2))
	log('* time.finis ' time())
	log('endgame')

	differ(logfile) endfile(g.logfile.channel)
							:(return)

game.end

	define('log.tiles()')				:(log.tiles.end)

*	Write tiles set to log file

log.tiles

	log('tiles  "' g.tiles '"')		:(return)

log.tiles.end

	define('log.player(pid)')			:(log.player.end)

*	Write player description to log file.

log.player
	log('player ' pid ' ' show.player(pid))
							:(return)

log.player.end

	define('grid(lines,start)i,r,c,line')		:(grid.end)

**	Construct a grid from a sequence of lines beginning at index START,
*	(1..15 for rows, 16..30 for columns.

*GRID*
grid

	grid = array('15,15',' ')
	start = ident(start) +1
	start = (le(start,15) 1, 16)
	gt(start,15)					:s(grid.col)

*	Here to build grid from the rows.

	r = 0

grid.nextrow

	gt(add1(.r),15)					:s(grid.done)
	line = lines[r]					:f(grid.3)
	i = 0
grid.r

*	out('grid r ' r '  ' i + 1 ' ' substr(line,i + 1,1))
	grid[r,add1(.i)] = substr(line,i,1)		:s(grid.r)f(grid.nextrow)

grid.col

*	Here to build grid from the columns.

	c = 14;* set to c will index first column after entering loop below.

grid.nextcol

	gt(add1(.c),30)					:s(grid.done)
	line = lines[c]
	i = 0

grid.c

	grid[add1(.i),c] = substr(line,i,1)		:s(grid.c)f(grid.nextcol)

grid.done						:(return)

grid.end

	define('hline(g,r)')				:(hline.end)

**	Return the horizontal line of grid G corresponding to
**	row R as a string.

*HLINE*
hline
	r = +r
	hline = g[r,1] g[r,2] g[r,3] g[r,4] g[r,5]
.		g[r,6] g[r,7] g[r,8] g[r,9] g[r,10]
.		g[r,11] g[r,12] g[r,13] g[r,14] g[r,15]
							:(return)
hline.end


	define('insert(line,move,upper)c,f,i,text')	:(insert.end)

*	Insert the text of a move into its free list of empty
*	cells in the line of the move.  Express the text in upper case
**	if UPPER is not null.

*INSERT*
insert
	add1(.count.insert)
	text = (differ(upper) ucase(text(move)), text(move))
	f = free(move)
	c = size(text(move))
	ne(f[c] - f[1], c - 1)			:s(insert.chars)

*	Here if cells are contiguous. Insert text after part before it,
*	and before part after it.

	add1(.count.insert.contig)

	insert = substr(line, 1, f[1] - 1) text substr(line, f[c] + 1)
	out(ne(size(line),15) 'insert failure ' line)		:s(end)
							:(return)
insert.chars

*	Here if cells not contiguous. Unpack the line, insert the
*	move text, and pack it back up.

	add1(.count.insert.split)

	insert = unpack(line)

insert.ch

	gt(add1(.i),size(text(move)))			:s(insert.done)
	insert[free(move)[i]] = substr(text,i,1)	:(insert.ch)

insert.done

	insert = pack(insert)				:(return)

insert.end

	define('isbest(move)')			:(isbest.end)

*	Test the score of a move to see if it the best yet seen in a turn.

*ISBERT*
isbest
	out(ne(f.showscore) 'Find points(move) ' points(move)
.		'  highest=' g.highest ' lowest=' g.lowest)

	lt(points(move),g.highest)			:s(freturn)
	gt(points(move),g.highest)			:s(isbest.new)

*	Here if points equal, look for lower cost

	lt(cost(text(move)),g.lowest)			:s(isbest.new)
	gt(cost(text(move)),g.lowest)			:s(freturn)

*	Here if same points and cost, see if one uses 's' and the
*	other doesn't.  Continue search if current best doesn't use 's'.

	text(find) ? break('s')				:f(freturn)

*	Here if current best uses an 's'.
*	Continue if new move also uses 's'.

	text(move) ? break('s')				:s(freturn)

isbest.new

*	Here to add the new best move.

	g.highest = points(move)
	g.lowest = cost(text(move))
*	out(ne(g.tracing) 'find NEW BEST move ' show.move(move))
							:(return)
isbest.end

	define('lcase(s)')				:(lcase.end)

*	Convert argument to lower case.

*LCASE*
lcase

	lcase = replace(s,&ucase,&lcase)		:(return)

lcase.end

	define('less(str,sub)before,after')		:(less.end)

**	Less removes the first instance of each character in SUB from *str*,
**	where SUB is a substring of *str*.

*LESS*
less
	ident(str)					:s(return)
	less = str

less.ch
	sub len(1) . ch =				:f(return)
	less break(ch) . before  ch rem . after
	less = before after				:(less.ch)

less.end

	define('lineid(num)')				:(lineid.end)

**	Returns row or column id corresponding to line number NUM.

*LINEID*
lineid

	lineid = (le(num,15) 'r' lpad(num,2,0), 'c' lpad(num - 15,2,0)) :(return)

lineid.end

	define('lines(g)i')				:(lines.end)

**	Express the grid G as a sequence of lines, with the
*	first fifteen consisting of the rows and the last
*	fifteen consisting of the columns.

*LINES*
lines

	lines = array(30)

lines.next

*	Make sure all entries in lines are in lower case,
*	 since we enter moves in g in upper case.

	gt(add1(.i),15)				:s(return)
	lines[i] = lcase(hline(g,i))
	lines[i + 15] = lcase(vline(g,i))		:(lines.next)

lines.end

	define('log(text)')				:(log.end)

*	Write text to logfile if making a log.

*LOG*
log
	eq(g.log)					:s(return)

	g.logfile = text				:(return)

log.end
	define('m(id,str,text)fi,free,len,pos')		:(m.end)

*	Create move in line with given id and text.
**	STR is one of the following:
*	  integer	gives starting position, in range 1..15
*	  string that can be converted to integer, treat as in integer case
*	  string giving list of empty (open) cells used, with entries
*			separated by spaces.

*	For example, the following each specify the word 'fribble'
*	starting at position 6 in row 8.

*		m(r8,6,'fribble')
*		m(r8,'6 7 8 9 10 11 12','fribble')

*M*
m
	free = array(size(text))

*	out('m str' str)
	str break(' ')					:s(m.list)
	pos = +str					:f(m.error)

m.pos

	add1(.len)
*	out('pos fi ' fi ' ' pos + (fi - 1 ))
	free[add1(.fi)] = pos + (fi - 1)		:s(m.pos)f(m.done)

m.list

*	Prepare for m.next loop.

	str = str ' '

m.next

	str break(' ') . pos span(' ')  =		:f(m.done)
	add1(.len)
	free[add1(.fi)] = pos				:(m.next)

m.error

	out('m(id,str,text) error - .') :(freturn)

m.done

	ne(len, size(text)) out('m size mismatch,try again'):s(freturn)

	out('m.done id=' id ' text=' text ', free[1]='
.		free[1] ' free[n]=' free[size(text)])

	m = move(id,free,text)				:(return)

m.end

	define('makemove(pid,move)player,board,lines,id') :(makemove.end)

**	Make a move for player with id PID, and return its value.

*MAKEMOVE*
makemove

	player = g.players[pid]
	makemove = move
*	out(ne(g.tracing) 'Game move ' show.move(move))
	g.lastmove = g.turn
	total(player)	= total(player) + points(move)
	thirty(player)	= ge(points(move),30) thirty(player) + 1
	highest(player) = gt(points(move),highest(player)) points(move)
	playmove(move)
	id = lineid(id(move))
	out(	name(player) ' played "' show.tiles(text(move)) '" for '
.		number(points(move)) ' points,'
.		' starting at ' (ident(substr(id,1),'r') 'row ', 'column')
.		' ' number(+substr(id,2))
.		', position ' number(free(move)[1]) '.')

	out('Score now: '
.		name(g.players[1]) ', ' number(total(g.players[1]))  '; '
.		name(g.players[2]) ', ' number(total(g.players[2]))  '. ')

	out('B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 '
.	    'N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 ')
	out()

*	Display move in grid with just this move in upper case by saving
*	the board, playing the move with the text in upper case, showing it,
*	and then restoring the board to its saved state.

	board = copy (g.board)
	lines = copy(g.lines)
	text(move) = ucase(text(move))
	playmove(move)
	text(move) = lcase(text(move));* restore
*	show.grid(g.board)
	g.board = board
	g.lines = lines
*	show.lines(g.lines,'Lines')
*	show.grid(g.used)
	g.used.lines = lines(g.used)
*	Update lines affected by grid changes to maintain consistency.

	g.bonus.lines = lines(g.bonus)

	g.lines = lines(g.board)

*	Fold g.lines into lower case so only new moves made later will
*	display in upper case.

	li = 0

makemove.fold

	g.lines[add1(.li)] = lcase(g.lines[li]) :s(makemove.fold)

*	Rebuild board since lines have changed.

*	out('rebuilding board')
	g.board = grid(g.lines)
							:(return)
makemove.end

	define('move.input()mov,line,out,cells,start,text')	:(move.input.end)

*	Enter move.inputly (by hand).

*MANUAL*
move.input
	ne(f.trace) out('getting move move.inputly')
*	Here to enter the move move.inputly



move.input.in
	out('enter move row/column')
	start = terminal
	out(' you entered ' start)
	out()

	out('enter cell(s)')
	cells = terminal
	out(' you entered ' cells)
	out()

	out('enter text')
	text = terminal
	out(' you entered ' text)
	move.input = 'm(' start ',"' cells '","' text '")'
	out()
							:(return)

	move.input = input.user()				:f(end)
	:(return)
	ident(move.input)					:s(return)
	move.input ( 'pass' | 'swap' | 'resign' | 'quit') :(return)
	move.input = move.input					:(return)

	move.input = eval(move.input)				:f(move.input.error)

*	ident(datatype(move.input),'move') out(show.move(move.input))	:f(move.input.error)

	ne(g.turn,1)					:s(move.input.check)

move.input.check

	valid(move.input)					:s(return)

	out('need to enter a valid move')		:(move.input)

move.input.error

	out('move.input error evaluating ' line)		:(freturn)

move.input.end

	define('number(n)')				:(number.end)

**	If N can be represented as a string of one or two words
**	then return that string. Otherwise return N.

number
	number = eq(n) 'zero'				:s(return)
	number = g.numbers[n]
	differ(number)					:s(return)
	number = n					:(return)
number.end

	define('order(tiles)chars,ch,c1,c2,swaps,i,v1,v2') :(order.end)

**	Sort the tiles in TILES according to their value, with
*	least valuable first.  Though 's' has a nominal value of 1,
*	its actual value is greater, since almost a third of
*	the words in the dictionary are plurals. Give 's' a value
*	of 5 for the purpose of the sort.

*ORDER*
order
	order = le(size(tiles),2) tiles			:s(return)
	chars = unpack(tiles)
							:(order.loop)
order.next

	eq(swaps,0)					:s(order.done)
	swaps = i = 0

*	Loop through chars, swapping out of order characters,
*	 until all characters are properly ordered.

order.loop

	c1 = chars[add1(.i)]				:f(order.next)
	c2 = chars[i + 1]				:f(order.next)
	v1 = (ident(c1,'s') 5, g.value[c1])
	v2 = (ident(c2,'s') 5, g.value[c2])
	le(v1,v2)					:s(order.loop)
	ch = c2
	chars[i + 1] = c1
	chars[i] = ch
	add1(.swaps)					:(order.loop)

order.done

	order = pack(chars)				:(return)

order.end

	define('out(text1,text2,text3)type1,type2')	:(out.end)

*	Output a line conisting of TEXT1, TEXT2 enclosed
*	in brackets, followed by TEXT3.

*OUT*
out
	output = text1 (differ(text2) '[' text2 ']', '')  (differ(text3) text3, '') :(return)

	differ(text2)				:s(out.text2)

*	Here if just text1.

	output = text1				:(return)

out.text2

	type2 = dt(text2)
	type3 = dt(text3)
*	output = 'dt(type2) ' dt(type2)
*	output = 'dt(type3) ' dt(type3)
	ident(datatype(text2),'string')			:s(out.2)
*	output = 'out second argument not integer or string,'
*.	' but of type ' type2
*.						:(error)

out.2

	ident(type3,'integer')			:s(out.3)
	ident(type3,'string')			:s(out.3)

out.3
	type.ex(text3,'string')			:s(out.ok)
	type.ex(text3,'integer')			:s(out.ok)
*	output = 'out third argument not integer or string,'
*.	' but of type ' type3
*.						 :(error)

out.ok

	output = text1 ' [' text2 ']' text3		:(return)

out.end

*	pack.sizes = array(30)

	define('pack(chars)n,i')			:(pack.end)

**	Pack the array of characters CHARS into a line.

*PACK*
pack
	n = +prototype(chars)
	ne(n,15)					:s(pack.chars)

*	Almost all calls to pack are to pack a line from the grid,
*	so do it directly, and so avoid quadratic behavior
*	if concatenate characters in loop.

	pack =  chars[1]  chars[2]  chars[3]  chars[4]  chars[5]
.		chars[6]  chars[7]  chars[8]  chars[9]  chars[10]
.		chars[11] chars[12] chars[13] chars[14] chars[15]

pack.chars
	pack = pack chars[add1(.i)]		:f(return)s(pack.chars)

pack.end

	define('place(txt,rack)')			:(place.end)

**	Place the permutation digits in TXT with the
**	corresponding tiles from RACK.

*PLACE
place

	place = replace(txt,substr('1234567',1,size(rack)),rack)
							:(return)
place.end


	define('playmove(move)i,p,r,c,ch')		:(playmove.end)

**	Play move MOVE, updating the board and related objects.

*PLAYMOVE*
playmove

	id = id(move)
*	out('enter playmove ' show.move(move))
*	out('free ' prototype(free(move)))

playmove.ch

	p = free(move)[add1(.i)]			:f(playmove.done)
	r = row(id,p)
	c = column(id,p)
	ch = substr(text(move),i,1)
*	out('playmove p=' p ' i=' i ' r=' r ' c=' c ' ch=' ch)
	g.board[r, c] = ch
*	out('playmove r=' r ' c=' c ' char=' g.board[r,c])
	g.used[r,c]   = 1
	g.bonus[r, c] = ' ' :(playmove.ch) ;* indicate bonus no longer available

playmove.done
*	out('playmove.done i=' i)
	out(ne(g.tracing) 'playmove returns')
							:(return)
playmove.end

	define('prefix(str,pre)word')			:(prefix.end)

*	Prefix takes a list of space-separated words str and prefixes each
*	with the string pre.

*PREFIX*
prefix

	str = str ' ';* so each word followed by space

prefix.1

	str break(' ') . word span(' ')  =		:f(return)
	add1(.prefixcount)
	prefix = append(prefix, pre word,'A')		:(prefix.1)

prefix.end

	define('random(n)')				:(random.end)

*	Return integer uniformly distributed in 1,2,...,n.
*	If n=0 returns real uniformly distributed in the interval [0,1].
*	The Algorithm is based on that in section 16.1 of "Algorithms in SNOBOL4,"
*	James F. Gimpel, John Wiley and Sons, 1976.

*RANDOM*
random

	g.random_var = remdr(g.random_var * 4676, 414971)
	random  = g.random_var / 414971.0
	random = ne(n) convert(random * n,'integer') + 1
							:(return)
random.end

	define('randomseed()s,c')			:(randomseed.end)

*	Compute seed for random number generator from date and time.

*RANDOMSEED*
randomseed
	g.random_var =
	s = g.date
	s = replace(s,'/:-','   ')

*	Get all the digits in s.

randomseed.loop

	s len(1) . c =					:f(randomseed.done)
	ident(c,' ')					:s(randomseed.loop)
	g.random_var = g.random_var c			:(randomseed.loop)

randomseed.done

*	Reverse the seed so digits depending on time come first.

	g.random_var = +reverse(g.random_var	)
							:(return)

randomseed.end

	define('reader(filename)n')			:(reader.end)

*	Return file as table of lines, with zero-th entry giving number
*	of lines.

*READER*
reader
	differ(filename) input(.file,g.channel.temp,filename)		:s(reader.opened)

	out('unable to open reader file ' filename '.') :(freturn)

reader.opened

	n = 0
	reader = table(100)

reader.next

	reader[add1(.n)] = (ident(filename) input, file) s:(reader.next)

*	Here at end of file, convert map to array of lines.

	reader[0] = n - 1;* line count

	differ(filename) endfile(g.channel.temp)
							:(return)
reader.end

*	One-time initialization for replay()

	str = 'date endgame game move play rack tiles total turn version '
	replay.ops = table(10)

replay.init
	str break(' ') . op ' ' =			:f(replay.init.done)
	replay.ops[op] = 1				:(replay.init)

replay.init.done

	define('replay(option)line,command'):(replay.end)

*	Replay commands from previous game.
**	If OPTION is an integer, replay that number of commands
**	from the replay file. If OPTION is a string not convertible
*	to an integer, prepare for replaying by reading in the lines
*	from that file.

*REPLAY*
replay
	g.replay.lines = reader(option)			:s(replay.lines)
	out('reader returned ' prototype(ops) ' commands.')
	out('error reading commands from ' option)	:(freturn)

replay.lines

	g.replay.i = 0;* set up for replaying.
	g.replay.n = commands[0]			:(return)


replay.next
	gt(add1(.g.replay.i), g.replay.n)		:s(replay.done)
	line = g.replay.lines[g.replay.i]		:f(replay.done)
	out('replaying line ' g.replay.i ' |' line '|')
	ident(line)					:s(replay.next)
	line '*'					:s(replay.next)
	line span(&lcase) . command =
	out('replay.op=' command)
	differ(replay.ops[command])			:s($('replay.' command))

	out('replaying unknown command ' command ', ignore.')	:(replay.next)

replay.endgame
							:(replay.done)
replay.move
	line span(' ') len(1) . pid span(' ') =
	out('replay.move evaluating |' line '|')
	move = eval(line)
	out('replaying move datatype=' datatype(move)  ','  show.move(move))
	show.play(makemove(pid,move))
							:(replay.next)
replay.player
	line '.' len(1) . pid span(' ') =
	g.players[pid] = eval(line)
							:(replay.next)
replay.rack
	line '.' len(1) . pid =
	line = ' rack(g.players[ ' pid '] = ' line
	out('replay.rack ' line)
	eval(line)
							:(replay.next)
replay.tiles
	line = ' g.tiles = ' line
	out('replay.tiles ' line)
	eval(line)
							:(replay.next)
replay.turn
	line span(' ') span('0123456789') . turn =
	g.turn = turn					:s(replay.next)

replay.done
							:(return)
replay.end

	define('replenish(pid)player,rack,s')		:(replenish.end)

*	Replenish a player's rack. Do this from the tiles is g.tilemanager is
*	set, or get the new tiles from the user otherwise.

*REPLENISH*
replenish

	player = g.players[pid]
	differ(g.tilemanager)				:s(replenish.auto)

replenish.manual

	out('enter rack for player: ' show.player(pid))
	replenish = lcase(input)			:f(replenish.eof)
	ident(replenish) out('no input - try again.')	:s(replenish.manual)
	gt(size(replenish),7) out('too many letters |' replenish
.			'|, try again.') :s(replenish.manual)
	s = replenish
	s span(&lcase) =
	differ(s) out('non-alphabetic character - try again.')
.							:s(replenish.manual)

							:(return)
replenish.eof

	out('end of data on input - bye ')		:(end)

replenish.auto

	replenish = rack(player)

	eq(size(replenish),7)				:s(return)

	replenish = replenish take(7 - size(replenish)) :(return)

replenish.end

	define('row(num,pos)')				:(row.end)

*	Returns row corresponding to position POS in line NUM.

*ROW*
row
	row = ((le(num,15) num, pos))		:(return)

row.end

	define('scan(pair,rack)num,line,i,pi,open,oi,nopen,n,'
.			'first,pos,move,sub,len')	:(scan.end)

*	Scan the given line to find the places where a valid move can be made.
*	At least one cell in a move must be adjacent to an occupied cell.
**	LINE is the line to be scanned, and *num* gives
*	its position on the board.

*SCAN*
scan

	line = line(pair)
	num = num(pair)
*	out(ne(g.tracing) 'Scan line ' lineid(num) ' '
*		show.line(line) ' ' show.hex(line))

**	Allocate and fill in OPEN, an array giving the
*	positions of the open cells.

*	Fail if no empty cells.

	open = avail(pair)				:f(scan.done)

*	Nopen is the number of open cells in the line.

	nopen = +prototype(open)

	pi = 0

scan.first

	first = open[add1(.pi)]			:f(scan.done)

**	FIRST is the position of the first letter in the move.

**	The number of moves N that can be made starting at a given
**	position in OPEN depends on the number of tiles in the rack,
*	and the number of remaining open cells in the line.

	n = +size(rack)
	n = gt(n, nopen - pi) nopen - pi;* number of remaining open cells

*	Try for moves of length len=n,n-1...1 starting at position
**	FIRST in the line.

	len = n + 1;* prime for loop

scan.len

	le(len = len - 1)				:s(scan.first)

*	out(ne(g.tracing) 'Scan first=' first ' left =' (nopen - pi)
*.		 ' n=' n ' len=' len)

*	At least one cell to be occupied by this move must be
*	adjacent to a used cell.

	oi = 0

scan.used

	gt(add1(.oi),len)				:s(scan.len)
	pos = open[pi + oi - 1]				:f(scan.first)
*	out(ne(g.tracing) 'Scan oi=' oi ' pos=' pos)
	adjacent(row(num,pos),column(num,pos)) 		:f(scan.used)s(scan.text)

**	If a move of length LEN has no adjacent cells, then no move
*	of lesser length can have adjacent cells, so we can advance to
*	the next possible starting point.

							:(scan.first)
scan.text

*	Here if adjacent cell found. Set text of move to
*	the permutation specification.

	sub = subarray(open,pi,len)			:f(scan.len)
	move = move(num,sub,size(rack) '?' len)		:f(scan.len)
*	out(ne(g.tracing) 'Scan move ' show.move(move))
	scan = ident(scan) table()
	add1(.count.scanned)
	scan[count.scanned] = move			:(scan.len)

scan.done

	ident(scan)					:s(freturn)
	scan = convert(scan,'array')
 							:(return)
scan.end

	define('scoreline(pair)'
.		'line,word,words,wi,n,start,ch,i,bonus,mult,val') :(scoreline.end)

*	Compute the score of a move on a given line. All the letters of
*	the move will be in upper case on the board so the score of the move
*	is the sum of the scores of all the words with upper case letters in
*	them, for both rows and columns. This function should only be called
*	for lines which have an upper case letter in them as a result of the move.

*SCORELINE*
scoreline

	scoreline = 0
	line = line(pair)
	empty(line)					:s(return)
	bonusline = g.bonus.lines[num(pair)]
	line break(&ucase)				:f(scoreline.error)
	words = words(line)				:f(scoreline.done)
	wi = 0

scoreline.word

	start = words[add1(.wi),1]			:f(scoreline.done)
	word = words[wi,2]
*	add1(.count.scoreline)
	ne(g.tracing) out('scoreline wi=' wi ' start=' start ' word=' word
.		 '.' ' count ' count.scoreline)
	word break(&ucase)				:f(scoreline.word)
	n = size(word)

*	Words of just one letter don't contribute to scoreline since
*	they result from a crossing line.

	eq(n,1)						:s(scoreline.word)

	line = substr(line,start)

* 	Extract corresponding part of bonus line.

	bonusline = substr(g.bonus.lines[num(pair)],start);

	i = 0
	mult = 1;* multiplier value for double and triple word cases.

scoreline.char

	gt(add1(.i),n) 			:s(scoreline.char.done)
	ch = substr(word,i,1)
	bonus = +substr(bonusline,i,1)

*	Update scoreline according to value of letter. Always get at
*	least the value of the letter, and may get double or
*	triple the letter value.

	val = g.value[ch]
	val = (eq(bonus,2) val * 2, eq(bonus,3) val * 3, val)
	scoreline = scoreline + val
	ne(g.tracing) out('ch=' ch ' val=' val ' scoreline now ' scoreline)

*	Update double/triple word multiplier.

	mult = gt(bonus,3) mult * (bonus - 2)		:(scoreline.char)


scoreline.char.done

	scoreline = ne(scoreline) scoreline * mult
	ne(g.tracing) out('mult=' mult ' scoreline=' scoreline)
						:(scoreline.word)
scoreline.error

	out('error tracing line with no new move ' line(pair))
	scoreline = 0					:(return)

scoreline.done

*	ne(g.scoremove) out('scoreline returns ' scoreline)
							:(return)
scoreline.end

	define('scoremove(move)i,p')			:(scoremove.end)

*	A move's score is the sum of the scores of its own line
*	and its crossing lines.

*SCOREMOVE*
scoremove

*	In order to determine which words on the board would be
**	formed by making this move, rebuild CLINES but with the
*	new tiles in uppercase. This way, a word is new if and only if
*	it contains an upper case character. The score is then the
*	sum over all the lines of the scores of the words containing an
*	upper-case character. At most one word in each line of grid will
*	contain an upper-case character.

*	Generate move's line and its cross lines with the move's
*	text in upper case.

	clines(move,1);

*	ne(g.tracing) show.clines()
*	ne(g.tracing) out('scoremove move=' show.move(move))
*	ne(g.tracing) out('g.cln=' g.cln)

	i = 0

scoremove.line

	ne(g.tracing) out('scoremove line' i)
	gt(add1(.i),g.cln)				:s(scoremove.done)
	ne(g.tracing) out('scoremove i=' i ' scoremove =' scoremove)
	scoremove = scoremove + scoreline(g.clines[i])	:(scoremove.line)

scoremove.done

*	There is a bonus of 35 points for playing seven tiles in one move.

	scoremove  = eq(size(size(text(move))),7) scoremove + 35;

	ne(g.tracing) out('scoremove returns ' scoremove)
							:(return)
scoremove.end

	define('seen(perm,rack,test)p,c,cp,cmap,next,signature,map,d,dp,dmap')	:(seen.end)

*	Test if a permutation has already been processed in this turn.

*	Racks will typically contain duplicate letters. We can make use of this
*	to avoid useless duplication of effort.
*
*	For example, if first and third letters are the same then in any permutation
*	we can interchange the positions of this letter with no effect. Simply put,
* 	if there are two "E" tiles, it doesn't matter in what order we play them.
*
*	For example, given the rack 'FRIBBLE', there are two B's, at positions five
*	and six, so the signature for permutation '1234567'  is
*
*		1234557
*
*	If later see a permutation such as '1234657', it will have
*	the same signature, and so will not need to investigate
*	futher -- we can move directly to the next permutation.

**	Define a map DMAP from digits to characters by
**	iterating over the permutation. If D is the
**	digit at position P, let *c* be the character
**	at position D in the rack. This is the character
**	corresponding to D. Set *dmap[d]* to *c*.

**	Define a map CMAP from characters to digits by iterating
**	over the rack. Let C be the character at position *p*.
*	If *cmap[c]* is null, this is the first instance of *c*;
*	set *cmap[c]* to *p*. This will be the value used to
**	represent each instance of C in the new permutation.

*	Iterate over the permutation to build an equivalent
**	permutation. Let D be the digit at
**	position P. Set *c* to the value of *dmap[d]*, then
* `	set the next digit in the new permutation to the value of
*	*cmap[c]*.


*	The result is the signature, or normal form, of the permutation.

**	Look up the result in the table SEEN. It the value is not
*	null then we have already seen an equivalent permutation,
*	and so return success.

*	If the value is null, enter the new permutation as the representation
*	of the input permutation, and return failure.

*SEEN*
seen
	ident(perm)				:s(freturn)
	ident(rack)				:s(freturn)

	g.cmap = table('cmap')
	g.dmap = table('dmap')
	cp = dp = 0

seen.d
	d = substr(perm,add1(.dp),1)		:f(seen.c)
	c = substr(rack,d,1)
	out('g.map')
	g.dmap[d] = c
						:(seen.d)
seen.c
	c = substr(rack,cp = cp + 1,1)		:f(seen.mapped)
	out('GET seen.c ')
	ident(g.cmap[c]) g.cmap[c] = convert(cp,'string') :(seen.c)

seen.mapped

	dp = 0
	signature =

seen.next

	d = substr(perm,dp = dp + 1,1)		:f(seen.check)
	c = g.dmap[d]
	signature = signature g.cmap[c]		:(seen.next)

seen.check

 :(seen.outed)
	seens = seens + 1
*	gt(seens,10000) :s(end)

	ne(remdr(seens,100)) :s(seen.outed)
	out()
	show(g.dmap)
	out()
	show(g.cmap)
	out()

	 out('seen.check rack=' rack ' ' perm ' -> ' signature)

seen.outed
	g.signature = signature
	count.signature = count.signature + 1

*	Succeed if have already seen this signature.

*	out('seen same perm=' perm ' rack=' rack )

	out('GET seen.outed ')
	differ(g.tried[signature])			:s(return)

*	Here if first encounter with this signature.

	g.tried[signature] = 1
							:(freturn)
*	out('seen new signature ' signature ' perm=' perm ' rack=' rack '.')
*	See if we have seen an equivalent permutation before.

*	Comapute signature of permutation and rack to account for presence
*	any duplicate tiles.


*	:(freturn)
seen.end

	define('shell()ops,key,op')			:(shell.def.end)

*	Simple 'shell' for fribble.

*	Read commands from terminal and execute them.
*	This is meant mainly for debugging, testing
*	and as a way to learn how fribble operates.

*SHELL*
shell
	out('entered shell')
*	s.ok is set to one if last 'eval' command succeeded, zero if it failed.

	s.ok = 0

*	s.move is last move entered in shell

	s.move =

*	s.ops is the list of shell commands.

	s.ops =
. 	'board clear eval find help init letters next move pass play quit '
.	'remove replay score search start tiles valid '

*	s.opabbrev maps abbreviated input to corresponding shell.
*	You need specify only first one or more characters
*	in the operation name.

	s.opabbrev = table(100)

	s.letters = &lcase &ucase

*	s.replay is set to read commands from file 'term' before
*	asking for key board input.

	s.replay =

*	s.v is set to value of last 'eval' operation.

*	Initialize s.optable to acceptable abbreviations for shell
*	operations.  Acceptable abbreviations consist of the initial
*	two or more characters of the operation, up to the
*	full command name itself.


	ops = s.ops

shell.setup.next
	ops break(' ') . op ' ' =		:f(shell.setup.end)
	key = op
	s.opabbrev[substr(key,1,1)] = op
shell.setup.op
	s.opabbrev[key] = op
	key = substr(key,1,size(key) - 1)	:f(shell.setup.next)
	gt(size(key),1)		:s(shell.setup.op)f(shell.setup.next)
shell.setup.end
	tab = char(9)
	out('starting shell')

*	Shell main command loop.

shell.loop
	out('starting replay')
	replay('keyin') :(end)
	out('enter shell loop') :(end)
	ident(s.replay)					:s(shell.term)
	linein = termfile				:s(shell.line)
	linein 'q'					:s(shell.loop)
	s.replay =
	endfile(3)
	output(.termfile,3,'term[-a]')

shell.term

	out('op?')
	linein = terminal ' '				:f(shell.end)

shell.line

	termfile = differ(termfile) linein;* save line
*	out('linein =' linein '.')
	linein span(s.letters) . opin span(' ') rem . operand
.							:s(shell.loop.ok)
	operand = trim(operand)
	out('fail opin =' opin ' operand=' operand '.') :(shell.loop)

shell.loop.ok

	opin = lcase(opin)
	op = s.opabbrev[opin]
	out('op ' opin ' operand ' operand '.')
*	out('op abbrev =' op)

	differ(op)					:s(shell.op)
	out('unknown op: ' op)				:(shell.loop)

shell.op						:($('shell.' op))

shell.board

	show.board(g.board)				:s(loop)

shell.clear

*	Clear the board
	g.board = array('15,15',' ')			:(shell.loop)

shell.end
	out('shell end of input - bye')		:(end)
shell.eval
	out('evaluating ' operand)
	s.v = eval(operand)	:s(shell.eval.succeed)f(shell.eval.fail)
shell.eval.succeed
	s.ok = 1					:(shell.loop)
shell.eval.fail
	out('eval failed, ' &errtext)
	s.ok = 0					:(shell.loop)

shell.find

*	Use find to find best move given current tiles for Player 1.

	s.move = find(1,g.turn)
	show.move(s.move)				:(shell.loop)

shell.game

*	(I know you're wondering, but Fribble wasn't written just
*	so I could I say I wrote a program where it made sense to
*	use the identifier 'shell.game'.)

*	Enter (or leave) game mode, if argument is 'on' ('off').

	s.game = (ident(substr(operand,2,1),'y') 1, 0)
							:(shell.loop)

shell.help
	out(rpad('board',14) 'show board')
	out(rpad('clear',14) 'clear board')
	out(rpad('eval' ,14) 'evaluation expression')
	out(rpad('help' ,14) 'help')
	out(rpad('init' ,14) 're-initialize global variable')
	out(rpad('letters',14) 'show values of letters')
	out(rpad('move' ,14) 'enter move')
	out(rpad('play' ,14) 'play last move')
	out(rpad('quit' ,14) 'exit shell')
	out(rpad('remove' ,14) 'remove (undo) last move played')
	out(rpad('score' ,14) 'score last move entered')
	out(rpad('search' ,14) 'search dictionary for matching words')
	out(rpad('start' ,14) 'make starting move')
	out(rpad('rack tiles',14) 'set rack to tiles, default "fribble"')
	out(rpad('valid' ,14) 'validate move')
							:(shell.loop)
shell.init
	init()						:(shell.loop)

shell.letters
	out(	'B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 '
.		'N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 ')
							:(shell.loop)
shell.move

*	Get move, assume user knows about 'mf' and 'm' functions.

	s.move = eval(operand)
	out('Last move now ' show.move(s.move))		:(shell.loop)

shell.next

*	When not in game mode, next is a no-op.
*	When in game mode, next increments the player id; if the
*	resulting player has the fribble attribute then a move is made
*	on that player's behalf, and another next command is executed.

	ident(s.game)					:s(shell.loop)

	g.turn = g.turn + 1
	g.pid = (eq(g.pid,1) 2, 1)

*	See if player has 'fribble' attribute.

	ident(fribble(g.players[g.pid]))		:s(shell.loop)

	s.move = (eq(g.turn,1) start(g.pid), find(g.pid))
	ident(s.move) out('no move found, so no move made')	:(shell.loop)

	points(s.move) = scoremove(s.move)
	show.play(makemove(g.pid,s.move))
	replenish(g.pid)
							:(shell.loop)
							:(shell.loop)

shell.pass

*	Pass from making a move. This is typically used when the
*	player with pid=1 does not want to make the first move.

	out('Player ' pid ' passes.')
	g.turn = g.turn + 1
							:(shell.loop)

shell.play

*	Play last move entered.

	points(s.move) = scoremove(s.move)
	makemove(g.pid,s.move)
	show.play(s.move)
							:(shell.loop)
shell.quit
	out('exiting')					:(end)

shell.remove
	out('remove not yet implemented')		:(shell.loop)

*	Remove (undo) last move played, by setting its free cells to
*	unused

							:(shell.loop)
shell.replay.

*	Replay input saved in 'term' from prior run. To main user
*	confidence in our programming skills, don't replay 'quit' op.

	replay('keyin')
	s.replay = 1
	input(.termfile,3,'term')
							:(shell.loop)
shell.score

*	Show score computation for last move entered.

	g.showscore = 1
	out('Scoring ' show.move(s.move))
	clines(s.move,1)
	show.clines()
	score = scoremove(s.move)
	points(move) = score
	g.showscore = 0
	out('Move ' show.move(move)
.			' scores ' score ' points.') :(shell.loop)


shell.scoremove

*	g.showscore = 1
	points(move) = findscore()
	out('move is worth ' points(s.move) ' points.')
							:(shell.loop)
	out('do you want to make this move (y or ENTER for yes,'
.					' no otherwise)?')
	ans = terminal				:f(shell.eod)
	ident(ans)				:s(shell.moveon)
	ident(ans,'y')				:s(shell.moveon)
						:(shell.you.move)

shell.search

*	Search dictionary for matching words

	out('search not yet implemented')

shell.start

*	Make starting move using current tiles, default to 'fribble'

	rack(g.players[1]) = ident(rack(g.players[1])) 'fribble'
	s.move = start(1,1)

*	Merge to make the move.
							:(shell.play)

shell.tiles

*	Get rack from operand.

	tiles = operand
	gt(size(tiles,7)) out('truncating to seven tiles')
	tiles = gt(size(tiles,7)) substr(tiles,1,7)
	rack(g.players[1]) = tiles
	out('rack now ' tiles)
							:(shell.loop)

shell.validmove

*	show.move(move)
	out((validmove(move) ' valid move','invalid move'))  :(shell.loop)

*shell.move
shell.moveon

	makemove(g.pid,s.move)
	show.play(move)
							:(shell.loop)
shell.eof

	out('end of input - bye')			:(return)

shell.def.end

	define('show(v)i,ent,type')			:(show.end)

*	Show the value of an expression.

*SHOW*
show
	ident(dt(v),'map') out('show arg type map',dt(v))	:s(error)
	typ = dt(v)
						:($('show.type.' typ))

show.type.array

	show = show.array(v)				:(show.done)

show.type.integer

	show = convert(v,'string')			:(show.done)

show.type.move

	show = show.move(v)				:(show.done)

show.type.pair

	show = show.pair(v)				:(show.done)

show.type.table

	show = show.table(v)				:(show.done)

show.type.string

	show = convert(v,'string')			:(show.done)

show.done
							:(return)
show.end

	define('show.array(ara)i,first,proto,second')	:(show.array.end)

*	Show an array. Fribble uses only one and two dimensional arrays

show.array

	out('show.array dt(ara)',dt(ara))
	proto = prototype(ara)
	out('show.array prototype ' proto)
	proto break(',')				:s(show.array.2)

*	Here for one dimensional array.

show.array.1
	first = ara[add1(.i)]				:f(show.array.done)
	out(lpad(i,3) tab first)			:(show.array.1)

show.array.2
	first = ara[add1(.i),1]		       	  :f(show.array.done)
	out(lpad(i,3) tab show(first) tab show(ara[i,2])) :(show.array.2)

show.array.done

	out()						:(return)

show.array.end

	define('show.board(board,title)b,r,c,ch,line')	:(show.board.end)

*	Show the bonus grid.

*SHOW.BOARD*
show.board

	show.header()

show.board.r

	gt(r = r + 1,15) 				:s(show.board.finish)
	line = lpad(r,2) '|'
	c = 0

show.board.c

	gt(add1(.c),15)					:s(show.board.margin)
	ch = ucase(board[r,c])
	b = g.bonus[r,c]
	differ(ch,' ')					:s(show.board.ch)

*	Here if empty cell, see if there is a bonus to be show.boarded.

	ne(b,1)						:s(show.board.b)

*	Here to show.board empty cell.

	line = line ' -'				:(show.board.c)

show.board.b

* 	Here to show.board bonus.

	ch = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line ch 					:(show.board.c)

show.board.margin

	out(line '|')					:(show.board.r)

show.board.ch

	line  = line ' ' ch				:(show.board.c)

show.board.finish

	out()						:(return)

show.board.end

	define('show.bonus()b,r,c,l,line')		:(show.bonus.end)

*	Show the board.

*SHOW.BONUS*
show.bonus

	show.header('bonus')

show.bonus.r

	gt(r = r + 1,15) 				:s(show.bonus.finish)
	line = lpad(r,2) '|'
	c = 0

show.bonus.c

	gt(add1(.c),15)					:s(show.bonus.l)
	l = g.bonus[r,c]
	line = differ(l,' ') line ' ' l 		:s(show.bonus.c)

* Here for blank cell, show.bonus bonus if applicable

	b = g.bonus[r,c]
	eq(b)						:s(show.b)
* 	Here to show bonus
	l = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line l 					:(show.bonus.c)

show.bonus.b

*	Here to show.bonus empty cell.
	line = line ' -'				:(show.bonus.c)

show.bonus.l

	out(line '|')					:(show.bonus.r)

show.bonus.finish

	out()						:(return)

show.bonus.end

	define('show.clines(move,title)i,p,line,num')	:(show.clines.end)

*	Show the clines array of lines

*SHOW.CLINES*
show.clines

*	show.board(g.board)
*	title  = 'clines' (differ(title) ' ' title, '')
*	out(title)
	out(differ(title) 'clines for ' show.move(move))
	out('    123456789012345')

show.clines.n

	le(add1(.i), g.cln)				:f(return)
	p = g.clines[i]
	num = num(p)					:f(return)
	line = line(p)
	out(lpad(lineid(num),2) ' '  replace(line,' ','.')) :(show.clines.n)

show.clines.end

	define('show.free(free,title)i')		:(show.free.end)

*	Show free array.

*SHOW.FREE*
show.free

	show.free = show.free append(lpad(free[add1(.i)]),3)	:s(show.free)
	show.free = 'Open: ' title ' ' show.free
							:(return)
show.free.end

	define('show.grid(g)r')				:(show.grid.end)

*	Show a grid.

*SHOW.GRID*
show.grid

	show.header()

show.grid.r

	gt(add1(.r),15) 				:s(show.grid.done)
	out(show.hline(g,r))				:(show.grid.r)

show.grid.done

	show.header()
	out()						:(return)

show.grid.end

	define('show.header(label)')			:(show.header.end)

*SHOW.HEADER*
show.header

	out(differ(label) label)
	out('                     1 1 1 1 1 1')
	out('   1 2 3 4 5 6 7 8 9 0 1 2 3 4 5')	:(return)

show.header.end

	define('show.hex(line)ch,i')			:(show.hex.end)

*	Show line with blanks replaced by hex digits showing
*	their position in the line.

*SHOW.HEX*
show.hex

	ch = substr(line,add1(.i),1)				:f(return)
	show.hex = show.hex (ident(ch,' ')
.		substr('123456789ABCDEF',i,1), ch) :(show.hex)

show.hex.end

	define('show.hline(g,row)line,ch')		:(show.hline.end)

**	Returns the line corresponding to row ROW in
**	grid G with two characters per cell.

*SHOW.HLINE*
show.hline

	line = hline(g,row)
	show.hline = '|'

show.hline.ch

	line len(1) . ch = 				:f(show.hline.done)
	show.hline = show.hline ' ' ch  		:(show.hline.ch)

show.hline.done

	show.hline = show.hline '|'			:(return)

show.hline.end

	define('show.line(line)')			:(show.line.end)

*	Show a line with blanks replaced by '.'

*SHOW.LINE*
show.line

	show.line = replace(line,' ','.')		:(return)

show.line.end

	define('show.lines(lines,title)i,line,titled')	:(show.lines.end)

*	Show the lines that are not empty in an array of lines

*SHOW.LINES*
show.lines

	title  = 'lines' (differ(title) ' ' title, '')
	out(itle)

show.lines.n

	line = lines[add1(.i)]			:f(return)
	empty(line)				:s(show.lines.n)
	differ(titled)				:s(show.lines.titled)

*	Don not list header unless at least one non-empty line

	out('    123456789012345')


	titled = 1

show.lines.titled

	out(lpad(lineid(i),2) ' ' replace(line,' ','.')) :(show.lines.n)

show.lines.end

	define('show.move(mov)f,i,ff,n')		:(show.move.end)

*	Show a move.

*SHOW.MOVE*
show.move

	ident(datatype(mov),'integer')			:s(error)
	show.move = 	'move id=' id(mov) ' text=' text(mov)
.			' free[1]=' free(mov)[1]
.			' proto(free) ' prototype(free(mov))
	n = +prototype(free(mov))

show.move.i
	gt(add1(.i),n)					:s(show.move.f)
	ff = free(mov)[i]
	f = append(f,ff)				:s(show.move.i)

show.move.f

	show.move = 'm('
.			lineid(id(mov)) ','
.			"'" f "',"
.			  "'" text(mov) "'"
.			(differ(points(mov)) ',+' points(mov), '')
.	             ')'
							:(return)
show.movefail

	out('free ff failure ')				:(end)

show.move.end

	define('show.pair(pair)')			:(show.pair.end)

*	Show paired item.

*SHOW.PAIR*
show.pair

	show.pair = '{' lineid(num(pair)) ',' "'"
.			replace(line(pair),' ','.') "'" '}'	:(return)

show.pair.end

	define('show.play(move)plines,b,r,c,ch,line')	:(show.play.end)

*	Show the board.

*SHOW.PLAY*
show.play

*	Display move in grid with just this move in upper case by
*	saving the board, playing the move with the text in upper case,
*	showing it, and then restoring the board to its saved state.

	board = copy (g.board)
	lines = copy(g.lines)
	text(move) = ucase(text(move))
	playmove(move)
	plines = lines(g.board)
	text(move) = lcase(text(move));* restore
	g.board = board
	g.lines = lines

*	Collect the lines of the grid.

	lines = array(15)

show.play.l

	gt(add1(.r),15) 				:s(show.play.ll)
	plines[r] = show.hline(board,r)			:(show.play.l)

show.play.ll

	r = 0
	out(lpad('',22) '1 1 1 1 1 1'
.		 lpad('',20) '1 1 1 1 1 1')
	out(lpad('', 4) '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5'
.		 lpad('', 2) '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5')

show.play.r

	gt(add1(.r),15) 				:s(show.play.finish)
	line = lpad(r,2) '|'
	c = 0

show.play.c

	gt(add1(.c),15)					:s(show.play.margin)
	ch = ucase(board[r,c])
	b = g.bonus[r,c]
	differ(ch,' ')					:s(show.play.ch)

*	Here if empty cell, see if there is a bonus to be show.played.

	ne(b,1)						:s(show.play.b)

*	Here to show.play empty cell.

	line = line ' -'				:(show.play.c)

show.play.b

* 	Here to show.play bonus.

	ch = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line ch 					:(show.play.c)

show.play.margin

	out(line  plines[r])				:(show.play.r)

show.play.ch

	line  = line ' ' ch 				:(show.play.c)

show.play.finish

	out(lpad('', 4) '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5'
.		 lpad('', 2) '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5')
	out()						:(return)

show.play.end

	define('show.player(pid)player')		:(show.player.end)

*	Show player description.

*SHOW.PLAYER*
show.player

*	data('player(pid,name,kind,rack,total,thirty,highest)')

	player = g.players[pid]
	show.player =
.		'player('  pid(player)	',"' name(player) '"'  	  	','
.		'player.kind.'	(
.			eq(kind(player),player.kind.auto) 'auto',
.			eq(kind(player),player.kind.foe)  'foe',
.			eq(kind(player),player.kind.solo) 'solo',
.			eq(kind(player),player.kind.team) 'team', ''
.			        )	','
.		'"' rack(player) '",' total(player) ','
.		(gt(highest(player)) highest(player) ,'')
.		')'
							:(return)
show.player.end

	define('show.table(tbl,col)ara,i,key')		:(show.table.end)

*	Show a table.

*SHOW.TABLE*
show.table

	ara = sort(tbl,col)

show.table.next

*	loop:	Get the next tbl key.

	key = ara[add1(.i),1]				:f(show.table.done)

*	Show the entry and continue back to loop.

	out(lpad(show(key),8) ' -> ' show(ara[i,2]))
							:(show.table.next)
show.table.done
	out()						:(return)

show.table.end

	define('show.tiles(tiles)i')			:(show.tiles.end)

*	Show a list of tiles, separated by blanks.

*SHOW.TILES*
show.tiles
	gt(add1(.i),size(tiles))			:s(return)

	show.tiles = append(show.tiles, ucase(substr(tiles,i,1))) :(show.tiles)

show.tiles.end

	define('show.words(words)i,pos')		:(show.words.end)

*	Show results of words() call.

show.words

	pos = words[add1(.i),1]			:f(return)
	out('words ' lpad(pos,2) ' ' words[i,2])	:(show.words)

show.words.end


	define('shuffle()tiles,n,passes,r1,r2,ch')	:(shuffle.end)

*	Shuffle the remaining tiles by randomly swapping.players[2]
*	tiles several times.

*SHUFFLE*
shuffle

	tiles = unpack(g.tiles)
	n = size(g.tiles)
	passes = random(1000) + 500

shuffle.next

	le(passes = passes - 1)				:s(shuffle.done)
	r1 = random(n); r2 = random(n)
	eq(r1,r2)					:s(shuffle.next)
	ch = tiles[r1]
	tiles[r1] = tiles[r2]
	tiles[r2] = ch					:(shuffle.next)

shuffle.done

	g.tiles = pack(tiles)
							:(return)
shuffle.end

	define('spaces(line)n')				:(spaces.end)

*	Count number of spaces in line.

*SPACES*
spaces

	line len(1) . c =				:f(return)
	spaces = ident(c,' ') spaces + 1		:(spaces)

spaces.end

	define('start(pid)player,tiles,perm,perms,permi,free,offset,i,'
.       	'highest,lower,best,n,word,start,score,move,max'):(start.end)

*	Determine best starting.turn. At least one letter in this move
*	must be in the center square (8,8). The only bonus available is
*	double word, for any word of more than four characters.

*	Find the move the highest score. Given two moves with the
*	same score, prefer the one with the lowest tile cost.
*
*	The return value has the form 'm s' where m is the move
*	and s is its score.
*
*	There are seven tiles, so we just try all permutations
*	of length one up to seven.

*START*
start

	max = 7;* maximum number of tiles to play
	player = g.players[pid]
	tiles = rack(player)
	n = 0;* number of tiles to play
	highest = lowest = 0;* best score, lowest cost

*	Assume word will start in column 8

	start = 8

*	Don't use 's' on starting move: save it for later.

	tiles break('s')				:f(start.n)
	tiles = less(tiles,'s')
	max = max - 1

start.n	gt(add1(.n),max)				:s(start.done)

	kind = size(tiles) '?' n
*	out('start.n kind=' kind)
	perms = g.permutations[kind]			:f(start.n)
	permi = 0

start.word

*	Get next word, check that valid, then see if new high score

	perm = perms[add1(.permi)]			:f(start.n)
	word = replace(perm,substr('1234567',1,size(tiles)),tiles)

*	out('kind ' kind ' perm ' perm ' word ' word)
	checkword(word)					:f(start.word)
	add1(.checkwords)

*	Score is the value of the tiles unless the word has five or
*	more characters, in which case the double word bonus
*	at index twelve can be achieved.

	score = (lt(size(word),5) cost(word), 2 * cost(word))

*	See if get bonus for playing seven tiles.

	score = eq(size(word),7) score + 35

**	Add the first word found to set HIGHEST and *lowest*

	eq(highest,0)					:s(start.new)

	lt(score,highest)				:s(start.word)
	gt(score,highest)				:s(start.new)

*	Here if current best and new move have same score.
*	Prefer the one with the lowest cost.

	lt(cost(word),lowest)				:s(start.new)

start.new

	highest = score
	lowest = cost(word)
	best = word
							:(start.word)
start.done

*	Start word at position 8, unless word size greater than
*	five, in which case move it to the left, but making sure
*	move still covers double-word cell at position twelve.

	offset = (lt(size(best,5) 0, 5 - size(best)))

*	Initialize free array for move.

	free = array(size(best))
	i = 0

start.free

	free[add1(.i)] = 7 + i  + offset		:s(start.free)

	start = move(8 + offset,free,best,highest) :(return)

start.end

	define('state.restore(saved)')		:(state.restore.end)

*	Restore the state of the game from a prior save.

state.restore

	g.grid = 	saved['grid']
	g.bonus = 	saved['bonus']
	g.tiles = 	saved['tiles']
	g.players[1] = 	saved['player.1']
	g.players[2] = 	saved['player.2']
							:(return)
state.restore.end

	define('state.save()')				:(state.save.end)

*	Save the state of the game.

state.save

	state.save = table(10)
	state.save['grid'] = 	copy(g.grid)
	state.save['bonus'] = 	copy(g.bonus)
	state.save['tiles'] = 	copy(g.tiles)
	state.save['player.1'] = copy(g.players[1])
	state.save['player.2'] = copy(g.players[2])
							:(return)
state.save.end


	define('subarray(ara,start,len)i')		:(subarray.end)

**	Like substr, but returns the sub-array of ARA starting at
**	element START and consisting of *len* elements

*SUBARRAY*
subarray

	subarray = array(len)

subarray.1

	gt(add1(.i),len)				:s(return)
	subarray[i] = copy(ara[start + i - 1])		:(subarray.1)

subarray.end

	define('swap(pid,n)player,tiles')		:(swap.end)

**	Swap N tiles from the first *n* characters in *tiles*
**	of player with id PID.  If fewer than *n* tiles remain,
**	set N to the size of the tiles.

*SWAP*
swap

	player = g.players[pid]
	tiles = rack(player)
	n = gt(n,size(tiles)) size(tiles)
	n = gt(n,size(g.tiles)) size(g.tiles)
	eq(n)						:s(freturn)

swap.next

	swap = substr(g.tiles,1,n)
	g.tiles = substr(g.tiles,n + 1)  substr(tiles,1,n)
							:(return)
swap.end

	define('take(n)')				:(take.end)

**	Take N tiles from the tiles, or taking all
**	the remaining tiles if fewer than N remain.

*TAKE*
take
	n = gt(n,size(g.tiles)) size(g.tiles)
	eq(n,0)						:s(return)
	take = order(substr(g.tiles,1,n))
	g.tiles = substr(g.tiles, n + 1)		:(return)

take.end

	define('test.perm(rack,perm,num,move,inlines)'
.		'text,lines,iline,i,p,cline')	:(test.perm.end)

*	Test if applying a permutation PERM to a rack RACK yields a valid move.
*	NUM is the line containing the move, and INLINES is a list of
*	the lines from the grid to be used.

*TEST.PERM*
test.perm

*	NOTE: THE LOOP BELOW IS THE CRITICAL INNER LOOP OF THIS PROGRAM.
*	ANY TIME SPENT SPEEDING THINGS UP ELSEWHERE WILL HAVE LITTLE EFFECT.
*
*	For example, given a move of length 7 with a rack of 7 letters, we
*	need to account for the slightly over 5000 permutations of the letters
*	that can be used here. And note this is just for one possible move ...
*
*	Since most racks will contain duplicate, or even triplicate, instances of
**	the same letter, the table TRIED is used below. This cut the running
*	time of the program by a factor of two when first introduced.

	add1(count.perm)

	seen(perm)				:s(freturn)
	count.cells = count.cells + size(perm)

	g.cln = 0

	text = place(perm,rack)

	lines = copy(inlines);

*	Insert the letters from the tiles corresponding to the permutation
*	into the selected blank cells in the line.  The digit '1' selects
*	the first tile, the digit '2' the second, and so on.  Then see if
*	the result gives a valid line. 'move' to the next permutation if not.
*	(This is a clever use of replace(), even if I do say so myself.)

	text(move) = perm;* insert permutation digits into free cells
	iline = insert(lines[num],move);* line with permutation digits entered
	checkline(place(iline,rack))			:f(freturn)

*	'move' is valid on this line, so check validity on crossing lines.
**	Save the valid lines in CLINES for scoring if move proves valid.

*	We could use the clines() procedure for this, but in this loop every
*	statement counts, so in effect we build clines on the fly.
*	Since almost all permutations will result in junk, we want to
*	detect junk as soon as possible so we can move on without wasting
*	needless effort.

	text(move) = text

*	out(ne(g.tracing) 'Find valid first '
*		show.move(move) ' ' show.line(line))

	g.clines[add1(.g.cln)] =  pair( id(move), insert(lines[num],move))
	i = 0

*	Check the crossing lines, constructing them as needed, to make sure the
*	move is valid.

test.perm.cross

*	out('find cross ')

*	If next assignment fails, we have finished checking the
*	permutation without finding a valid move, and so return failure.

	p = free(move)[add1(.i)]			:f(return)
	cline = cline(lines,move,p,substr(rack,substr(perm,i,1),1))
	checkline(line(cline))				:f(freturn)

*	out(ne(g.tracing) 'Find valid checkline ' line(cline))

	text(move) = place(text(move),ucase(rack))

*	out(ne(g.tracing) 'Find text ' text(move))

	g.clines[add1(.g.cln)] = cline			:(test.perm.cross)

test.perm.end

	define('thousands(s)n')				:(thousands.end)

*	Format s with comma's every three digits from right.

*THOUSANDS*
thousands

	n = size(s)
	thousands = le(n,3) s				:s(return)
	thousands = thousands(substr(s,1,n - 3)) ',' substr(s, n - 2, 3) :(return)

thousands.end

	define('traceoff()')				:(traceoff.end)

*	Initiate tracing.

*TRACEOFF*
traceoff
	&ftrace = &trace =

	g.scoring = g.tracing = 0
	out('stop TRACING ')

traceoff.end

	define('traceon()')				:(traceon.end)

*	Initiate tracing.

*TRACEON*
traceon

	out('start TRACING')
*	&ftrace = &trace = 1500000
	g.scoring = g.tracing = 1
							:(return)
traceon.end

	define('turn(pid,mode)manual,state,points.player,'
.			'points.fribble') 	:(turn.end)

*	Play a turn in a game.

*	Steps are

*	1.	Replenish tiles before making move if managing tiles by hand.

*	2.	Find or enter the move to be played.

*	3.	Make the move by updating the data structures, scores, etc.

*	4.	If not managing tiles by hand, use fribble to update the rack.

*TURN*
turn

	player = g.players[pid]

	ne(f.trace) out('enter turn pid=' pid ' ' show.player(pid))

	eq(g.trace,g.turn) traceon()

*	Replenish tiles before making the move.

*	This is needed when playing in team mode.
*	need to enter your tiles from the wwf board.

	eq(f.mode,f.mode.auto)				:s(turn.auto)
	ne(kind(player),player.kind.team)		:s(turn.move)

	rack(player) = replenish(pid)
	ne(f.trace) out('rack pid=' pid '   now ' rack(player))
	ne(f.trace) out(show.player(pid))

turn.move

	log( 'rack ' pid ' "' rack(player) '"')

*	2.	Find or enter the move to be played.

*	Here to pick the next move.
*	You need to enter the foe's move when playing as a team,
*	and your own move when playing a solo game.

	eq(f.mode,f.mode.auto)				:s(turn.auto)
	eq(kind(player),player.kind.foe)		:s(turn.manual)

*	Enable next line to get 'enhanced' mode where Fribble reports
*	move it would have made

*	eq(kind(player),player.kind.solo)		:s(turn.solo)

	eq(kind(player),player.kind.solo)		:s(turn.manual)

turn.auto

*	Here to have fribble find the best move.

	ne(f.trace) out('fribble making move.')

*	ne(kind(player),player.kind.auto) out('computing move ...')

	g.move = find(pid,g.turn)			:f(turn.fail)

*	ne(f.trace) out('auto move ' show.move(g.move))

*	ne(kind(player),player.kind.auto) out('... computed')
							:(turn.make)

turn.manual

*	Here to enter the move manually

	ne(f.trace) out('getting move manually')

	manual = move.input()
	ident(datatype(manual),'move')			:f(turn.manual.nomove)
	g.move = manual					:(turn.validate)

turn.manual.nomove

*	Here if manual didn't return a move, so branch
*	to the corresponding handler.

	manual 'error'					:s(turn.manual.error)
							:($('turn.' move))
turn.solo
*HERE*

*	Here to when playing solo. Get the player's move, then
*	find what fribble would have played, and show the difference.

turn.solo.in

	ne(f.trace) out('getting move manually')

	manual = move.input()
	ident(datatype(manual),'move')			:f(turn.solo.nomove)
	out('solo player move ' show.move(manual))
	g.move = manual				:(turn.solo.fribble.havemove)

turn.solo.nomove

*	Here if manual didn't return a move, so branch
*	to the corresponding handler.

	manual 'error'				:s(turn.manual.error)
	target = $('turn.' manual)
	out('solo no move target datatype ' datatype(target) ' ' target)
	out('turn.solo.nomove ' manual)
						:($('turn.' manual))
turn.solo.move

	eq(g.turn,1) valid.start(manual)	:s(turn.solo.fribble.havemove)
	ne(g.turn,1) valid(manual)		:s(turn.solo.fribble.havemove)

	out('invalid move - try again')			:(turn.solo.in)

turn.solo.fribble.havemove

	g.move = manual

*	G.move is the player's valid move.
*	Save the state, find the move fribble would have made,
*	and report the results to the player.

	state = state.save()
	move = find(pid, rack)			:s(turn.solo.fribble.move)

*	Here if fribble couldn't find a valid move.

	out('Hmmm ... Fribble unable to find a valid move.')	:(turn.validate)

turn.solo.fribble.move

	points.fribble = scoremove(move)
	points.player = scoremove(g.move)

	out('You played the move ' show.move(g.move) ' for '
.		number(points.player) ' points.')

	out('Fribble would have played ' show.move(move) ' for '
.		number(points(move)) ' points.')

	show.play(makemove(pid,move));* display fribble's move.

	lt(points.player,points.fribble)
.		out('Fribble would have scored ' (points(move) - points.player)
.		 ' more points.')

	eq(points.player,points.fribble)
.		out('Fribble and you would have scored the same - '
.		'Congratulations!')

	gt(points.player,points.fribble)
.		out('You score more (' (points.player - points.fribble)
.		 		    ') points than Fribble.')

	gt(points.player,points.fribble)	out('You are a genius!')

*	Put things back where they were.

	state.restore(state)

turn.validate

	ne(f.trace) out('validating move ' show.move(g.move))

*	See if move is valid.

	eq(g.turn,1) valid.start(g.move)		:s(turn.make)
	ne(g.turn,1) valid(g.move)			:s(turn.make)

	out('invalid move - try again')			:(turn.manual)

turn.manual.error

	out('eval error ' &errtext)			:(turn.manual)

turn.make
*	3.	Make the move by updating the data structures, scores, etc.

	points(g.move) = scoremove(g.move)

	log.move(pid,g.move)

*	ne(f.trace) out('making move ' show.move(g.move))

	show.play(makemove(pid,g.move))

turn.replenish

*	4.	Replenish the tiles if managing the tiles automatically.


*	Replenish tiles if necessary. If doing this manually, don't do it here,
*	but at start of next turn.

	eq(g.tilemanager)				:s(turn.done)
*	out('DAVE')
*	out('replenishing pid= ' pid ' ' show.player(player))
	ne(f.trace) out('replenishing pid= ' pid )


*	Here to update rack when fribble is managing the tiles.
*	Remove tiles played on move and then replenish the rack.

	ne(f.trace) out('updating rack pid=' pid)
	rack(player) = less(rack(player), lcase(text(g.move)))
	rack(player) = replenish(pid)
	ne(f.trace) out('rack pid=' pid '   now ' rack(player))
							:(turn.done)

turn.pass

	log( 'pass ' pid)
							:(turn.done)
turn.resign

	out('player ' pid ' resigns.')
	log('resign ' pid)				:(turn.done)

turn.swap

*	Here in case foe swapped tiles. Report it as such and move on.


	log('swap ' pid)

	out('foe swapped tiles')			:(turn.done)

turn.done

	ne(f.trace) out('turn done')
							:(return)
turn.fail

	out('turn failed - unable to find move.')	:(freturn)

turn.end

	define('user.input()')				:(user.input.end)

*	Get a line from the user, usually from the terminal, or from
*	a user input file.

user.input

	user.input = terminal				:f(freturn)s(return)

user.input.end

	define('valid.start(move)free,num,text')	:(valid.start.end)

*	Test if a suggested starting move is valid.

*VALID.START*
valid.start

*	If this is a starting move, check that it covers column 8 in row 8,
*	and is a word in the dictionary.

	free = free(move)
	text = text(move)

	num = convert(free,'integer')			:f(valid.start.free)

	out('valid.start.start num=' num)

	lt(num,9 - size(text))				:s(valid.start.error)
	gt(num,7 + size(text))				:s(valid.start.error)

valid.start.free

*	Here if free is list of cells. Check that '8' is one of them.

	out('valid.start.start.free ' show.move(valid.start))
	out('valid.start.start.free ' free(valid.start))

	free break('8')					:f(valid.start.error)
	checkword(text(move))				:s(return)f(freturn)

valid.start.start.error

	out('starting move must use column 8.')		:(freturn)

valid.start.end

	define('log.move(pid,move)')			:(log.move.end)

*	Write move description to log file.

log.move

	log('move ' pid ' ' show.move(move))		:(return)

log.move.end


	define('ucase(s)')				:(ucase.end)

*	Convert argument to upper case.

*UCASE*
ucase

	ucase = replace(s,&lcase,&ucase)		:(return)

ucase.end

	define('unpack(line),c,i')			:(unpack.end)

**	Unpack the characters of line LINE to an array of characters.

*UNPACK*
unpack

	unpack = array(size(line))

unpack.ch

	c = substr(line,add1(.i),1)			:f(return)
	unpack[i] = c					:(unpack.ch)

unpack.end

	define('valid(move)num,i,pos')			:(valid.end)

*	Test if move is valid.

*VALID*
valid
valid.move

*	At least one cell to be occupied by this move must be
*	adjacent to a used cell.

	num = id(move)

valid.u

	gt(add1(.i),size(text(move)))			:s(freturn)
	pos = free(move)[i]
	adjacent(row(num,pos),column(num,pos)) 		:f(valid.u)s(valid.used)

*	Here if no adjacent cell found, fail.  *
							:(freturn)
valid.used

*	Test that line and all its crossing lines are valid.

	clines(move);* get line and its crossing lines
	i = 0

valid.i

	gt(add1(.i),g.cln)				:s(return)
	checkline(line(g.clines[i]))			:f(freturn)s(valid.i)

valid.end

	define('vline(g,c)')				:(vline.end)

**	Return the vertical line of  grid G corresponding
**	to column C as a string.

*VLINE*
vline

	c = +c
	vline = g[1,c] g[2,c] g[3,c] g[4,c] g[5,c]
.		g[6,c] g[7,c] g[8,c] g[9,c] g[10,c]
.		g[11,c] g[12,c] g[13,c] g[14,c] g[15,c]
							:(return)
vline.end

	define('words(s)n,w,pos,i,sp')			:(words.end)

*	Return array of the words in s, fail if no words.
*	The first entry for an array element is the starting index;
*	the second is the word itself.

*WORDS*
words

*	Make sure we'll have blank to start off so initial span()
*	matches something, and also one at end to break to
*	in case last word extends to end of line.

	words = table(n)
	s = ' ' s ' '
	pos = 0
words.sp

*	Account for blank(s) between words.

	s span(' ') . sp =

	ident(s)					:s(words.done)

	pos = pos + size(sp);* point to start of next word

words.w

*	While it is customary to absorb the blank in the
*	usage below, we leave it in so there will be at least
*	one blank to satisfy span() when loop back to words.sp

	s break(' ') . w  = 	 			:f(words.done)
	words[pos] = w
	pos = pos + size(w)				:(words.sp)

words.done

	words = convert(words,'array')			:(return)

words.end

	:(error.end)
error
	output = 'error lastno ' &lastno
	output = 'ERROR'
	output = 'Fatal error: stopping the madness.'
*	&dump = 3
							:(end)
error.end

