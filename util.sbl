
* This software is licensed under the MIT License, contained in the file LICENSE.

* Copyright (c) 2016 dave shields

*	Utility functions

	define('col(i)')			:(col.end)
*	return contents of column as a string
col
	col = 	board[1,j] board[2,j] board[3,j] board[4,j] board[5,j]
.		board[6,j] board[7,j] board[8,j] board[9,j] board[10,j]
.		board[11,j] board[12,j] board[13,j] board[14,j] board[15,j]
						:(return)
col.end

	define('getwords(filename)file,this,word')	:(getwords.end)
getwords

* Convert dictionary to a single string of getwords, combining getwords
* into strings of 1000 characters before concatenating to build
* single string.

	getwords =
	this = 
	input(.file,3,filename)			:s(getwords.in)
	output = 'unable to open input file ' filename	:(feturn)
getwords.in
	word = file				:f(getwords.done)
	this  = this  word  ' '		
	le(size(this),1000)			:s(getwords.in)
	getwords = getwords ' ' this		
	this =					:(getwords.in)
*	add in remaining words
	getwords = differ(this) getwords ' ' this 
*	add blank at end of getwords to simplify scan later
	getwords = getwords ' '
						:(getwords.in)
getwords.done					
	endfile(3)
						:(return)
*	getwords now has the word list as one large string.
getwords.end
	define('initboards(),board,i,j')	:(initboards.end)
initboards
	initboards =array('1:15,1:15')
	i = 0
initboards.i
	le(i = i + 1,15)			:f(initboards.done)
	j = 0
initboards.j
	le(j = j + 1,15)			:f(initboards.i)
	initboards[i,j] = ' '			:(initboards.j)
						:(return)
initboards.end

	define('isword(word)')			:(isword.end)
isword
	differ(words[word])			:s(return)f(freturn)
isword.end

	define('less(s,c)')			:(less.end)
*	remove the first instance of character c in s.
less
	less = s
	s break(c) . first len(1) rem . rest 
	less = first rest
*	output = 'less s=' s ', c=' c '->' less
							:(return)
less.end
	
	define('row(i)')		:(row.end)
*	return contents of row as a string
row
	row = 	board[i,1] board[i,2] board[i,3] board[i,4] board[i,5]
.		board[i,6] board[i,7] board[i,8] board[i,9] board[i,10]
.		board[i,11] board[i,12] board[i,13] board[i,14] board[i,15]
						:(return)
row.end
