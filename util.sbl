* This software is licensed under the MIT License, contained in the file LICENSE.

* Copyright (c) 2016 dave shields

*	Utility functions

	define('add(str,word)')				:(add.end)

*	add word to string str, prefixing with a space if str is not null.
*	this aids in building list of words separated by spaces.

add
	add = ident(str) word				:s(return)
	add = str ' ' word				:(return)
add.end

	define('backwords(dict)ara,key,val,i')	:(backwords.end)

*	use dictionary dict to build dictionary with the words reversed.

backwords
	ara = convert(dict,'array')
*	backwords = table(20000)
	backwords = table()

	
backwards.1
	key = ara[i = i + 1,1]				:f(return)
	val = ara[i,2]
	backwords[key] = reverse(val)			:(backwords.1)
backwords.end

	define('bonusinit()b')				:(bonusinit.end)

*	initialize the bonus squares for the 15x15 grid, using 1 for double letter, 
*	2 for triple letter, and 3 for triple word.

bonusinit
	line =  '1 0203 1 0212 1 0302 1 0305 1 0311 1 0312 1 0314 1 0503 1 0613 1 0705 1 0711 '
.		'1 0905 1 0911 1 1103 1 1109 1 1113 1 1302 1 1305 1 1311 1 1314 1 1403 1 1413 '
.		'2 0107 2 0109 2 0404 2 0412 2 0606 2 0610 2 0701 2 0715 2 0901 2 0915 2 1006 '
.               '2 1010 2 1304 2 1312 2 1507 2 1509 2 '
.		'3 0104 3 0112 3 0401 3 0415 3 1101 3 1115 3 1504 3 1512 '

bonusinit.loop
	line len(1) . b ' ' len(2) . r len(2) . c ' ' = :f(return)
	bonusinit[+r, +c] = +b				:(bonusinit.loop)
bonusinit.end

	define('getrows(board)')			:(getrows.end)
getrows
	getrows = array(7)
	rline = 
getrows.r
	ri = ri + 1
	gt(ri,15)					:s(return)
	line = 
	ci = 0
getrows.c
	getrows[ri, ci = ci + 1] = ' '			:f(return)
getrows.end
	
*	define('getcolumns(rows),cline,ci,ri')		:(getcolumns.end)
*
*getcolumns
*	ri = ci = 0
*	getcolumns = array(15)
*getcolumns.c
**	compute column i
*	gt(ci = ci + 1,15)				:s(return)
*	cline =
*	ri = 0
*getcolumns.r
*	gt(ri = ri + 1,15)				:s(getcolumns.d)
*	cline = cline substr(rows[ri],ci,1)		:(getcolumns.r)
*getcolumns.d
*	getcolumns[ci] = cline				:(getcolumns.c)
*getcolumns.end

	define('getwords(filename)file,this,word')	:(getwords.end)
getwords

* Convert dictionary to a single string of getwords, combining getwords
* into strings of 1000 characters before concatenating to build
* single string.

	getwords =
	this = 
	input(.file,3,filename)				:s(getwords.in)
	output = 'unable to open input file ' filename	:(feturn)
getwords.in
	word = file					:f(getwords.done)
	this = add(this,word)
	le(size(this),1000)				:s(getwords.in)
	getwords = add(getwords,this)
	this =						:(getwords.in)
							:(getwords.in)
getwords.done					
*	add in remaining words
	getwords = differ(this) add(getwords,this)
	endfile(3)					:(return)
getwords.end

	define('getdict(filename)file,n,word')		:(getdict.end)
getdict

* Convert dictionary to a table.

	getdict = table(2000)
	input(.file,3,filename)				:s(getdict.in)
	output = 'unable to open input file ' filename	:(freturn)
getdict.in
	n = n + 1
	word = file					:f(getdict.done)
	gt(size(word),15)				:s(getdict.in)
	getdict[word] = +1				:(getdict.in)
getdict.done
	output = 'word count ' n
	endfile(3)					:(return)
getdict.end


	define('isword(word,words)')			:(isword.end)
isword
	differ(words[word])				:s(return)f(freturn)
isword.end

	define('less(str,ch)before,after')		:(less.end)
*	remove the first instance of character ch in str.
less
	ident(str)					:s(return)
	str break(ch) . before len(1) rem . after	:f(less.1) 
	less = before after				:(return)
less.1
	less = ident(substr(s,1,1),ch) substr(s,2)	:s(return)
	less = str					:(return)
less.end
	
	define('perm(s,p)c,n,i,dist,t')				:(perm.end)

*	perm(s,d) returns all the permutations from string s
*	with length p, as a list of words separated by spaces.

perm
*	build perm as list of entries separated by space. Will
*	eliminate extra space at the end before returning.


perm.dist.1
	n = +size(s)
	eq(p,0)							:s(return)
	gt(p,1)							:s(perm.n) 

*	here for permutations length one, which consists of
*	the letters in s, separated by spaces.
*	Here also we avoid adding duplicate characters

perm.1	
	c = substr(s,i = i + 1,1)				:f(return)
	perm = add(perm, c)					:(perm.1)

perm.n

*	Here if two or more characters in the string. 
*	For each distinct character, the permutations
*	of p items can be found by find the permutations
*	of p-1 items in the string with c removed.

perm.n.1
	gt(i = i + 1,n)						:s(return)
	c = substr(s,i,1)

*	This optimization in next line isn't working, so skip for now
*	skip if have already generated permutations starting with this letter

*	done break(c)						:s(perm.n.1)

*	compute permutations starting with c, by recursively computing the permutations of all the letters
*	that follow c, and then prefixing each permutation in the resulting list with c.

	perm = add(perm,prefix(perm(less(s,c),p - 1),c)) 
*	done = done c
								:(perm.n.1)
perm.end

	define('prefix(str,pre)word')			:(prefix.end)
prefix

*	prefix takes a list of space-separated words str and prefixes each
*	with the string pre.


	str = str ' ';* so each word followed by space
prefix.1
	str break(' ') . word span(' ')  =		:f(return)
	prefix = add(prefix, pre word)			:(prefix.1)
prefix.end

	define('valid(d,w)')				:(valid.end)

*	see if word is in dictionary

valid
	differ(d[w])					:s(return)f(freturn)
valid.end

	define('validate(dict,line)word')		:(validate.end)

*	succeed if line contains only valid words, fail otherwise.	

validate
	line = line ' '
validate.1
	line span(' ') =
	ident(line)					:s(return)
	line break(' ') . word span(' ') =
	valid(dict, word)				:f(freturn)s(validate.1)
validate.end


	define('valueinit()line,c')			:(valueinit.end)

*	initialize value map for letters
valueinit
	valueinit = table(26)
	line = &lcase
valueinit.1
	line len(1) . c =				:f(valueinit.2)
	valueinit[c] = 1					:(valueinit.1)
valueinit.2
	valueinit['q'] = valueinit['z'] = 10
	valueinit['k'] = valueinit['j'] = 3
							:(return)
valueinit.end
							;
				k
	define('words(s)i')				:(words.end)
*	return number of space-separated words in s
words
	s = s  ' '
	words = 0
words.1	
	s break(' ') ' ' =				:f(return)
	words = words + 1				:(words.1)
words.end

