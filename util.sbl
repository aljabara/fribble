* This software is licensed under the MIT License, contained in the file LICENSE.

* Copyright (c) 2016 dave shields

*	Global Variables

*	The global variables, initialized by the function *init()*,  are as follows:

*	g.board		array('15,15',' ')	grid of the playing board
*	g.bonus		array('15,15',+0)	grid with non-zero cells for bonus squares
*	g.tileset	string			all the characters in the initial set of tiles, by frequency
*	g.perms		table			table of permutations of n=1..7 things taken 1..k at a time

*	Utility functions

	define('add(str,word)')				:(add.end)

*	add word to string str, prefixing with a space if str is not null.
*	this aids in building list of words separated by spaces.

add
	add = ident(str) word				:s(return)
	add = str ' ' word				:(return)
add.end

	define('adjacent(r,c)')			:(adjacent.end)

*	succeeds if cell (r,c) is adjacent to occupied cell on
*	board, fails otherwise.

adjacent

*	test neighboring cells to see if occupied. Note that
*	may examine cells outside the playing board, in which
*	case the attempt to get the value of the cell will fail.

	r = +r; c = +c
	differ(g.board[r - 1,c])			:s(return)
	differ(g.board[r - 1,c])			:s(return)
	differ(g.board[r,c - 1])			:s(return)
	differ(g.board[r,c + 1])			:s(return)
						:(freturn)
adjacent.end



	define('backwords()ara,key,val,i')	:(backwords.end)

*	use dictionary g.dict to build dictionary with the words reversed.

backwords
	ara = convert(g.dict,'array')
*	backwords = table(20000)
	backwords = table()

	
backwards.1
	key = ara[i = i + 1,1]				:f(return)
	val = ara[i,2]
	backwords[key] = reverse(val)			:(backwords.1)
backwords.end

	define('cells(move)r,c,t,text,i,n')		:(cells.end)

*	Return the cells that comprise a move, by which we mean a list consisting of a series of one or more
*	placements, each consisting of a string of one or more characters followed by a signed integer with
*	a specified form. The signed integer identifies where the placement is in a row (plus sign) or
*	along a column (minus sign). The cell is indicated by multiplying the row number by one hundred and adding the
*	column number.

cells
	move break('+-') . text len(1) . sign rem . rc
	output = 'text ' text '|' sign '|' rc
	
	n = size(text)
	cells = array(size(text) ',3')
	ident(sign,'+')					:s(cells.h)
	ident(sign,'-')					:s(cells.v)
	output = 'improper type in move ' move		:(freturn)
cells.h
	i = i + 1
	gt(i,n)						:s(return)
	cells[i,1] = +(rc / 100)			:f(return)
	cells[i,2] = remdr(rc,100) 
	cells[i,3] = substr(text,i,1)
	c. = c + 1					:(cells.h)
cells.v
	i = i + 1
	gt(i,n)						:s(return)
	cells[i,1] = +(rc / 100)			:f(return)
	cells[i,2] = +remdr(rc,100); 
	cells[i,3] = substr(text,i,1)
	r = r + 1					:(cells.v)
cells.end


	define('getrows(board)')			:(getrows.end)

*	Return an array of rows on the board, from top to bottom. Each row is fifteen characters long.

getrows
	getrows = array(7)
	rline = 
getrows.r
	ri = ri + 1
	gt(ri,15)					:s(return)
	line = 
	ci = 0
getrows.c
	getrows[ri, ci = ci + 1] = ' '			:f(return)
getrows.end
	
*	define('getcolumns(rows),cline,ci,ri')		:(getcolumns.end)

*	Return an array of the columns on the board, from left to right. Each column is fifteen characters long.

*getcolumns
*	ri = ci = 0
*	getcolumns = array(15)
*getcolumns.c
**	compute column i
*	gt(ci = ci + 1,15)				:s(return)
*	cline =
*	ri = 0
*getcolumns.r
*	gt(ri = ri + 1,15)				:s(getcolumns.d)
*	cline = cline substr(rows[ri],ci,1)		:(getcolumns.r)
*getcolumns.d
*	getcolumns[ci] = cline				:(getcolumns.c)
*getcolumns.end

	define('getwords(filename)file,this,word')	:(getwords.end)
getwords

*	Convert the dictionary to a single string of words, combining words
* 	into strings of 1000 characters before concatenating to build the
* 	single string.

	getwords =
	this = 
	input(.file,3,filename)				:s(getwords.in)
	output = 'unable to open input file ' filename	:(freturn)
getwords.in
	word = file					:f(getwords.done)
	this = add(this,word)
	le(size(this),1000)				:s(getwords.in)
	getwords = add(getwords,this)
	this =						:(getwords.in)
							:(getwords.in)
getwords.done					
*	add in remaining words
	getwords = differ(this) add(getwords,this)
	endfile(3)					:(return)
getwords.end


	define('init(dictfile,skip),i,s,t')		:(init.end)

*	Initialize global variables, each with name starting with 'g.'
*	The variables include:
*		g.tileset, a string containing all the characters in the initial bag of characters.
*		g.bonus, an array indicating which cells have a bonus value, and the nature of that value,
*			such as double letter, or triple word.
*		g.value, a map from characters to the tile value of that character.
*		g.dict, a map on words that is non-null only for words in the dictionary.
*		g.board, the playing board, non-null if letter
*			played on given cell


init

	g.board = array('15,15')

* Initialize set of tiles.

	
* 	ignoring two blanks for now

	s = 'a 9 b 2 c 2 d 5 e 13 f 2 g 3 h 4 i 8 j 1 k 1 l 4 m 2 n 5 o 8 p 2 q 1 r 6 s 5 t 7 u 4 v 2 w 2 x 1 y 2 z 1 '
	g.tileset =
init.1
	s break(' ') . c ' ' break(' ') . n ' ' =	:f(init.2)
	g.tileset = g.tileset new dupl(c,+n)		:(init.1)
init.2

*	initialize the bonus squares for the 15x15 grid, using 1 for double letter, 
*	2 for triple letter, 3 for double word, and 4 for triple word.

	g.bonus = array('15,15')

	s =     '1 0203 1 0212 1 0302 1 0305 1 0311 1 0312 1 0314 1 0503 1 0613 1 0705 1 0711 '
.		'1 0905 1 0911 1 1103 1 1109 1 1113 1 1302 1 1305 1 1311 1 1314 1 1403 1 1413 '
.		'2 0107 2 0109 2 0404 2 0412 2 0606 2 0610 2 0701 2 0715 2 0901 2 0915 2 1006 '
.               '2 1010 2 1304 2 1312 2 1507 2 1509 '
.		'3 0206 3 0210 3 0408 3 0602 3 0614 3 0804 3 0812 3 1002 3 1014 3 1208 3 1406 3 1410 '
.		'4 0104 4 0112 4 0401 4 0415 4 1101 4 1115 4 1504 4 1512 '
init.3
	s len(1) . n ' ' len(2) . r len(2) . c ' ' =	:f(init.3.done)
	g.bonus[+r,+c] = +n				:(init.3)
init.3.done
	
*	initialize value map from letters to value, ignoring ' ' for now

	g.value = table(26)
	s = &lcase
init.4
*	assume value is 1
	s len(1) . c =					:f(init.5)
	g.value[c] = 1					:(init.4)
init.5
*	g.value[' '] = 1
*	update assumptions for letters with value greater than one.
	g.value['d'] = g.value['l'] = g.value['n'] = g.value['p'] = g.value['u'] = g.value['w'] =  +2
	g.value['g'] = g.value['h'] = g.value['y'] = +3
	g.value['b'] = g.value['c'] = g.value['f'] = g.value['m'] = g.value['p'] = g.value['w'] = +4
	g.value['k'] = g.value['v'] = +5
	g.value['x'] = +8
	g.value['j'] = g.value['q'] = g.value['z'] = 10

	g.dict = initdict(dictfile,skip)
	initperm(dictfile '.perm')
	
							:(return)
init.end

	define('initdict(filename,skip)file,n,word,s')	

*	g.wwf is list of words not in enable dictionary but known to be used by wwf.

	g.wwf = 'qi brr '

							:(initdict.end)
initdict

*	Read in a dictionary from a specified file, with one word per line. If 'skip'
*	is non-zero then that number of lines are skipped before adding the next word.
*	This assists the use of smaller dictionaries for testing.

	skip = (ident(skip) +1, +skip)
	initdict = table(200000)

*	add words from g.wwf list to dictionary

	s = g.wwf
initdict.wwf.1
	s break(' ') . word ' ' =			:f(initdict.wwf.2)
	initdict[word] = +1				:(initdict.wwf.1)
initdict.wwf.2
	
	filename = ident(filename) 'enable1.txt'
	input(.file,3,filename)				:s(initdict.in)
	output = 'unable to open input file ' filename	:(freturn)
	n = 0
initdict.in
	word = file					:f(initdict.done)
	gt(size(word),15)				:s(initdict.in)
	initdict[word] = +1				
	eq(skip,1)					:s(initdict.in)
*	here want to skip over entries in the dictionary (for testing)
	n = skip
initdict.skip
	word = file					:f(initdict.done)
	gt(n = n - 1,0)					:s(initdict.skip)f(initdict.in)
initdict.done
	endfile(3)					:(return)
initdict.end
	
	define('initperm(filename)line,ifile,n,k,lines')	:(initperm.end)

initperm
	g.permutations = table(100)
	input(.ifile,4, filename)			:s(initperm.1)
	output = 'unable to open permutation file ' filename 	:(freturn)
*	read first line and merge to process permutation description line
	line = ifile					:f(initperm.done)s(initperm.2)
	lines = 1
initperm.1
	line = ifile					:f(initperm.done)
	lines = lines + 1
initperm.2
	line '; ' break('?') . n '?' break(' ') . k ' ' rem . count :f(initperm.err)
initperm.k
	line = ifile					:f(initperm.done)
	lines = lines + 1
*	add blank at end of list to simplify later iterations over the list
	g.permutations[n '?' k] = line ' '		:(initperm.1)
initperm.done	
	endfile(4)					:(return)
initperm.err
	output = 'initperm error, line ' lines '  '  line :(freturn)
initperm.end

	define('isword(word,words)')			:(isword.end)

*	words is a map on words. Returna if words is defined for the specified word,
*	fails otherwise.
isword
	differ(words[word])				:s(return)f(freturn)
isword.end

	define('less(str,ch)before,after')		:(less.end)

*	Removes the first instance of character ch in str.

less
	ident(str)					:s(return)
	str break(ch) . before len(1) rem . after	:f(less.1) 
	less = before after				:(return)
less.1
	less = ident(substr(s,1,1),ch) substr(s,2)	:s(return)
	less = str					:(return)
less.end
	
	define('open(tiles)best,n,w')			:(open.end)

*	Determine best opening move. At least one letter in this move must be in the center square (8,8).
*	The only bonus available is double word, for any word of more than four characters.
*
*	The return value has the form 'm s' where m is the move and s is its score.
*
*	There are seven tiles, so we just try all permutations of length one up to seven.

open
	n = 0;* number of tiles to play
	best = 0;* best score

open.1	le(n = n + 1,7)					:f(return)
	perms = permutations(tiles,n)
open.2
*	get next word, check that valid, then see if new high score
	perms break(' ') . w ' ' =			:f(open.1)
	permwords = permwords + 1
	valid(w)					:f(open.2)
	validwords = validwords + 1
	le(oscore(w),best)				:s(open.2)
	best = oscore(w)
	open = w '+0808 ' best				:(open.2)
open.end

	define('prefix(str,pre)word')			:(prefix.end)
prefix

*	Prefix takes a list of space-separated words str and prefixes each
*	with the string pre.


	str = str ' ';* so each word followed by space
prefix.1
	str break(' ') . word span(' ')  =		:f(return)
	prefixcount = prefixcount + 1
	prefix = add(prefix, pre word)			:(prefix.1)
prefix.end

	define('oscore(word)n,c')			:(oscore.end)
oscore
	n = size(word)
	oscoren = oscoren + 1
oscore.1
	word len(1) . c =				:f(return)
*	double word score if length greater than four.
	oscore = oscore + g.value[c] * (gt(n,4) +2, +1) :(oscore.1)
oscore.end

	define('permutations(s,k,d)')			:(permutations.end)

*	Return permutations of s taken k at a time.

permutations
	permutations = g.permutations[size(s) '?' k]		:f(freturn)
	d = substr('1234567',1,size(s))
	permutations = replace(permutations,d,s)			:(return)
permutations.end

	define('random(n)')				

*	Return integer uniformly distributed in 1,2,...,n. If n=0 returns real uniformly distributed
*	in the interval [0,1]. 
*	The Algorithm is based in that in section 16.1 of "Algorithms in SNOBOL4," James F. Gimpel, John Wiley and Sons, 1976.

*	Gimpel uses integer here, but need to have real.
	random_var = convert(1,'real')

							:(random.end)
random	random_var = remdr(random_var * 4676, 414971)

	random  = random_var / 414971
	random = ne(n,0) convert(random * n,'integer') + 1
							:(return)
random.end

	define('random_rack()i')				:(random_rack.end)

*	Return random set of seven tiles from the initial set of tiles.
*	This is used for testing.
	
random_rack
	gt(i = i + 1,7)					:s(return)
	random_rack = random_rack substr(g.tileset,random(size(g.tileset)),1)	:(random_rack)
random_rack.end

	define('valid(w)')				:(valid.end)

*	Succeeds if w is in the global dictionary, fails otherwise.

valid
	differ(g.dict[w])				:s(return)f(freturn)
valid.end

	define('validate(line)word')			:(validate.end)

*	Succeeds if all the words in the line are in the dictionary, fails otherwise.

validate
	line = line ' '
validate.1
	line span(' ') =
	ident(line)					:s(return)
	line break(' ') . word span(' ') =
	valid( word)					:f(freturn)s(validate.1)
validate.end


							;
	define('words(s)i,w')				:(words.end)

*	Returns number of space-separated words in s

words
	s = s  ' '
	words = 0
words.1	
	s break(' ') . w span(' ') =			:f(return)
	words = words + 1				:(words.1)
words.end

