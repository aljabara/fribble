
* This software is licensed under the MIT License, contained in the file LICENSE.

* Copyright (c) 2016 dave shields

*	Write out all permutations of up to seven digits, including all permutations of substrings.

-include "../util.sbl"


	define('perm(s,p)c,n,i,dist,t')				:(perm.end)

*	Perm(s,d) returns all the permutations from string s
*	with length p, as a list of words separated by spaces.

perm
*	build perm as list of entries separated by space. Will
*	eliminate extra space at the end before returning.


	permcalls = permcalls + 1
perm.dist.1
	n = +size(s)
	eq(p,0)							:s(return)
	gt(p,1)							:s(perm.n) 

*	here for permutations length one, which consists of
*	the letters in s, separated by spaces.
*	Here also we avoid adding duplicate characters

perm.1	
	c = substr(s,i = i + 1,1)				:f(return)
	perm = add(perm, c)					:(perm.1)

perm.n

*	Here if two or more characters in the string. 
*	For each distinct character, the permutations
*	of p items can be found by find the permutations
*	of p-1 items in the string with c removed.

perm.n.1
	gt(i = i + 1,n)						:s(return)
	c = substr(s,i,1)

*	This optimization in next line isn't working, so skip for now
*	skip if have already generated permutations starting with this letter

*	done break(c)						:s(perm.n.1)

*	Compute permutations starting with c, by recursively computing the permutations of all the letters
*	that follow c, and then prefixing each permutation in the resulting list with c.

	perm = add(perm,prefix(perm(less(s,c),k - 1),c)) 
*	done = done c
								:(perm.n.1)
perm.end
	&anchor = &trim = 1
	digits = '123456789'
	n = 0

main.1

*	Start permutations of n digits.

	gt(n = n + 1, 7)					:s(end)
	k = 0
main.2
	gt(k = k + 1,n)						:s(main.1)

*	Compute permutations of n digits taken k at a time.

	pip = perm(substr(digits,1,n),k) ' ' 
	output = '; ' n '?' k ' ' words(pip)
	output = pip						:(main.2)
end
