	define('m(id,str,text)fi,free,len,pos')		:(m.end)

*	Create move in line with given id and text.
**	STR is one of the following:
*	  integer	gives starting position, in range 1..15
*	  string that can be converted to integer, treat as in integer case
*	  string giving list of empty (open) cells used, with entries
*			separated by spaces.

*	For example, the following each specify the word 'fribble'
*	starting at position 6 in row 8.

*		m(r8,6,'fribble')
*		m(r8,'6 7 8 9 10 11 12','fribble')

*M*
m
	free = array(size(text))

*	out('m str' str)
	str break(' ')					:s(m.list)
	pos = +str					:f(m.error)

m.pos

	add1(.len)
*	out('pos fi ' fi ' ' pos + (fi - 1 ))
	free[add1(.fi)] = pos + (fi - 1)		:s(m.pos)f(m.done)

m.list

*	Prepare for m.next loop.

	str = str ' '

m.next

	str break(' ') . pos span(' ')  =		:f(m.done)
	add1(.len)
	free[add1(.fi)] = pos				:(m.next)

m.error

	out('m(id,str,text) error - .') :(freturn)

m.done

	ne(len, size(text)) out('m size mismatch,try again'):s(freturn)

	out('m.done id=' id ' text=' text ', free[1]='
.		free[1] ' free[n]=' free[size(text)])

	m = move(id,free,text)				:(return)

m.end

	define('makemove(pid,move)player,board,lines,id') :(makemove.end)

**	Make a move for player with id PID, and return its value.

*MAKEMOVE*
makemove

	player = g.players[pid]
	makemove = move
*	out(ne(g.tracing) 'Game move ' show.move(move))
	g.lastmove = g.turn
	total(player)	= total(player) + points(move)
	thirty(player)	= ge(points(move),30) thirty(player) + 1
	highest(player) = gt(points(move),highest(player)) points(move)
	playmove(move)
	id = lineid(id(move))
	out(	name(player) ' played "' show.tiles(tiles(move)) '" for '
.		number(points(move)) ' points,'
.		' starting at ' (ident(substr(id,1),'r') 'row ', 'column')
.		' ' number(+substr(id,2))
.		', position ' number(free(move)[1]) '.')

	out('Score now: '
.		name(g.players[1]) ', ' number(total(g.players[1]))  '; '
.		name(g.players[2]) ', ' number(total(g.players[2]))  '. ')

	out('B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 '
.	    'N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 ')
	out()

*	Display move in grid with just this move in upper case by saving
*	the board, playing the move with the text in upper case, showing it,
*	and then restoring the board to its saved state.

	board = copy (g.board)
	lines = copy(g.lines)
	tiles(move) = ucase(tiles(move))
	playmove(move)
	tiles(move) = lcase(tiles(move));* restore
*	show.grid(g.board)
	g.board = board
	g.lines = lines
*	show.lines(g.lines,'Lines')
*	show.grid(g.used)
	g.used.lines = lines(g.used)
*	Update lines affected by grid changes to maintain consistency.

	g.bonus.lines = lines(g.bonus)

	g.lines = lines(g.board)

*	Fold g.lines into lower case so only new moves made later will
*	display in upper case.

	li = 0

makemove.fold

	g.lines[add1(.li)] = lcase(g.lines[li]) :s(makemove.fold)

*	Rebuild board since lines have changed.

*	out('rebuilding board')
	g.board = grid(g.lines)
							:(return)
makemove.end

	define('move.input()mov,line,out,cells,start,text')	:(move.input.end)

*	Enter move.inputly (by hand).

*MANUAL*
move.input
	ne(f.trace) out('getting move move.inputly')
*	Here to enter the move move.inputly



move.input.in
	out('enter move row/column')
	start = terminal
	out(' you entered ' start)
	out()

	out('enter cell(s)')
	cells = terminal
	out(' you entered ' cells)
	out()

	out('enter text')
	text = terminal
	out(' you entered ' text)
	move.input = 'm(' start ',"' cells '","' text '")'
	out()
							:(return)

	move.input = input.user()				:f(end)
	:(return)
	ident(move.input)					:s(return)
	move.input ( 'pass' | 'swap' | 'resign' | 'quit') :(return)
	move.input = move.input					:(return)

	move.input = eval(move.input)				:f(move.input.error)

*	ident(datatype(move.input),'move') out(show.move(move.input))	:f(move.input.error)

	ne(g.turn,1)					:s(move.input.check)

move.input.check

	valid(move.input)					:s(return)

	out('need to enter a valid move')		:(move.input)

move.input.error

	out('move.input error evaluating ' line)		:(freturn)

move.input.end

	define('place(txt,rack)')			:(place.end)

**	Place the permutation digits in TXT with the
**	corresponding tiles from RACK.

*PLACE
place

	place = replace(txt,substr('1234567',1,size(rack)),rack)
							:(return)
place.end


	define('scan(pair,rack)num,line,i,pi,open,oi,nopen,n,'
.			'first,pos,move,sub,len')	:(scan.end)

*	Scan the given line to find the places where a valid move can be made.
*	At least one cell in a move must be adjacent to an occupied cell.
**	LINE is the line to be scanned, and *num* gives
*	its position on the board.

*SCAN*
scan

	line = line(pair)
	num = num(pair)
*	out(ne(g.tracing) 'Scan line ' lineid(num) ' '
*		show.line(line) ' ' show.hex(line))

**	Allocate and fill in OPEN, an array giving the
*	positions of the open cells.

*	Fail if no empty cells.

	open = avail(pair)				:f(scan.done)

*	Nopen is the number of open cells in the line.

	nopen = +prototype(open)

	pi = 0

scan.first

	first = open[add1(.pi)]			:f(scan.done)

**	FIRST is the position of the first letter in the move.

**	The number of moves N that can be made starting at a given
**	position in OPEN depends on the number of tiles in the rack,
*	and the number of remaining open cells in the line.

	n = +size(rack)
	n = gt(n, nopen - pi) nopen - pi;* number of remaining open cells

*	Try for moves of length len=n,n-1...1 starting at position
**	FIRST in the line.

	len = n + 1;* prime for loop

scan.len

	le(len = len - 1)				:s(scan.first)

*	out(ne(g.tracing) 'Scan first=' first ' left =' (nopen - pi)
*.		 ' n=' n ' len=' len)

*	At least one cell to be occupied by this move must be
*	adjacent to a used cell.

	oi = 0

scan.used

	gt(add1(.oi),len)				:s(scan.len)
	pos = open[pi + oi - 1]				:f(scan.first)
*	out(ne(g.tracing) 'Scan oi=' oi ' pos=' pos)
	adjacent(row(num,pos),column(num,pos)) 		:f(scan.used)s(scan.text)

**	If a move of length LEN has no adjacent cells, then no move
*	of lesser length can have adjacent cells, so we can advance to
*	the next possible starting point.

							:(scan.first)
scan.text

*	Here if adjacent cell found. Set text of move to
*	the permutation specification.

	sub = subarray(open,pi,len)			:f(scan.len)
	move = move(num,sub,size(rack) '?' len)		:f(scan.len)
*	out(ne(g.tracing) 'Scan move ' show.move(move))
	scan = ident(scan) table()
	add1(.count.scanned)
	scan[count.scanned] = move			:(scan.len)

scan.done

	ident(scan)					:s(freturn)
	scan = convert(scan,'array')
 							:(return)
scan.end

	define('scoreline(pair)'
.		'line,word,words,wi,n,start,ch,i,bonus,mult,val') :(scoreline.end)

*	Compute the score of a move on a given line. All the letters of
*	the move will be in upper case on the board so the score of the move
*	is the sum of the scores of all the words with upper case letters in
*	them, for both rows and columns. This function should only be called
*	for lines which have an upper case letter in them as a result of the move.

*SCORELINE*
scoreline

	scoreline = 0
	line = line(pair)
	empty(line)					:s(return)
	bonusline = g.bonus.lines[num(pair)]
	line break(&ucase)				:f(scoreline.error)
	words = words(line)				:f(scoreline.done)
	wi = 0

scoreline.word

	start = words[add1(.wi),1]			:f(scoreline.done)
	word = words[wi,2]
*	add1(.count.scoreline)
	ne(g.tracing) out('scoreline wi=' wi ' start=' start ' word=' word
.		 '.' ' count ' count.scoreline)
	word break(&ucase)				:f(scoreline.word)
	n = size(word)

*	Words of just one letter don't contribute to scoreline since
*	they result from a crossing line.

	eq(n,1)						:s(scoreline.word)

	line = substr(line,start)

* 	Extract corresponding part of bonus line.

	bonusline = substr(g.bonus.lines[num(pair)],start);

	i = 0
	mult = 1;* multiplier value for double and triple word cases.

scoreline.char

	gt(add1(.i),n) 			:s(scoreline.char.done)
	ch = substr(word,i,1)
	bonus = +substr(bonusline,i,1)

*	Update scoreline according to value of letter. Always get at
*	least the value of the letter, and may get double or
*	triple the letter value.

	val = g.value[ch]
	val = (eq(bonus,2) val * 2, eq(bonus,3) val * 3, val)
	scoreline = scoreline + val
	ne(g.tracing) out('ch=' ch ' val=' val ' scoreline now ' scoreline)

*	Update double/triple word multiplier.

	mult = gt(bonus,3) mult * (bonus - 2)		:(scoreline.char)


scoreline.char.done

	scoreline = ne(scoreline) scoreline * mult
	ne(g.tracing) out('mult=' mult ' scoreline=' scoreline)
						:(scoreline.word)
scoreline.error

	out('error tracing line with no new move ' line(pair))
	scoreline = 0					:(return)

scoreline.done

*	ne(g.scoremove) out('scoreline returns ' scoreline)
							:(return)
scoreline.end

	define('scoremove(move)i,p')			:(scoremove.end)

*	A move's score is the sum of the scores of its own line
*	and its crossing lines.

*SCOREMOVE*
scoremove

*	In order to determine which words on the board would be
**	formed by making this move, rebuild CLINES but with the
*	new tiles in uppercase. This way, a word is new if and only if
*	it contains an upper case character. The score is then the
*	sum over all the lines of the scores of the words containing an
*	upper-case character. At most one word in each line of grid will
*	contain an upper-case character.

*	Generate move's line and its cross lines with the move's
*	text in upper case.

	clines(move,1);

*	ne(g.tracing) show.clines()
*	ne(g.tracing) out('scoremove move=' show.move(move))
*	ne(g.tracing) out('g.cln=' g.cln)

	i = 0

scoremove.line

	ne(g.tracing) out('scoremove line' i)
	gt(add1(.i),g.cln)				:s(scoremove.done)
	ne(g.tracing) out('scoremove i=' i ' scoremove =' scoremove)
	scoremove = scoremove + scoreline(g.clines[i])	:(scoremove.line)

scoremove.done

*	There is a bonus of 35 points for playing seven tiles in one move.

	scoremove  = eq(size(size(tiles(move))),7) scoremove + 35;

	ne(g.tracing) out('scoremove returns ' scoremove)
							:(return)
scoremove.end

	define('seen(perm,rack,test)p,c,cp,cmap,next,signature,map,d,dp,dmap')	:(seen.end)

*	Test if a permutation has already been processed in this turn.

*	Racks will typically contain duplicate letters. We can make use of this
*	to avoid useless duplication of effort.
*
*	For example, if first and third letters are the same then in any permutation
*	we can interchange the positions of this letter with no effect. Simply put,
* 	if there are two "E" tiles, it doesn't matter in what order we play them.
*
*	For example, given the rack 'FRIBBLE', there are two B's, at positions five
*	and six, so the signature for permutation '1234567'  is
*
*		1234557
*
*	If later see a permutation such as '1234657', it will have
*	the same signature, and so will not need to investigate
*	futher -- we can move directly to the next permutation.

**	Define a map DMAP from digits to characters by
**	iterating over the permutation. If D is the
**	digit at position P, let *c* be the character
**	at position D in the rack. This is the character
**	corresponding to D. Set *dmap[d]* to *c*.

**	Define a map CMAP from characters to digits by iterating
**	over the rack. Let C be the character at position *p*.
*	If *cmap[c]* is null, this is the first instance of *c*;
*	set *cmap[c]* to *p*. This will be the value used to
**	represent each instance of C in the new permutation.

*	Iterate over the permutation to build an equivalent
**	permutation. Let D be the digit at
**	position P. Set *c* to the value of *dmap[d]*, then
* `	set the next digit in the new permutation to the value of
*	*cmap[c]*.


*	The result is the signature, or normal form, of the permutation.

**	Look up the result in the table SEEN. It the value is not
*	null then we have already seen an equivalent permutation,
*	and so return success.

*	If the value is null, enter the new permutation as the representation
*	of the input permutation, and return failure.

*SEEN*
seen
	ident(perm)				:s(freturn)
	ident(rack)				:s(freturn)

	g.cmap = table('cmap')
	g.dmap = table('dmap')
	cp = dp = 0

seen.d
	d = substr(perm,add1(.dp),1)		:f(seen.c)
	c = substr(rack,d,1)
	out('g.map')
	g.dmap[d] = c
						:(seen.d)
seen.c
	c = substr(rack,cp = cp + 1,1)		:f(seen.mapped)
	out('GET seen.c ')
	ident(g.cmap[c]) g.cmap[c] = convert(cp,'string') :(seen.c)

seen.mapped

	dp = 0
	signature =

seen.next

	d = substr(perm,dp = dp + 1,1)		:f(seen.check)
	c = g.dmap[d]
	signature = signature g.cmap[c]		:(seen.next)

seen.check

 :(seen.outed)
	seens = seens + 1
*	gt(seens,10000) :s(end)

	ne(remdr(seens,100)) :s(seen.outed)
	out()
	show(g.dmap)
	out()
	show(g.cmap)
	out()

	 out('seen.check rack=' rack ' ' perm ' -> ' signature)

seen.outed
	g.signature = signature
	count.signature = count.signature + 1

*	Succeed if have already seen this signature.

*	out('seen same perm=' perm ' rack=' rack )

	out('GET seen.outed ')
	differ(g.tried[signature])			:s(return)

*	Here if first encounter with this signature.

	g.tried[signature] = 1
							:(freturn)
*	out('seen new signature ' signature ' perm=' perm ' rack=' rack '.')
*	See if we have seen an equivalent permutation before.

*	Comapute signature of permutation and rack to account for presence
*	any duplicate tiles.


*	:(freturn)
seen.end

	define('start(pid)player,tiles,perm,perms,permi,free,offset,i,'
.       	'highest,lower,best,n,word,start,score,move,max'):(start.end)

*	Determine best starting.turn. At least one letter in this move
*	must be in the center square (8,8). The only bonus available is
*	double word, for any word of more than four characters.

*	Find the move the highest score. Given two moves with the
*	same score, prefer the one with the lowest tile cost.
*
*	The return value has the form 'm s' where m is the move
*	and s is its score.
*
*	There are seven tiles, so we just try all permutations
*	of length one up to seven.

*START*
start

	max = 7;* maximum number of tiles to play
	player = g.players[pid]
	tiles = rack(player)
	n = 0;* number of tiles to play
	highest = lowest = 0;* best score, lowest cost

*	Assume word will start in column 8

	start = 8

*	Don't use 's' on starting move: save it for later.

	tiles break('s')				:f(start.n)
	tiles = less(tiles,'s')
	max = max - 1

start.n	gt(add1(.n),max)				:s(start.done)

	kind = size(tiles) '?' n
*	out('start.n kind=' kind)
	perms = g.permutations[kind]			:f(start.n)
	permi = 0

start.word

*	Get next word, check that valid, then see if new high score

	perm = perms[add1(.permi)]			:f(start.n)
	word = replace(perm,substr('1234567',1,size(tiles)),tiles)

*	out('kind ' kind ' perm ' perm ' word ' word)
	checkword(word)					:f(start.word)
	add1(.checkwords)

*	Score is the value of the tiles unless the word has five or
*	more characters, in which case the double word bonus
*	at index twelve can be achieved.

	score = (lt(size(word),5) cost(word), 2 * cost(word))

*	See if get bonus for playing seven tiles.

	score = eq(size(word),7) score + 35

**	Add the first word found to set HIGHEST and *lowest*

	eq(highest,0)					:s(start.new)

	lt(score,highest)				:s(start.word)
	gt(score,highest)				:s(start.new)

*	Here if current best and new move have same score.
*	Prefer the one with the lowest cost.

	lt(cost(word),lowest)				:s(start.new)

start.new

	highest = score
	lowest = cost(word)
	best = word
							:(start.word)
start.done

*	Start word at position 8, unless word size greater than
*	five, in which case move it to the left, but making sure
*	move still covers double-word cell at position twelve.

	offset = (lt(size(best,5) 0, 5 - size(best)))

*	Initialize free array for move.

	free = array(size(best))
	i = 0

start.free

	free[add1(.i)] = 7 + i  + offset		:s(start.free)

	start = move(8 + offset,free,best,highest) :(return)

start.end

	define('test.perm(rack,perm,num,move,inlines)'
.		'text,lines,iline,i,p,cline')	:(test.perm.end)

*	Test if applying a permutation PERM to a rack RACK yields a valid move.
*	NUM is the line containing the move, and INLINES is a list of
*	the lines from the grid to be used.

*TEST.PERM*
test.perm

*	NOTE: THE LOOP BELOW IS THE CRITICAL INNER LOOP OF THIS PROGRAM.
*	ANY TIME SPENT SPEEDING THINGS UP ELSEWHERE WILL HAVE LITTLE EFFECT.
*
*	For example, given a move of length 7 with a rack of 7 letters, we
*	need to account for the slightly over 5000 permutations of the letters
*	that can be used here. And note this is just for one possible move ...
*
*	Since most racks will contain duplicate, or even triplicate, instances of
**	the same letter, the table TRIED is used below. This cut the running
*	time of the program by a factor of two when first introduced.

	add1(count.perm)

	seen(perm)				:s(freturn)
	count.cells = count.cells + size(perm)

	g.cln = 0

	text = place(perm,rack)

	lines = copy(inlines);

*	Insert the letters from the tiles corresponding to the permutation
*	into the selected blank cells in the line.  The digit '1' selects
*	the first tile, the digit '2' the second, and so on.  Then see if
*	the result gives a valid line. 'move' to the next permutation if not.
*	(This is a clever use of replace(), even if I do say so myself.)

	tiles(move) = perm;* insert permutation digits into free cells
	iline = insert(lines[num],move);* line with permutation digits entered
	checkline(place(iline,rack))			:f(freturn)

*	'move' is valid on this line, so check validity on crossing lines.
**	Save the valid lines in CLINES for scoring if move proves valid.

*	We could use the clines() procedure for this, but in this loop every
*	statement counts, so in effect we build clines on the fly.
*	Since almost all permutations will result in junk, we want to
*	detect junk as soon as possible so we can move on without wasting
*	needless effort.

	tiles(move) = text

*	out(ne(g.tracing) 'Find valid first '
*		show.move(move) ' ' show.line(line))

	g.clines[add1(.g.cln)] =  pair( id(move), insert(lines[num],move))
	i = 0

*	Check the crossing lines, constructing them as needed, to make sure the
*	move is valid.

test.perm.cross

*	out('find cross ')

*	If next assignment fails, we have finished checking the
*	permutation without finding a valid move, and so return failure.

	p = free(move)[add1(.i)]			:f(return)
	cline = cline(lines,move,p,substr(rack,substr(perm,i,1),1))
	checkline(line(cline))				:f(freturn)

*	out(ne(g.tracing) 'Find valid checkline ' line(cline))

	tiles(move) = place(tiles(move),ucase(rack))

*	out(ne(g.tracing) 'Find text ' tiles(move))

	g.clines[add1(.g.cln)] = cline			:(test.perm.cross)

test.perm.end

	define('valid.start(move)free,num,text')	:(valid.start.end)

*	Test if a suggested starting move is valid.

*VALID.START*
valid.start

*	If this is a starting move, check that it covers column 8 in row 8,
*	and is a word in the dictionary.

	free = free(move)
	text = tiles(move)

	num = convert(free,'integer')			:f(valid.start.free)

	out('valid.start.start num=' num)

	lt(num,9 - size(text))				:s(valid.start.error)
	gt(num,7 + size(text))				:s(valid.start.error)

valid.start.free

*	Here if free is list of cells. Check that '8' is one of them.

	out('valid.start.start.free ' show.move(valid.start))
	out('valid.start.start.free ' free(valid.start))

	free break('8')					:f(valid.start.error)
	checkword(tiles(move))				:s(return)f(freturn)

valid.start.start.error

	out('starting move must use column 8.')		:(freturn)

valid.start.end

