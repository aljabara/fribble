*	Copyright 2017, David Shields

 g.cmap = g.dmap = g.signature =

* This file is part of the fribble project: http://github.com/daveshields/fribble.
*
*	Fribble is free software: you can redistribute it and/or modify
*	it under the terms of the gnu general public license as published by
*	the free software foundation, either version 2 of the license, or
*	(at your option) any later version.
*
*	Fribble is distributed in the hope that it will be useful,
*	but without any warranty; without even the implied warranty of
*	merchantability or fitness for a particular purpose.  See the
*	gnu general public license for more details.
*
*	You should have received a copy of the gnu general public license
*	along with fribble.  If not, see <http://www.gnu.org/licenses/>.

*	Global variables have names starting with 'g.' Their initial value is set
*	in the procedure *init()* and its subfunctions.

*	g.version is the version of the program:

	g.version = '17.1.30'		;* 30 January 2017, 1st version. 
	g.version = '17.2.*'		;* Under development.

*	g.board, array('15,15'), the playing board. Each entry is blank (' ') for 
*	an unplayed cell, or is the letter played.

*	g.bonus.lines,array(30), is the array of lines corresponding to g.bonus

*	g.bonus,array(15,15) gives the bonus values for the squares on the board:

*		1	for the value of the letter itself,
*		2	for double letter,
*		3	for triple letter, 
*		4	for double word, and
*		5	for triple word.

*	A paired line consists of a line number and an associated line.
*	It is used when it is necessary to pass a line of text to a procedure 
*	along with line number from where it was derived.

*	g.channel.temp is channel number used for temporary files, that is, 
*	files that are opened, read, and then immediately closed.

	g.channel.temp = 4

	g.clines = array(8);* for line with move and its crossing lines.
	g.cln = 0;* number of entries in clines.

*	g.date, date and time at start of run. Used to name log file and 
*	seed the random number generator.

*	g.dict, array(15), is an array of hashtables  that are non-null 
*	for words in the dictionary.

	g.highest = 0;* highest score
	g.lowest = 0;* lowest cost

*	g.lines, array(30), is the array of the lines defined by the 
*	rows and columns in the board. 

*	g.log is set to append a copy of standard output to
*	log file 'fribble.log'.
*	g.log.version is version of format for log file.
	
	g.log = 1
	g.log.version = 1

*	g.logfile is the output-associated variable for the log file
*	g.logfile.channel is its channel; g.logfile.name is its name

	g.logfile = g.logfile.name = 
	g.logfile.channel = 5

*	g.maxmoves, maximum number of moves. This is used to avoid 
*	runaway behavior.

	g.maxmoves = 60
	g.maxmoves = 2

*	The program can be run in several modes:

	g.mode.auto = 1;* for auto mode, where fribble moves for both players.
	g.mode.solo = 2;* for solo mode, where you play against fribble.
	g.mode.team = 3;* for team mode, where you and fribble work as team to play another player.
	g.mode.foe  = 4;*is used for 'foe' when playing against another person

	g.mode = g.mode.auto;* default

*	A move consists of a sequence of empty cells in a row or column such 
*	that at least one cell in the sequence is adjacent to an already 
*	occupied cell, with each cell occupied by one of the tiles in the 
*	player's rack.  The cells are ordered from left to right for a 
*	horizontal play, top to bottom for a vertical play.


	data('move(id,free,text,points)')

*		*id*	 gives the line number, in the range 1..30;
*		*free*	 is an array of the free (empty) cells used in this move;
*		*text*	 is the string of tiles of the move; and
*		*points* is the number of points won by playing this move.

*	g.move is the current/last move.

*	g.options maps option names to their value

*	A player is represented by

	data('player(pid,name,kind,rack,total,thirty,highest)')

*	where
*		*pid*		is an integer identifier, either 1 or 2;
*		*name* 		is the player's name;
*		*kind*	 	is the player's kind:
	
			player.kind.solo = 1;* you are playing on your own;
			player.kind.auto = 2;* fribble plays against itself;
			player.kind.team = 3;* you and fribble work as a team; and
			player.kind.foe  = 4;* the other player when in team mode.

*		*rack* 		is the player's rack;
*		*total*		is the player's current score;
*		*thirty* 	is number of moves with scores of 30 
*				or more points; 
*		*highest* 	is the player's highest move score.

*	g.moves is array of the valid moves found by most recent call to find(),
*	sorted with highest scoring move first.
*	g.moves.max is the maximum length of the arrays so produced

	g.moves =
	g.moves.max =

*	g.options.abbrev maps a shorted form of an option to its full
*	name; see init() for details.

*	g.players is an array of the two players.

	g.players = array(2)	
	g.players[1] = player(1)
	g.players[2] = player(2)

*	g.pid is the player of the current player.

	g.pid = 1

		data('pair(num, line)')

*	g.permutations, a table of the permutations of n=1..7 things 
*	taken 1..k at a time.
*	For example, g.perms['7?3'] is permutations of 1..7 
*	taken 3 at a time.
*	Each entry in the table is an array giving the desired 
*	set of permutations.

*	g.permutations.count, a table of the number of permutations 
*	for a given *n* and *k*.

*	g.random_var is used by random() to compute the next pseudo-random value.

	g.random_var = 1

*	g.replay.lines holds the lines read in for subsequence replaying.
*	g.replay is the index of the last line read in from the replay file.
*	g.replay.n is the number of lines in the replay file.

*	g.scoring is used to enable tracing of scoring.

	g.scoring = 1
	g.scoring = 

*	g.tiles, a string containing the characters in the 
*	initial bag of characters.

*	g.tilemanager determines how tiles are dealt out. 
*	If not null, the program manages the tiles and updates the players'
*	racks after each turn.  If null, then you manually update the racks.

	g.tilemanager =

*	g.time is execution time in milliseconds

*	g.trace, if not null, begin tracing at the start of move g.trace.

	g.trace = 

*	g.tracing, set nonzero when tracing initiated by *g.trace* begins.

*	g.turn, the number of the current turn
*	g.turn.last, the turn when the last move was made.

	g.turn = g.turn.last = 0

*	g.used, array('15,15') tracks the cells in the board that have been 
*	used in a move.  A move made after the first move must have at least one
*	tile played in a square adjacent to another that has been 
*	used in a prior move.

*	g.used.lines, array(30), an array of lines defined by the rows and columns
*	 of the used grid.

*	g.value, a map from characters to the tile value of that character.

*	The variables for row and column numbers are used
*	for the input of moves. They map name to line number.

	r1 = r01 = 1; r2 = r02 = 2; r3 = r03 = 3; r4 = r04 = 4; r5 = r05 = 5;
	r6 = r06 = 6; r7 = r07 = 7; r8 = r08 = 8; r9 = r09 = 9; r10 = 10
	r11 = 11; r12 = 12; r13 = 13; r14 = 14; r15 = 15
	c1 = c01 = 16; c2 = c02 = 17; c3 = c03 = 18; c4 = c04 = 19; c5 = c05 = 20
	c6 =  c06 = 21; c7 = c07 = 22; c8 = c08 = 23; c9 = c09 = 24;
*	c10 = 25; c11 = 26; c12 = 27; c13 = 28; c14 = 29; c15 = 30
	
*	Utility functions

	define('init(dictfile,skip,external)c,i,j,s,t')	:(init.end)

*	Initialize global variables.

*INIT*
init
	
	g.date = date(2)

	init.options()
	show.table(g.options)

	init.main(dictfile,skip)

	ne(g.random_var) randomseed();* seed the random number generator
							:(return)
init.end

	define('init.main(dictfile,skip)c,i,j,s,t')	:(init.main.end)

*	Initialize global variables.

init.main

	g.dict = array(15)
	g.board = array('15,15',' ')
	g.lines = lines(g.board)

*	Intialize g.used to blank board.
	g.used = array('15,15',' ')
*	Initialize g.used to all ones for 'dumb' option.
	g.used = ne(g.dumb) array('15,15','1')
	show.grid(g.used)

	g.used.lines = lines(g.used)

	init.bonus()

	init.number()

*	Initialze permutation map.

	init.perm('perm.txt')

	init.tileset()
	init.value()

	init.dict(dictfile,skip)
							:(return)
init.main.end

	define('init.bonus()s,row,col,b,c')		:(init.bonus.end)

*	Initialize the bonus squares for the 15x15 grid: 
*		1 for the value of the letter,
*		2 for double letter,
*		3 for triple letter,
*		4 for double word, and
*		5 for triple word.

*INIT.BONUS*
init.bonus

	g.bonus = array('15,15','1')
	s = 	'5 0104 3 0107 3 0109 5 0112 2 0203 4 0206 4 0210 2 0213 '
.		'2 0302 2 0305 2 0311 2 0314 5 0401 3 0404 4 0408 3 0412 5 0415 '
.		'2 0503 2 0507 2 0509 2 0513 4 0602 3 0606 3 0610 4 0614 '
.		'3 0701 2 0705 2 0711 3 0715 4 0804 4 0812 3 0901 2 0905 2 0911 '
.		'3 0915 4 1002 3 1006 3 1010 4 1014 2 1103 2 1107 2 1109 2 1113 '
.		'5 1201 3 1204 4 1208 3 1212 5 1215 2 1302 2 1305 2 1311 2 1314 '
.		'5 1403 4 1406 4 1410 2 1413 5 1504 3 1507 3 1509 5 1512 '

init.bonus.1

	s len(1) . b ' ' len(2) . row len(2) . col ' ' =  :f(init.bonus.next)
	g.bonus[+row,+col] = +b				:(init.bonus.1)

init.bonus.next

	g.bonus.lines = lines(g.bonus)			:(return)

init.bonus.end

	define('init.dict(filename)file,i,n,w,s')	:(init.dict.end)

*	Initialize the global dictionary g.dict.

*INIT.DICT*
init.dict

*	Set hash table sizes according to number of words of given length.

	s  =	'1 100 1000 4000 9000 15000 23000 28000 25000 20000 '
.		'15000 11000 8000 5000 3000 '

init.dict.tbl

	gt(i = i + 1,15)				:s(init.dict.tbl.1)
	s break(' ') . n ' ' = 
	g.dict[i] = table(+n)				:(init.dict.tbl)

init.dict.tbl.1

	i = 0

*	Read in dictionary from a file, with one word per line.

	filename = ident(filename) 'dict.txt'
	input(.file,g.channel.temp,filename)		:s(init.dict.in)
	out('unable to open input file ' filename)	:(freturn)
	n = 0

init.dict.in

	w = file					:f(init.dict.done)
	gt(size(w),15)					:s(init.dict.in)

*	Process plural words, indicated by 'S' at end.

	differ(substr(w,size(w),1),'S')			:s(init.dict.w)
	w = substr(w,1,size(w) - 1)
	g.dict[size(w)][w] = +1
	g.dict[size(w) + 1][w 's'] = +1			:(init.dict.in)

init.dict.w

	g.dict[size(w)][w] = +1				:(init.dict.in)

init.dict.done

	endfile(g.channel.temp)				:(return)

init.dict.end

	define('init.number()i1,i2,i3,s1,s2,w')		:(init.number.end)

*	Initialize g.numbers.

init.number

	s1 =	'one two three four five six seven eight nine ten eleven twelve '
.		'thirteen fourteen fifteen sixteen seventeen eighteen nineteen '
	s2 =	'twenty thirty forty fifty sixty seventy eighty ninety '
	i1 = 0; i2 = 10; i3 = 20

	g.numbers = table(100)
	map(g.numbers,100,'one hundred')

init.number.digits

	s1 break(' ') . w ' ' =				:f(init.number.tens)
	map(g.numbers,i1 = i1 + 1,w)			:(init.number.digits)

init.number.tens

	s2 break(' ') . w ' ' =				:f(init.number.decades)
	map(g.numbers,i2 = i2 + 10,w)			:(init.number.tens)

init.number.decades
	
	le(i3 = i3 + 1,99)				:f(return)
	eq(remdr(i3,10))				:s(init.number.decades)
	map(g.numbers,i3,g.numbers[(i3 / 10) * 10] ' ' g.numbers[remdr(i3,10)])
.					:s(init.number.decades)f(return)
init.number.end

	define('init.options()s,t,options,optname,opt,val,cname')	:(init.options.end)

*	Initialize command line options.

init.options

	g.options = table()
	g.options.abbrev = table()

*	Set up map from first two characters of option name to full name.

	s = 'auto dumb moves random seen shell solo team trace '

init.options.abbrev

	s span(' ' ) =
	ident(s)					:s(init.options.abbrev.done)
	s break(' ') . opt = 				:f(init.options.abbrev.done)
 &dump = 3
	map(g.options.abbrev,substr(opt,1,2),opt)	:(init.options.abbrev)

init.options.abbrev.done

*	Enter default options, those with non-null initial value.
*	These values may be changed if they also occurs in the
*	actual option list.

	options = '-uauto -umoves=' g.maxmoves ' '
.		'-urandom=' g.random_var  ' '

	options = options host(0) ' '

	out('host options: ' options '.')
	show.table(g.options)


init.options.next
	
	val = 1
	options '-u' =					:f(return)
	options break(' ') . opt span(' ') =	

init.options.opt


	lt(size(opt),3) out('no such option ' opt '  - ignoring.')
.						:s(init.options.next)
	optname = g.options.abbrev[substr(opt,1,2)]
*	out('optname=' optname)
	ident(optname) out('no such option ' opt ' - ignoring.')
.						:s(init.options.next)
*	out('dave')

	opt 'no'				:s(init.options.no)
	opt break('=')				:s(init.options.val)

*	cname = $('init.options.opt.' optname)
*	out('cname=' cname ' optname=' optname '.')
*	:($('init.options.opt.' optname))

init.options.no

*	'no' before option name sets val to zero.
	
	opt 'no' =
	val = 0						
	out('option -no- opt=' opt '.')
							:(init.options.opt)

init.options.val

*	'=' is followed by value

	opt break('=') . opt '=' rem . val		:(init.options.opt)

init.options.set

*	Set value for command options.

	map(g.options,optname,val)			:(init.options.next)

init.options.opt.auto

	g.mode = g.mode.auto				:(init.options.next)

init.options.opt.dumb

	g.dumb = val					:(init.options.set)

init.options.opt.moves

	g.maxmoves = val				:(init.options.set)

init.options.opt.random

	g.random_var = (ne(val) val,2017)		:(init.options.set)

init.options.opt.seen

	g.seen = val					:(init.options.set)

init.options.opt.shell

	g.shell = val					:(init.options.set)

init.options.opt.solo

	g.mode = g.mode.solo				:(init.options.next)

init.options.opt.team

	g.mode = g.mode.team				:(init.options.next)

init.options.opt.trace

	g.trace = val					:(init.options.set)

init.options.end

	define('init.perm(filename)line,ifile,n,k,lines,nread')	:(init.perm.end)

*	Initialize the list of possible permutations from a file.

*INIT.PERM*
init.perm

	g.permutations = table(7)
	g.permutations.count = table(100)
	input(.ifile,g.channel.temp, filename)			:s(init.perm.next)
	out('unable to open permutation file ' filename) 	:(freturn)

init.perm.next

	line = ifile					:f(init.perm.done)
	line break('?') . n '?' break(' ') . k ' ' rem . count :f(init.perm.err)
	g.permutations.count[n '?' k] = count
	ara = array(count)
	ai = 0

init.perm.array

	ara[ai = ai + 1] = ifile			:s(init.perm.array)
	map(g.permutations,n '?' k,ara)			:(init.perm.next)

init.perm.done

	endfile(g.channel.temp)				:(return)

init.perm.err

	out('init.perm error, line ' lines '  '  line) :(freturn)

init.perm.end

	define('init.tileset()ch,n,s')			:(init.tileset.end)

* 	Initialize set of tiles, ignoring the 'blank' tiles for now.

*INIT.TILESET*
init.tileset

	s = 'a 9 b 2 c 2 d 5 e 13 f 2 g 3 h 4 i 8 j 1 k 1 l 4 m 2 '
.           'n 5 o 8 p 2 q 1 r 6 s 5 t 7 u 4 v 2 w 2 x 1 y 2 z 1 '
	g.tiles =

init.tileset.ch

	s break(' ') . ch ' ' break(' ') . n ' ' =	:f(init.tileset.ch.done)
	g.tiles = g.tiles dupl(ch,n)			:(init.tileset.ch)

init.tileset.ch.done

	randomseed();* set random number generator seed

	shuffle();* shuffle the tileset
							:(return)

init.tileset.end

	define('init.value()s,c')			:(init.value.end)
*INIT.VALUE*
init.value

	g.value = table(52)
	s = &lcase &ucase

*	Assume value of a tile is one, and correct that below.

init.value.next

*	assume value is 1
	s len(1) . c =					:f(init.value.letters)
	g.value[c] = +1					:(init.value.next)

init.value.letters

*	Update assumptions for letters with value greater than one.

	s = 
.	'b 4 c 4 d 2 f 4 g 3 h 3 j 10 k 5 l 2 m 4 '
.	'n 2 p 4 q 10 u 2 v 5 w 4 x 8 y 3 z 10 '
.	'B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 '
.	'N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 '

init.value.update

	s break(' ') . c ' ' break(' ') . v ' ' =	:f(return)
	g.value[c] = +v					:(init.value.update)

init.value.end

	define('adjacent(r,c)')				:(adjacent.end)

*	Test if the cell in row *r* and column *c* is adjacent to one 
*	that has been used.

*ADJACENT*
adjacent

	gt(r,1) differ(g.used[r - 1,c],' ')	:s(return) ;* cell to north
	lt(c,15) differ(g.used[r,c + 1],' ')	:s(return) ;* cell to east
	gt(c,1) differ(g.used[r,c - 1],' ')	:s(return) ;* cell to west
	lt(r,15) differ(g.used[r + 1,c],' ')	:s(return) ;* cell to south
						:(freturn)
adjacent.end

	define('append(str,w,ch)')				:(append.end)

*	Append word *w* to string *str*, prefixing with *ch* if *str* is not null,
*	or using space if *ch* is null.

*APPEND*
append

	append = (ident(str) w, str (ident(ch) ' ' , ch) w)	:(return)

append.end


	define('avail(pair)line,spaces,c,i,oi')	:(avail.end)

*	Return array containing the indexes of the avail (blank) cells in line.
*	Fail if no cells are available.

*AVAIL*
avail
	line = line(pair)
	spaces = spaces(line)
	eq(spaces,0)					:s(freturn)
	avail = array(spaces)
	i = ai = 0

avail.c

	c = substr(line, i = i + 1, 1)			:f(avail.done)
	differ(c,' ')					:s(avail.c)
	avail[oi = oi + 1] = +i				:(avail.c)

avail.done

	eq(g.tracing)					:s(return)
	i = 0; c = 

avail.done.ch

	c = c lpad(avail[i = i + 1],3)		:s(avail.done.ch)
*	out(ne(g.tracing) 'Open: ' lpad(lineid(num(pair)),3) ' '  
*		show.hex(line) '|  |' show.line(line) '| is ' c)
							:(return)
avail.end

	define('bonus.lines()i')			:(bonus.lines.end)

*BONUS.LINES*
bonus.lines

	bonus.lines = array(30)

bonus.lines.next

	gt(i = i + 1,15)				:s(return)
	bonus.lines[i] = hline(g.bonus,i)
	bonus.lines[i + 15] = vline(g.bonus,i)		:(bonus.lines.next)

bonus.lines.end

	define('checkline(line)word')			:(checkline.end)

*	Test if all the words in a line are in the dictionary.

*CHECKLINE*
checkline

	count.checkline = count.checkline + 1
	line span(' ') =
	empty(line)					:s(return)
	line = line ' ';* to simplify breaking out words.

checkline.1

	line span(' ') =
	line break(' ')  . word ' ' =			:f(return)
	eq(size(word),1)				:s(checkline.1)
	checkword(word)					:f(freturn)s(checkline.1)

checkline.end

	checkwordn = 0

	define('checkword(word)')			:(checkword.end)

*	Test if a word is in the dictionary.

*CHECKWORD*
checkword

	count.checkword = count.checkword + 1

*	Accept words of a single character since they can occur in crossing lines.

	eq(size(word),1)				:s(return)

	word = lcase(word);* in case upper case letters have wrongly crept it.
	differ(g.dict[size(word)][word])		:f(freturn)s(return)

checkword.end

	define('cline(lines,move,p,ch)c,line')		:(cline.end)

*	Return crossing line of p-th cell in move *move*.
*	*ch* gives tile to be played.

*CLINE*
cline
	count.cline = count.cline + 1

*	Cross line of row r, position p, is column p.
*	Cross line of column c, position p, is row p.

	c = (le(id(move),15) p + 15, p);* cross line id
	line = lines[c];* cross line
	p = (le(id(move),15) id(move), id(move) - 15);* position to insert
	line = substr(line,1,p - 1) ucase(ch) substr(line,p + 1)
	cline = pair(c,line)				:(return)

cline.end

	define('clines(move,upper)p,c,ch,line')		:(clines.end)

*	Update g.clines to contain the line for move *move* and all
*	its crossing lines. Express the letters of the move in upper case
*	(for later scoring) if *upper* is not null.

*CLINES*
clines
	line = g.lines[id(move)]
	p = free(move)[1]

*	First entry is for the line containing the move

	g.cln = 1
	g.clines[1] = pair(id(move), insert(g.lines[id(move)],move,1))
	i = 1

*	On each pass through the loop, we compute the crossing line of the
*	i-th character in the move.

clines.i

	p = free(move)[i]


*	Cross line of row r, position p,  is column p.
*	Cross line of column c, position p, is row p.

	c = (le(id(move),15) p + 15, p);* cross line
	line = g.lines[c];* cross line
	p = (le(id(move),15) id(move), id(move) - 15);* position to insert 
	ch = substr(text(move),i,1)
	line = (gt(p,1) substr(line,1,p - 1),'') 
.		 (differ(upper) ucase(ch), ch) (lt(p,15) substr(line,p + 1),'')
	g.clines[g.cln = g.cln + 1] = pair(c, (ident(upper) lcase(line), line))
	le(i = i + 1, size(text(move)))			:s(clines.i)f(return)

clines.end

	define('column(num,pos)')			:(column.end)

*	Returns column corresponding to position *pos* in line *num*.

*COLUMN*
column

	column = ((gt(num,15) num - 15, pos))		:(return)

column.end

	define('cost(text)')				:(cost.end)

*	Return the cost of *text*, defined as the sum of the 
*	values of the tiles in *text*.

*COST*
cost

	text len(1) . ch =				:f(return)
	cost = cost + g.value[ch]			:(cost)

cost.end

	define('counter(text,count)')			:(counter.end)

*	Output the descriptive text *text* and value *n* of a counter.

*COUNTER*
counter

	out(lpad(text,26) lpad(count,12))		:(return)

counter.end

	define('counters()')				:(counters.end)

*	Output the collected counter metrics.

*COUNTERS*
counters

	out()
	out('Performance metrics:')
	counter('moves'				, thousands(g.turn))
	g.time = (time() - g.time);* execution time in milliseconds 
	g.time = g.time / ( 1000 * g.turn)	;* seconds per move
	counter('seconds per move'		, thousands(g.time))
	counter('placements found by scan'	, thousands(count.scanned))
	counter('permutations examined'		, thousands(count.perm))
	counter('signatures computed'		, thousands(count.signature))
	counter('signatures already seen'	, thousands(count.signature.seen))
	counter('cells examined'		, thousands(count.cells))
	counter('potential moves found'		, thousands(count.moves	))
	counter('lines checked'			, thousands(count.checkline))
	counter('words checked'			, thousands(count.checkword))
	counter('cross lines checked'		, thousands(count.cline))
	counter('valid moves found'		, thousands(count.valid))
	counter('most valid moves in a turn'	, thousands(g.moves.max))
	counter('total inserts'			, thousands(count.insert))
	counter('contiguous inserts'		, thousands(count.insert.contig))
	counter('split inserts'			, thousands(count.insert.split))
							:(return)
counters.end

	define('datename(date)s')				:(datename.end)

*	Convert date to form with no blanks, just dashes, to be
*	suitable for use as part of a file name.

datename

	datename = replace(date,' :','--')		
	datename = substr(datename,12,8) '-' substr(datename,1,10)
							:(return)
datename.end

	define('empty(line)')				:(empty.end)

*	Test if line is empty (null or all blanks).

*EMPTY*
empty

*	In most cases, the first character in line is not null.

	differ(substr(line,1,1),' ')			:s(freturn)
	line span(' ') =
	ident(line)					:s(return)f(freturn)

empty.end
	
	define('endgame()')				:(endgame.end)
	
*	Summarize results at end of game.

*ENDGAME*
endgame

	out(	name(g.players[1])  ' scored ' number(total(g.players[1])) ' points, '
.		'with a best move of ' number(highest(g.players[1])) ' points.')

	out(	name(g.players[2])  ' scored ' number(total(g.players[2])) ' points; '
.		'with a best move of ' number(highest(g.players[2])) ' points.')

	out(gt(thirty(g.players[1])) name(g.players[1]) ' had ' 
.		number(thirty(g.players[1])) ' moves of thirty or more points.')

	out(gt(thirty(g.players[2])) name(g.players[2]) ' had ' 
.		number(thirty(g.players[2])) ' moves of thirty or more points.')

	counters()
							:(return)
endgame.end

	define('find(pid,turn)rack,num,inlines,line,moves,nmoves,mi,m,perms,perm,'
.	 'permi,fline,tline,cline,highest,lowest,i,p,score,move,tried')	
.							:(find.end)

*	Find all the valid moves and their scores given the current board 
*	and the indicated rack. For each line, find the set of all possible 
*	moves for that line. Then for each move check the options (permutations) 
*	that can be played from the tileset.  For each specific permutation, 
*	see if the resulting line contains only valid words.  If not, go on 
*	to the next permutation. If true, then see if all the lines affected by 
*	the move contain only valid words.  If not, go on to the next permutation.
*	If so, then add up the scores of all new words created by the move.

*	From amongst the valid moves determine the best move as follows.
*	If two moves have different scores, prefer the one with the higher score.

*	The 'cost' of a move is the sum of the values of the tiles in the move; so 
*	want to keep cost low to save higher value tiles for later moves.
*	If two moves have the same score and different costs, prefer the move 
*	with the lower cost.  If two moves have the same score and cost, 
*	while one uses the letter 's' and the other doesn't, prefer the move 
*	that doesn't use the letter 's'.

*	Find returns the best move as defined above, or null if it is unable 
*	to find a valid move.

*FIND*
find

*	See if first move, in which case call start()

	find = eq(turn,1) start(pid)			:s(return)

	rack = rack(g.players[pid])
	lines = copy(g.lines)
	inlines = copy(lines)
	g.highest = 0;* highest score this turn
	g.lowest = 0;* lowest cost this turn
	g.moves = table(20)
	g.tried = table(100)
	nmoves = num = 0

find.line

	gt(num = num + 1,30)				:s(find.done)
	line = lines[num]
*	out(ne(g.tracing) 'Find.line ' lpad(lineid(num),3) ' ' show.line(line))
	moves = scan(pair(num,line),rack)		:f(find.line)
	mi = 0

find.move

	count.moves = count.moves + 1
	move = moves[mi = mi + 1,2]			:f(find.line)
*	out(ne(g.tracing) 'Find.move mi ' mi ' ' show.move(move,'find'))
	points(move) = 
	permi = 0

*	The rack will almost always have at least two, and sometimes three,
*	identical letters.  Use *tried* to track previous permutations,
*	to avoid duplicate testing for validity of the same text.
	
	g.tried = table(100)

	perms = g.permutations[text(move)]		:s(find.next)

*	Something must be wrong with the requested permutation

	out('fatal permutation request ' text(move)) :(end)

find.next

	perm = perms[permi = permi + 1]			:f(find.move)
	ident(perm)					:s(find.move)
	seen(perm,rack,1)					:s(find.next)
	test.perm(rack,perm,num,move,inlines)		:f(find.next)

find.score

	score = 0

*	out(ne(g.tracing) 'Found valid move ' show.move(move) ' in ' 
*.		show.pair(pair(num,line)))

*	Score the line by summing the scores of the lines saved in clines.
	
*	out(ne(g.tracing) 'valid move :' line '  move '  id(move) ' ' 
*.		size((text(move)) '  '
*.		free(move)[1] '...' free(move)[size(text(move))] 
*.		' ' text(move))
 
	count.valid = count.valid + 1
	move = copy(move)

*	out(ne(g.tracing) 'Find cross ' show.move(move) '  text=' text(move))
*	ne(g.tracing) show.move(move)
*	ne(g.tracing) show.play(move)
*	out(ne(g.tracing) 'Find calling scoremove')

	points(move) = +scoremove(move)	
	g.moves[nmoves = nmoves + 1] = move
	g.cln = 0;* reset for next permutation
	find = isbest(move) copy(move)			:(find.next)

find.done

	ident(find)					:s(find.fail)
	:(return)

	moves = rsort(g.moves,2)

*	Convert two-dimensional array to one-dimensional array.

	i = 0
	g.moves = array(nmoves)

find.done.moves

	gt(i = i + 1,nmoves)			:s(return)
	g.moves[i] = moves[i,2]			:f(return)
	move = g.moves[i]
	out('find.done.moves i=' i ' perm=' perm ' text="' text(move) '"')

						:(find.done.moves)
find.fail

*	out('find failed ')

	output = ident(find) 'find FAILED, no move found.'

							:(freturn)
find.end

	define('game(mode)players,player,opn,move,i,li,offset,open.word,'
.		'open.score,n,tiles,moves,li,passed,board,lfn,tmp') :(game.end)

*	Play a game of fribble. *max* is the maximum number of moves.
*	Mode is 
*		one to have fribble play a game with itself,
*		two to let you play against fribble, and 
*		three to work with fribble to play with another person,
*		who may be using fribble themself, but good for them!

*GAME*
game

*	Test to see if log file needed. Even if not, we always call log() 
*	function. It will do nothing if no log file. This avoids need 
*	to test for presence of log file before each call to log().

	eq(g.log)					:s(game.setup)

*	Open log file.

	g.logfile.name = datename(g.date) '.fri'
	output(.g.logfile,g.logfile.channel,g.logfile.name)	:s(game.log)
	out('unable to open log file ' g.logfile.name)		:(game.setup)

game.log

	g.time = time()
	log('* game ' mode)
	log('* version ' g.version)
	log('* time.start ' g.time)
	log('* date.start ' g.date)
*	tmp = sort(g.options)
*	out('datatype(tmp) ' datatype(tmp))

game.log.1

*	ident(tmp[i = i + 1,1],'#')			:s(game.log.1)
*	log('* option ' tmp[i = i,1] ' ' tmp[i,2]) 
							:(game.log.2)
game.log.2
	
	i = 0
	log.tiles()
	log.player(1)
	log.player(2)

game.setup

	pid = 2;* set to two so will become one when loop first entered

game.turn

	g.turn = g.turn + 1
	log('turn ' g.turn)

*	ne(f.trace) out('g.turn=' g.turn ' g.maxmoves=' g.maxmoves)
	gt(g.turn,g.turn.last + 3) 
.		out('Game over - too many turns with no move.') :s(game.over)

	gt(g.turn,g.maxmoves)				
.		out('Game over -- too many turns (' 
.		g.maxmoves ').') :s(game.over)

	pid = (eq(pid,1) 2, 1)

	player = g.players[pid]

	out('Move ' g.turn ': ' name(player) 
.		 (differ(g.tilemanager) ', with tiles "'
.		show.tiles(rack(player),'A'),'')	'",')

	turn(pid,mode)			:f(game.turn.fail)s(game.turn)

game.turn.fail

*	Here if turn failed because no move could be found.
*	Try to swap three tiles

	out('no move, swapping tiles.')
	rack(player) = swap(pid,3)			:(game.turn)
	
game.fail

*	Here if no move found.

	out('No move found.')

*	Here if no move found, in which case the return value is a set of 
*	swapped tiles. If *move* is null, then pass.

	differ(move)					:s(game.swap)
	passed = passed + 1
	out(gt(passed,6) ' Too many passed moves.')	:s(game.over)
	out('Player ' name(player) ' passes.')		:(game.turn)
	
game.swap

	out('swapping tiles pid=' pid)
	rack(player) = swap(pid,3)
	out('Player ' name(player) ' swapped tiles.')
	out('Player ' name(player) ' now has tiles ' 
.		show.tiles(rack(player))) :(game.turn)

game.over						

	endgame()					

*	Complete log file.

	log('* total.1 ' total(g.players[1]))
	log('* total.2 ' total(g.players[2]))
	log('* date.finis ' date(2))
	log('* time.finis ' time())
	log('endgame')

	differ(logfile) endfile(g.logfile.channel)
							:(return)

game.end

	define('grid(lines,start)i,r,c,line')		:(grid.end)

*	Construct a grid from a sequence of lines beginning at index *start*,
*	(1..15 for rows, 16..30 for columns.

*GRID*
grid

	grid = array('15,15',' ')
	start = ident(start) +1
	start = (le(start,15) 1, 16)
	gt(start,15)					:s(grid.col)

*	Here to build grid from the rows.

	r = 0

grid.nextrow

	gt(r = r + 1,15)				:s(grid.done)
	line = lines[r]					:f(grid.3)
	i = 0
grid.r

*	out('grid r ' r '  ' i + 1 ' ' substr(line,i + 1,1))
	grid[r,i = i + 1] = substr(line,i,1)		:s(grid.r)f(grid.nextrow)

grid.col

*	Here to build grid from the columns.

	c = 14;* set to c will index first column after entering loop below.

grid.nextcol

	gt(c = c + 1,30)				:s(grid.done)
	line = lines[c]
	i = 0

grid.c

	grid[i = i + 1,c] = substr(line,i,1)		:s(grid.c)f(grid.nextcol)

grid.done						:(return)

grid.end

	define('hline(g,r)')				:(hline.end)

*	Return the horizontal line of grid *g* corresponding to 
*	row *r* as a string.

*HLINE*
hline
	r = +r
	hline = g[r,1] g[r,2] g[r,3] g[r,4] g[r,5] 
.		g[r,6] g[r,7] g[r,8] g[r,9] g[r,10]
.		g[r,11] g[r,12] g[r,13] g[r,14] g[r,15]
							:(return)
hline.end

	define('input.user()')				:(input.user.end)

*	Get a line from the user, usually from the terminal, or from
*	a user input file.

input.user

	input.user = terminal				:f(freturn)s(return)

input.user.end

	define('log.tiles()')				:(log.tiles.end)

*	Write tiles set to log file

log.tiles

	log('tiles  "' g.tiles '"')		:(return)

log.tiles.end

	define('log.player(pid)')			:(log.player.end)

*	Write player description to log file.

log.player
	log('player ' pid ' ' show.player(pid))			
							:(return)

log.player.end


	define('insert(line,move,upper)c,f,i,text')	:(insert.end)

*	Insert the text of a move into its free list of empty
*	cells in the line of the move.  Express the text in upper case 
*	if *upper* is not null.

*INSERT*
insert
	count.insert = count.insert + 1
	text = (differ(upper) ucase(text(move)), text(move))
	f = free(move)
	c = size(text(move))
	ne(f[c] - f[1], c - 1)			:s(insert.chars)

*	Here if cells are contiguous. Insert text after part before it,
*	and before part after it.

	count.insert.contig = count.insert.contig + 1

	insert = substr(line, 1, f[1] - 1) text substr(line, f[c] + 1)
	out(ne(size(line),15) 'insert failure ' line)		:s(end)
							:(return)
insert.chars

*	Here if cells not contiguous. Unpack the line, insert the 
*	move text, and pack it back up.

	count.insert.split = count.insert.split + 1

	insert = unpack(line)

insert.ch

	gt(i = i + 1,size(text(move)))			:s(insert.done)
	insert[free(move)[i]] = substr(text,i,1)	:(insert.ch)

insert.done

	insert = pack(insert)				:(return)

insert.end

	define('isbest(move)')			:(isbest.end)

*	Test the score of a move to see if it the best yet seen in a turn.

*ISBERT*
isbest
	out(ne(f.showscore) 'Find points(move) ' points(move) 
.		'  highest=' g.highest ' lowest=' g.lowest)

	lt(points(move),g.highest)			:s(freturn)
	gt(points(move),g.highest)			:s(isbest.new)

*	Here if points equal, look for lower cost

	lt(cost(text(move)),g.lowest)			:s(isbest.new)
	gt(cost(text(move)),g.lowest)			:s(freturn)

*	Here if same points and cost, see if one uses 's' and the 
*	other doesn't.  Continue search if current best doesn't use 's'.

	text(find) ? break('s')				:f(freturn)

*	Here if current best uses an 's'. 
*	Continue if new move also uses 's'.

	text(move) ? break('s')				:s(freturn)

isbest.new

*	Here to add the new best move.

	g.highest = points(move)
	g.lowest = cost(text(move))
	out(ne(g.tracing) 'find NEW BEST move ' show.move(move))
							:(return)
isbest.end

	define('lcase(s)')				:(lcase.end)

*	Convert argument to lower case.

*LCASE*
lcase

	lcase = replace(s,&ucase,&lcase)		:(return)

lcase.end
	
	define('less(str,sub)before,after')		:(less.end)

*	Less removes the first instance of each character in *sub* from *str*, 
*	where *sub* is a substring of *str*.

*LESS*
less
	ident(str)					:s(return)
	less = str

less.ch
	sub len(1) . ch =				:f(return)	
	less break(ch) . before  ch rem . after
	less = before after				:(less.ch)

less.end

	define('lineid(num)')				:(lineid.end)

*	Returns row or column id corresponding to line number *num*.

*LINEID*
lineid

	lineid = (le(num,15) 'r' lpad(num,2,0), 'c' lpad(num - 15,2,0)) :(return)

lineid.end

	define('lines(g)i')				:(lines.end)

*	Express the grid *g* as a sequence of lines, with the 
*	first fifteen consisting of the rows and the last 
*	fifteen consisting of the columns.

*LINES*
lines

	lines = array(30)

lines.next

*	Make sure all entries in lines are in lower case,
*	since we enter moves in g in upper case.

	gt(i = i + 1,15)				:s(return)
	lines[i] = lcase(hline(g,i))
	lines[i + 15] = lcase(vline(g,i))		:(lines.next)

lines.end

	define('log(text)')				:(log.end)

*	Write text to logfile if making a log.

*LOG*
log
	eq(g.log)					:s(return)

	g.logfile = text				:(return)

log.end

	define('log.move(pid,move)')			:(log.move.end)

*	Write move description to log file.

log.move

	log('move ' pid ' ' show.move(move))		:(return)

log.move.end

	define('m(id,str,text)fi,free,len,pos')		:(m.end)

*	Create move in line with given id and text.
*	*str* is one of the following:
*	  integer	gives starting position, in range 1..15
*	  string that can be converted to integer, treat as in integer case
*	  string giving list of empty (open) cells used, with entries
*			separated by spaces.

*	For example, the following each specify the word 'fribble' 
*	starting at position 6 in row 8.

*		m(r8,6,'fribble')
*		m(r8,'6 7 8 9 10 11 12','fribble')

*M*
m
	free = array(size(text))

*	out('m str' str)
	str break(' ')					:s(m.list)
	pos = +str					:f(m.error)

m.pos

	len = len + 1
*	out('pos fi ' fi ' ' pos + (fi - 1 ))
	free[fi = fi + 1] = pos + (fi - 1)		:s(m.pos)f(m.done)

m.list

*	Prepare for m.next loop.

	str = str ' '

m.next

	str break(' ') . pos span(' ')  =		:f(m.done)
	len = len + 1
	free[fi = fi + 1] = pos				:(m.next)

m.error

	out('m(id,str,text) error - .') :(freturn)

m.done

	ne(len, size(text)) out('m size mismatch,try again'):s(freturn)

	out('m.done id=' id ' text=' text ', free[1]=' 
.		free[1] ' free[n]=' free[size(text)])

	m = move(id,free,text)				:(return)

m.end

	define('makemove(pid,move)player,board,lines')	:(makemove.end)

*	Make a move for player with id *pid*, and return its value.

*MAKEMOVE*
makemove

	player = g.players[pid]
	makemove = move
	out(ne(g.tracing) 'Game move ' show.move(move))
	g.turn.last = g.turn
	total(player)	= total(player) + points(move)
	thirty(player)	= ge(points(move),30) thirty(player) + 1
	highest(player) = gt(points(move),highest(player)) points(move)
	playmove(move)

	out(	'played "' show.tiles(text(move)) '" for ' 
.		number(points(move)) ' points,'
.		' starting at ' lineid(id(move)) 
.		', position ' number(free(move)[1]) '.')

	out('Score now: '  
.		name(g.players[1]) ', ' number(total(g.players[1]))  '; '
.		name(g.players[2]) ', ' number(total(g.players[2]))  '. ')

	out('B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 '
.	    'N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 ')
	out()

*	Display move in grid with just this move in upper case by saving 
*	the board, playing the move with the text in upper case, showing it,
*	and then restoring the board to its saved state.

	board = copy (g.board)
	lines = copy(g.lines)
	text(move) = ucase(text(move))
	playmove(move)
	text(move) = lcase(text(move));* restore
*	show.grid(g.board)
	g.board = board
	g.lines = lines
*	show.lines(g.lines,'Lines')
*	show.grid(g.used)
	g.used.lines = lines(g.used)
*	Update lines affected by grid changes to maintain consistency.

	g.bonus.lines = lines(g.bonus)

	g.lines = lines(g.board)

*	Fold g.lines into lower case so only new moves made later will 
*	display in upper case.

	li = 0

makemove.fold						

	g.lines[li = li + 1] = lcase(g.lines[li]) :s(makemove.fold)

*	Rebuild board since lines have changed.

*	out('rebuilding board')
	g.board = grid(g.lines)				
							:(return)
makemove.end

	define('manual()line,out')			:(manual.end)

*	Enter move manually (by hand).

*MANUAL*	
manual
	ne(f.trace) out('getting move manually')
*	Here to enter the move manually

manual.in
	out('enter move')
	manual = input.user()				:f(end)

	manual ( 'pass' | 'swap' | 'resign' | 'quit') :s(return)

	manual = eval(manual)				:f(manual.error)

*	ident(datatype(manual),'move') out(show.move(manual))	:f(manual.error)

	ne(g.turn,1)					:s(manual.check)

manual.check

	valid(manual)					:s(return)

	out('need to enter a valid move')		:(manual)

manual.error

	out('manual error evaluating ' line)		:(freturn)

manual.end

	define('map(tbl,key,val)')			:(map.end)

*	Test for entry for *key* in table *tbl*, adding
*	new one with value *val* if needed.
*	Maintain a count of the number of entries using key '#',
*	which is used solely for this purpose.

map

	map = tbl[key]
	differ(map)					:s(return)

*	Here to create new entry.

	tbl[key] = val
	tbl['#'] = tbl['#'] + 1				
	map = val					:(return)

map.end

	define('number(n)')				:(number.end)

*	If *n* can be represented as a string of one or two words then
*	return that string. Otherwise return *n*.

number
	number = g.numbers[n]
	differ(number)					:s(return)
	number = n					:(return)
number.end

	define('order(tiles)chars,ch,c1,c2,swaps,i,v1,v2') :(order.end)

*	Sort the tiles in *tiles* according to their value, with 
*	least valuable first.  Though 's' has a nominal value of 1, 
*	its actual value is greater, since almost a third of the words
*	in the dictionary are plurals. Give 's' a value of 5 for the 
*	purpose of the sort.

*ORDER*
order
	order = le(size(tiles),2) tiles			:s(return)
	chars = unpack(tiles)
							:(order.loop)
order.next

	eq(swaps,0)					:s(order.done)
	swaps = i = 0						

*	Loop through chars, swapping out of order characters,
*	 until all characters are properly ordered.

order.loop

	c1 = chars[i = i + 1]				:f(order.next)
	c2 = chars[i + 1]				:f(order.next)
	v1 = (ident(c1,'s') 5, g.value[c1])
	v2 = (ident(c2,'s') 5, g.value[c2])
	le(v1,v2)					:s(order.loop)
	ch = c2
	chars[i + 1] = c1
	chars[i] = ch
	swaps = swaps + 1				:(order.loop)

order.done

	order = pack(chars)				:(return)

order.end

	define('out(line)')				:(out.end)

*	Output a line.

*OUT*
out
	output = line					:(return)

out.end

*	pack.sizes = array(30)

	define('pack(chars)n,i')			:(pack.end)

*	Pack the array of characters *chars* into a line.

*PACK*
pack
	n = +prototype(chars)
	ne(n,15)					:s(pack.chars)

*	Almost all calls to pack are to pack a line from the grid,
*	so do it directly, and so avoid quadratic behavior 
*	if concatenate characters in loop.

	pack =  chars[1]  chars[2]  chars[3]  chars[4]  chars[5]  
.		chars[6]  chars[7]  chars[8]  chars[9]  chars[10] 
.		chars[11] chars[12] chars[13] chars[14] chars[15] 
	
pack.chars
	pack = pack chars[i = i + 1]		:f(return)s(pack.chars)

pack.end

	define('place(txt,rack)')			:(place.end)

*	Place the permutation digits in *txt* with the 
*	corresponding tiles from *rack*.

*PLACE
place

	place = replace(txt,substr('1234567',1,size(rack)),rack)
							:(return)
place.end


	define('playmove(move)i,p,r,c,ch')		:(playmove.end)

*	Play move *move*, updating the board and related objects.

*PLAYMOVE*
playmove

	id = id(move)
*	out('enter playmove ' show.move(move))
*	out('free ' prototype(free(move)))

playmove.ch

	p = free(move)[i = i + 1]			:f(playmove.done)
	r = row(id,p)
	c = column(id,p)
	ch = substr(text(move),i,1)
*	out('playmove p=' p ' i=' i ' r=' r ' c=' c ' ch=' ch)
	g.board[r, c] = ch
*	out('playmove r=' r ' c=' c ' char=' g.board[r,c])
	g.used[r,c]   = 1
	g.bonus[r, c] = ' ' :(playmove.ch) ;* indicate bonus no longer available 

playmove.done
*	out('playmove.done i=' i)
	out(ne(g.tracing) 'playmove returns')
							:(return)
playmove.end
	
	define('prefix(str,pre)word')			:(prefix.end)

*	Prefix takes a list of space-separated words str and prefixes each
*	with the string pre.

*PREFIX*
prefix

	str = str ' ';* so each word followed by space

prefix.1

	str break(' ') . word span(' ')  =		:f(return)
	prefixcount = prefixcount + 1
	prefix = append(prefix, pre word,'A')		:(prefix.1)

prefix.end

	define('random(n)')				:(random.end)

*	Return integer uniformly distributed in 1,2,...,n. 
*	If n=0 returns real uniformly distributed in the interval [0,1].
*	The Algorithm is based on that in section 16.1 of "Algorithms in SNOBOL4,"
*	James F. Gimpel, John Wiley and Sons, 1976.

*RANDOM*
random

	g.random_var = remdr(g.random_var * 4676, 414971)
	random  = g.random_var / 414971.0
	random = ne(n) convert(random * n,'integer') + 1
							:(return)
random.end

	define('randomseed(n)s,c')			:(randomseed.end)

*	Compute seed for random number generator from date and time.
*	Do nothing if argument is zero.

*RANDOMSEED*
randomseed
	eq(n)						:s(return)
	s = g.date
	s = replace(s,'/:-','   ')

*	Get all the digits in s.

randomseed.loop

	s len(1) . c =					:f(randomseed.done)
	ident(c,' ')					:s(randomseed.loop)
	g.random_var = g.random_var c			:(randomseed.loop)

randomseed.done

*	Reverse the seed so digits depending on time come first.

	g.random_var = +reverse(g.random_var	)	:(return)

randomseed.end

	define('reader(filename)n')			:(reader.end)

*	Return file as table of lines, with zero-th entry giving number
*	of lines.

*READER*
reader
	input(.file,g.channel.temp,filename)		:s(reader.opened)
	
	out('unable to open reader file ' filename '.') :(freturn)

reader.opened

	n = 0
	reader = table(100)

reader.next
	reader[n = n + 1] = file		:s(reader.next)

*	Here at end of file, convert map to array of lines.

	reader[0] = n - 1;* line count

	endfile(g.channel.temp)
							:(return)

reader.end

*	One-time initialization for replay()

	str = 'date endgame game move play rack tiles total turn version '
	replay.ops = table(10)

replay.init	
	str break(' ') . op ' ' =			:f(replay.init.done)
	replay.ops[op] = 1				:(replay.init)

replay.init.done

	define('replay(option)line,command'):(replay.end)

*	Replay commands from previous game.
*	If *option* is an integer, replay that number of commands
*	from the replay file. If *option* is a string not convertible
*	to an integer, prepare for replaying by reading in the lines
*	from that file.

*REPLAY*
replay
	g.replay.lines = reader(option)			:s(replay.lines)
	out('reader returned ' prototype(ops) ' commands.')
	out('error reading commands from ' option)	:(freturn)
	
replay.lines

	g.replay.i = 0;* set up for replaying.
	g.replay.n = commands[0]			:(return)


replay.next
	gt(g.replay.i = g.replay.i + 1, g.replay.n)	:s(replay.done)
	line = g.replay.lines[g.replay.i]		:f(replay.done)
	out('replaying line ' g.replay.i ' |' line '|')
	ident(line)					:s(replay.next)
	line '*'					:s(replay.next)
	line span(&lcase) . command =
	out('replay.op=' command)
	differ(replay.ops[command])			:s($('replay.' command))

	out('replaying unknown command ' command ', ignore.')	:(replay.next)

replay.endgame
							:(replay.done)
replay.move
	line span(' ') len(1) . pid span(' ') =
	out('replay.move evaluating |' line '|')
	move = eval(line)
	out('replaying move datatype=' datatype(move)  ','  show.move(move))
	show.play(makemove(pid,move))
							:(replay.next)
replay.player
	line '.' len(1) . pid span(' ') = 
	g.players[pid] = eval(line)
							:(replay.next)
replay.rack
	line '.' len(1) . pid =
	line = ' rack(g.players[ ' pid '] = ' line
	out('replay.rack ' line)
	eval(line)
							:(replay.next)
replay.tiles
	line = ' g.tiles = ' line
	out('replay.tiles ' line)
	eval(line)
							:(replay.next)
replay.turn
	line span(' ') span('0123456789') . turn =
	g.turn = turn					:s(replay.next)

replay.done
							:(return)
replay.end

	define('replenish(pid)player,rack,s')		:(replenish.end)

*	Replenish a player's rack. Do this from the tileset is g.tilemanager is
*	set, or get the new tileset from the user otherwise.

*REPLENISH*
replenish

	player = g.players[pid]
	differ(g.tilemanager)				:s(replenish.auto)

replenish.manual

	out('enter rack for player: ' show.player(pid))
	replenish = lcase(input)			:f(replenish.eof)
	ident(replenish) out('no input - try again.')	:s(replenish.manual)
	gt(size(replenish),7) out('too many letters |' replenish 
.			'|, try again.') :s(replenish.manual)
	s = replenish
	s span(&lcase) =
	differ(s) out('non-alphabetic character - try again.')	
.							:s(replenish.manual)

							:(return)
replenish.eof

	out('end of data on input - bye ')		:(end)

replenish.auto

	replenish = rack(player)

	eq(size(replenish),7)				:s(return)

	replenish = replenish take(7 - size(replenish)) :(return)

replenish.end

	define('row(num,pos)')				:(row.end)

*	Returns row corresponding to position *pos* in line *num*.

*ROW*
row
	row = ((le(num,15) num, pos))		:(return)

row.end

	define('scan(pair,rack)num,line,i,pi,open,oi,nopen,n,'
.			'first,pos,move,sub,len')	:(scan.end)

*	Scan the given line to find the places where a valid move can be made.
*	At least one cell in a move must be adjacent to an occupied cell. 
*	*line* is the line to be scanned, and *num* gives 
*	its position on the board.

*SCAN*
scan

	line = line(pair)
	num = num(pair)
*	out(ne(g.tracing) 'Scan line ' lineid(num) ' ' 
*		show.line(line) ' ' show.hex(line))

*	Allocate and fill in *open*, an array giving the 
*	positions of the open cells.

*	Fail if no empty cells.

	open = avail(pair)				:f(scan.done)

*	Nopen is the number of open cells in the line.

	nopen = +prototype(open)
	
	pi = 0

scan.first

	first = open[pi = pi + 1]			:f(scan.done)
	
*	*first* is the position of the first letter in the move.

*	The number of moves *n* that can be made starting at a given 
*	position in *open* depends on the number of tiles in the rack,
*	and the number of remaining open cells in the line.
	
	n = +size(rack)
	n = gt(n, nopen - pi) nopen - pi;* number of remaining open cells
	
*	Try for moves of length len=n,n-1...1 starting at position 
*	*first* in the line.

	len = n + 1;* prime for loop

scan.len

	le(len = len - 1)				:s(scan.first)

*	out(ne(g.tracing) 'Scan first=' first ' left =' (nopen - pi)
*.		 ' n=' n ' len=' len)

*	At least one cell to be occupied by this move must be 
*	adjacent to a used cell.
	
	oi = 0

scan.used

	gt(oi = oi + 1,len)				:s(scan.len)
	pos = open[pi + oi - 1]				:f(scan.first)
*	out(ne(g.tracing) 'Scan oi=' oi ' pos=' pos)
	adjacent(row(num,pos),column(num,pos)) 		:f(scan.used)s(scan.text)

*	If a move of length *len* has no adjacent cells, then no move 
*	of lesser length can have adjacent cells, so we can advance to 
*	the next possible starting point.

							:(scan.first)
scan.text

*	Here if adjacent cell found. Set text of move to 
*	the permutation specification.

	sub = subarray(open,pi,len)			:f(scan.len)
	move = move(num,sub,size(rack) '?' len)		:f(scan.len)
*	out(ne(g.tracing) 'Scan move ' show.move(move))
	scan = ident(scan) table()
	count.scanned = count.scanned + 1
	scan[count.scanned] = move			:(scan.len)

scan.done

	ident(scan)					:s(freturn)
	scan = convert(scan,'array')			
 							:(return)
scan.end

	define('scoreline(pair)'
.		'line,word,words,wi,n,start,ch,i,bonus,mult,val') :(scoreline.end)

*	Compute the score of a move on a given line. All the letters of the move 
*	will be in upper case on the board so the score of the move is the sum 
*	of the scores of all the words with upper case letters in them, for
*	both rows and columns. This function should only be called for lines 
*	which have an upper case letter in them as a result of the move.

*SCORELINE*
scoreline

	scoreline = 0
	line = line(pair)
	empty(line)					:s(return)
	bonusline = g.bonus.lines[num(pair)]
	line break(&ucase)				:f(scoreline.error)
	words = words(line)				:f(scoreline.done)
	wi = 0

scoreline.word

	start = words[wi = wi + 1,1]			:f(scoreline.done)
	word = words[wi,2]
*	count.scoreline = count.scoreline + 1
	ne(g.tracing) out('scoreline wi=' wi ' start=' start ' word=' word
.		 '.' ' count ' count.scoreline)
	word break(&ucase)				:f(scoreline.word)
	n = size(word)

*	Words of just one letter don't contribute to scoreline since 
*	they result from a crossing line.

	eq(n,1)						:s(scoreline.word)

	line = substr(line,start)

* 	Extract corresponding part of bonus line.

	bonusline = substr(g.bonus.lines[num(pair)],start);

	i = 0
	mult = 1;* multiplier value for double and triple word cases.

scoreline.char

	gt(i = i + 1,n) 			:s(scoreline.char.done)
	ch = substr(word,i,1)
	bonus = +substr(bonusline,i,1)

*	Update scoreline according to value of letter. Always get at least 
*	the value of the letter, and may get double or triple the letter value.
	
	val = g.value[ch]
	val = (eq(bonus,2) val * 2, eq(bonus,3) val * 3, val)
	scoreline = scoreline + val
	ne(g.tracing) out('ch=' ch ' val=' val ' scoreline now ' scoreline)

*	Update double/triple word multiplier.

	mult = gt(bonus,3) mult * (bonus - 2)		:(scoreline.char)


scoreline.char.done

	scoreline = ne(scoreline) scoreline * mult	
	ne(g.tracing) out('mult=' mult ' scoreline=' scoreline)
						:(scoreline.word)
scoreline.error

	out('error tracing line with no new move ' line(pair))
	scoreline = 0					:(return)

scoreline.done

*	ne(g.scoremove) out('scoreline returns ' scoreline)
							:(return)
scoreline.end

	define('scoremove(move)i,p')			:(scoremove.end)

*	A move's score is the sum of the scores of its own line 
*	and its crossing lines.

*SCOREMOVE*
scoremove

*	In order to determine which words on the board would be 
*	formed by making this move, rebuild *clines* but with the 
*	new tiles in uppercase. This way, a word is new if and only if
*	it contains an upper case character. The score is then the 
*	sum over all the lines of the scores of the words containing an 
*	upper-case character. At most one word in each line of grid will
*	contain an upper-case character.

*	Generate move's line and its cross lines with move text in upper case.

	clines(move,1);

	ne(g.tracing) show.clines()
	ne(g.tracing) out('scoremove move=' show.move(move))
	ne(g.tracing) out('g.cln=' g.cln)

	i = 0

scoremove.line

	ne(g.tracing) out('scoremove line' i)
	gt(i = i + 1,g.cln)				:s(scoremove.done)
	ne(g.tracing) out('scoremove i=' i ' scoremove =' scoremove)
	scoremove = scoremove + scoreline(g.clines[i])	:(scoremove.line)

scoremove.done

*	There is a bonus of 35 points for playing seven tiles in one move.

	scoremove  = eq(size(size(text(move))),7) scoremove + 35;

	ne(g.tracing) out('scoremove returns ' scoremove)
							:(return)
scoremove.end

	define('seen(perm,rack,test)p,c,cp,cmap,next,signature,map,d,dp,dmap')	:(seen.end)

*	Test if a permutation has already been processed in this turn.

*	Racks will typically contain duplicate letters. We can make use of this
*	to avoid useless duplication of effort.
*
*	For example, if first and third letters are the same then in any permutation
*	we can interchange the positions of this letter with no effect. Simply put,
* 	if there are two "E" tiles, it doesn't matter in what order we play them.
*
*	For example, given the rack 'FRIBBLE', there are two B's, at positions five
*	and six, so the signature for permutation '1234567'  is
*
*		1234557
*
*	If later see a permutation such as '1234657', it will have
*	the same signature, and so will not need to investigate 
*	futher -- we can move directly to the next permutation.

*	Define a map *dmap* from digits to characters by
*	iterating over the permutation. If *d* is the
*	digit at position *p*, let *c* be the character
*	at position *d* in the rack. This is the character
*	corresponding to *d*. Set *dmap[d]* to *c*. 

*	Define a map *cmap* from characters to digits by iterating
*	over the rack. Let *c* be the character at position *p*.
*	If *cmap[c]* is null, this is the first instance of *c*;
*	set *cmap[c]* to *p*. This will be the value used to
*	represent each instance of *c* in the new permutation.

*	Iterate over the permutation to build an equivalent
*	permutation. Let *d* be the digit at
*	position *p*. Set *c* to the value of *dmap[d]*, then
* `	set the next digit in the new permutation to the value of
*	*cmap[c]*.

	
*	The result is the signature, or normal form, of the permutation.

*	Look up the result in the table *seen*. It the value is not
*	null then we have already seen an equivalent permutation,
*	and so return success.  

*	If the value is null, enter the new permutation as the representation 
*	of the input permutation, and return failure.

*SEEN*
seen
	ident(perm)				:s(freturn)
	ident(rack)				:s(freturn)

	g.cmap = table(10)
	g.dmap = table(10)
	cp = dp = 0
	
seen.d
	d = substr(perm,dp = dp + 1,1)		:f(seen.c)
	c = substr(rack,d,1)
	map(g.dmap,d,c)
						:(seen.d)
seen.c
	c = substr(rack,cp = cp + 1,1)		:f(seen.mapped)
	ident(g.cmap[c]) map(g.cmap,c,convert(cp,'string')) :(seen.c)

seen.mapped

	dp = 0
	signature = 

seen.next

	d = substr(perm,dp = dp + 1,1)		:f(seen.check)
	c = g.dmap[d]
	signature = signature g.cmap[c]		:(seen.next)

seen.check

 :(seen.outed)
	seens = seens + 1
	gt(seens,10000) :s(end)
	
	ne(remdr(seens,100)) :s(seen.outed)
	out()
	show.table(g.dmap)
	out()
	show.table(g.cmap)
	out()

	 out('seen.check rack=' rack ' ' perm ' -> ' signature)

seen.outed
	g.signature = signature
	count.signature = count.signature + 1

*	Succeed if have already seen this signature.

*	out('seen same perm=' perm ' rack=' rack )

	differ(g.tried[signature])			:s(return)

*	Here if first encounter with this signature.

	g.tried[signature] = 1
	count.signature.seen = count.signature.seen + 1
							:(freturn)
*	out('seen new signature ' signature ' perm=' perm ' rack=' rack '.')
*	See if we have seen an equivalent permutation before.

*	Compute signature of permutation and rack to account for presence
*	any duplicate tiles.


*	:(freturn)
seen.end

	define('shell()ops,key,op')			:(shell.def.end)

*	Simple 'shell' for fribble. 

*	Read commands from terminal and execute them. 
*	This is meant mainly for debugging, testing
*	and as a way to learn how fribble operates.

*SHELL*
shell
	out('entered shell')
*	s.ok is set to one if last 'eval' command succeeded, zero if it failed.

	s.ok = 0

*	s.move is last move entered in shell

	s.move =

*	s.ops is the list of shell commands. 

	s.ops = 
. 	'board clear eval find help init letters next move pass play quit '
.	'remove replay score search start tiles valid '

*	s.opabbrev maps abbreviated input to corresponding shell.
*	You need specify only first one or more characters
*	in the operation name.

	s.opabbrev = table(100)

	s.letters = &lcase &ucase

*	s.replay is set to read commands from file 'term' before 
*	asking for key board input.

	s.replay =

*	s.v is set to value of last 'eval' operation.

*	Initialize s.optable to acceptable abbreviations for shell 
*	operations.  Acceptable abbreviations consist of the initial 
*	two or more characters of the operation, up to the 
*	full command name itself.


	ops = s.ops

shell.setup.next
	ops break(' ') . op ' ' =		:f(shell.setup.end)
	key = op
	s.opabbrev[substr(key,1,1)] = op
shell.setup.op
	s.opabbrev[key] = op
	key = substr(key,1,size(key) - 1)	:f(shell.setup.next)
	gt(size(key),1)		:s(shell.setup.op)f(shell.setup.next)
shell.setup.end
	tab = char(9)
	out('starting shell')

*	Shell main command loop.

shell.loop
	out('starting replay')
	replay('keyin') :(end)
	out('enter shell loop') :(end)
	ident(s.replay)					:s(shell.term)
	linein = termfile				:s(shell.line)
	linein 'q'					:s(shell.loop)
	s.replay =
	endfile(3)
	output(.termfile,3,'term[-a]')

shell.term

	out('op?')
	linein = terminal ' '				:f(shell.end)

shell.line

	termfile = differ(termfile) linein;* save line
*	out('linein =' linein '.')
	linein span(s.letters) . opin span(' ') rem . operand 
.							:s(shell.loop.ok)
	operand = trim(operand)
	out('fail opin =' opin ' operand=' operand '.') :(shell.loop)

shell.loop.ok

	opin = lcase(opin)
	op = s.opabbrev[opin]
	out('op ' opin ' operand ' operand '.')
*	out('op abbrev =' op)

	differ(op)					:s(shell.op)
	out('unknown op: ' op)				:(shell.loop)

shell.op						:($('shell.' op))

shell.board

	show.board(g.board)				:s(loop)

shell.clear

*	Clear the board
	g.board = array('15,15',' ')			:(shell.loop)

shell.end
	out('shell end of input - bye')		:(end)
shell.eval
	out('evaluating ' operand)
	s.v = eval(operand)	:s(shell.eval.succeed)f(shell.eval.fail)
shell.eval.succeed
	s.ok = 1					:(shell.loop)
shell.eval.fail
	out('eval failed, ' &errtext)
	s.ok = 0					:(shell.loop)

shell.find

*	Use find to find best move given current tiles for Player 1.

	s.move = find(1,g.turn)			
	show.move(s.move)				:(shell.loop)

shell.game

*	(I know you're wondering, but Fribble wasn't written just 
*	so I could I say I wrote a program where it made sense to 
*	use the identifier 'shell.game'.)

*	Enter (or leave) game mode, if argument is 'on' ('off').

	s.game = (ident(substr(operand,2,1),'y') 1, 0)
							:(shell.loop)

shell.help
	out(rpad('board',14) 'show board')
	out(rpad('clear',14) 'clear board')
	out(rpad('eval' ,14) 'evaluation expression')
	out(rpad('help' ,14) 'help')
	out(rpad('init' ,14) 're-initialize global variable')
	out(rpad('letters',14) 'show values of letters')
	out(rpad('move' ,14) 'enter move')
	out(rpad('play' ,14) 'play last move')
	out(rpad('quit' ,14) 'exit shell')
	out(rpad('remove' ,14) 'remove (undo) last move played')
	out(rpad('score' ,14) 'score last move entered')
	out(rpad('search' ,14) 'search dictionary for matching words')
	out(rpad('start' ,14) 'make starting move')
	out(rpad('rack tiles',14) 'set rack to tiles, default "fribble"')
	out(rpad('valid' ,14) 'validate move')
							:(shell.loop)
shell.init
	init()						:(shell.loop)
	
shell.letters
	out(	'B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 '
.		'N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 ')
							:(shell.loop)
shell.move

*	Get move, assume user knows about 'mf' and 'm' functions.

	s.move = eval(operand)
	out('Last move now ' show.move(s.move))		:(shell.loop)

shell.next

*	When not in game mode, next is a no-op.
*	When in game mode, next increments the player id; if the
*	resulting player has the fribble attribute then a move is made
*	on that player's behalf, and another next command is executed.

	ident(s.game)					:s(shell.loop)

	g.turn = g.turn + 1
	g.pid = (eq(g.pid,1) 2, 1)
	
*	See if player has 'fribble' attribute.
	
	ident(fribble(g.players[g.pid]))		:s(shell.loop)
	
	s.move = (eq(g.turn,1) start(g.pid), find(g.pid))
	ident(s.move) out('no move found, so no move made')	:(shell.loop)

	points(s.move) = scoremove(s.move)
	show.play(makemove(g.pid,s.move))
	replenish(g.pid)
							:(shell.loop)	
							:(shell.loop)

shell.pass
	
*	Pass from making a move. This is typically used when the player with pid=1
*	does not want to make the first move.

	out('Player ' pid ' passes.')
	g.turn = g.turn + 1
							:(shell.loop)

shell.play

*	Play last move entered.

	points(s.move) = scoremove(s.move)
	makemove(g.pid,s.move)
	show.play(s.move)
							:(shell.loop)
shell.quit
	out('exiting')					:(end)

shell.remove
	out('remove not yet implemented')		:(shell.loop)
	
*	Remove (undo) last move played, by setting its free cells to unused

							:(shell.loop)
shell.replay.

*	Replay input saved in 'term' from prior run.
*	To main user confident in our programming skills,
*	don't replay the 'quit' op.

	replay('keyin')	
	s.replay = 1
	input(.termfile,3,'term')
							:(shell.loop)
shell.score

*	Show score computation for last move entered.

	g.showscore = 1
	out('Scoring ' show.move(s.move))
	clines(s.move,1)
	show.clines()
	score = scoremove(s.move)
	points(move) = score
	g.showscore = 0
	out('Move ' show.move(move) ' scores ' score ' points.') :(shell.loop)


shell.scoremove
	
*	g.showscore = 1
	points(move) = findscore()
	out('move is worth ' points(s.move) ' points.')
							:(shell.loop)
	out('do you want to make this move (y or ENTER for yes,'
.					' no otherwise)?')
	ans = terminal					:f(shell.eod)
	ident(ans)					:s(shell.moveon)
	ident(ans,'y')					:s(shell.moveon)
							:(shell.you.move)

shell.search

*	Search dictionary for matching words

	out('search not yet implemented')

shell.start

*	Make starting move using current tiles, default to 'fribble'

	rack(g.players[1]) = ident(rack(g.players[1])) 'fribble'
	s.move = start(1,1)

*	Merge to make the move.
							:(shell.play)

shell.tiles

*	Get rack from operand.

	tiles = operand
	gt(size(tiles,7)) out('truncating to seven tiles')
	tiles = gt(size(tiles,7)) substr(tiles,1,7)
	rack(g.players[1]) = tiles
	out('rack now ' tiles)
							:(shell.loop)

shell.validmove

	show.move(move)
	out((validmove(move) ' valid move','invalid move'))	:(shell.loop)

*shell.move
shell.moveon

	makemove(g.pid,s.move)
	show.play(move)
							:(shell.loop)
shell.eof

	out('end of input - bye')			:(return)

shell.def.end

*	Show if probably never used. Delete code below when cnfirm this.

	define('show(rack,player)')			:(show.end)

*	Show state of board, used and value grids before start of move.

*SHOW*
show
	out('rack for player ' player ': ' rack)

	show.grid(g.board)
	show.lines(g.lines)
*	show.board(g.bonus,'bonus')
	show.grid(g.used)
							:(return)
show.end

	define('show.board(board,title)b,r,c,ch,line')	:(show.board.end)

*	Show the bonus grid.

*SHOW.BOARD*
show.board

	show.header()

show.board.r

	gt(r = r + 1,15) 				:s(show.board.finish)
	line = lpad(r,2) '|' 
	c = 0

show.board.c

	gt(c = c + 1,15)				:s(show.board.margin)
	ch = ucase(board[r,c])
	b = g.bonus[r,c]
	differ(ch,' ')					:s(show.board.ch)

*	Here if empty cell, see if there is a bonus to be show.boarded.

	ne(b,1)						:s(show.board.b)

*	Here to show.board empty cell.

	line = line ' -'				:(show.board.c)

show.board.b

* 	Here to show.board bonus.

	ch = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line ch 					:(show.board.c)

show.board.margin

	out(line '|')					:(show.board.r)

show.board.ch

	line  = line ' ' ch				:(show.board.c)

show.board.finish

	out()						:(return)

show.board.end

	define('show.bonus()b,r,c,l,line')		:(show.bonus.end)

*	Show the board.

*SHOW.BONUS*
show.bonus

	show.header('bonus')

show.bonus.r

	gt(r = r + 1,15) 				:s(show.bonus.finish)
	line = lpad(r,2) '|'
	c = 0

show.bonus.c

	gt(c = c + 1,15)				:s(show.bonus.l)
	l = g.bonus[r,c]
	line = differ(l,' ') line ' ' l 		:s(show.bonus.c)

* Here for blank cell, show.bonus bonus if applicable

	b = g.bonus[r,c]
	eq(b)						:s(show.b)
* 	Here to show bonus
	l = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line l 					:(show.bonus.c)

show.bonus.b

*	Here to show.bonus empty cell.
	line = line ' -'				:(show.bonus.c)

show.bonus.l

	out(line '|')					:(show.bonus.r)

show.bonus.finish

	out()						:(return)

show.bonus.end

	define('show.clines(move,title)i,p,line,num')	:(show.clines.end)

*	Show the clines array of lines

*SHOW.CLINES*
show.clines

*	show.board(g.board)
*	title  = 'clines' (differ(title) ' ' title, '')
*	out(title)
	out(differ(title) 'clines for ' show.move(move))
	out('    123456789012345')

show.clines.n

	le(i = i + 1, g.cln)				:f(return)
	p = g.clines[i]
	num = num(p)					:f(return)
	line = line(p) 
	out(lpad(lineid(num),2) ' '  replace(line,' ','.')) :(show.clines.n)

show.clines.end

	define('show.grid(g)r')				:(show.grid.end)

*	Show a grid.

*SHOW.GRID*
show.grid

	show.header()

show.grid.r

	gt(r = r + 1,15) 				:s(show.grid.done)
	out(show.hline(g,r))				:(show.grid.r)		 

show.grid.done

	show.header()
	out()						:(return)

show.grid.end

	define('show.header(label)')			:(show.header.end)

*SHOW.HEADER*
show.header

	out(differ(label) label)
	out('                     1 1 1 1 1 1')
	out('   1 2 3 4 5 6 7 8 9 0 1 2 3 4 5')	:(return)

show.header.end

	define('show.hex(line)ch,i')			:(show.hex.end)

*	Show line with blanks replaced by hex digits showing 
*	their position in the line.

*SHOW.HEX*
show.hex

	ch = substr(line,i = i + 1,1)				:f(return)
	show.hex = show.hex (ident(ch,' ') 
.		substr('123456789ABCDEF',i,1), ch) :(show.hex)

show.hex.end

	define('show.hline(g,row)line,ch')		:(show.hline.end)

*	Returns the line corresponding to row *row* in 
*	grid *g* with two characters per cell.

*SHOW.HLINE*
show.hline

	line = hline(g,row)
	show.hline = '|'

show.hline.ch

	line len(1) . ch = 				:f(show.hline.done)
	show.hline = show.hline ' ' ch  		:(show.hline.ch)

show.hline.done

	show.hline = show.hline '|'			:(return)

show.hline.end

	define('show.line(line)')			:(show.line.end)

*	Show a line with blanks replaced by '.'

*SHOW.LINE*
show.line

	show.line = replace(line,' ','.')		:(return)

show.line.end

	define('show.lines(lines,title)i,line,titled')	:(show.lines.end)

*	Show the lines that are not empty in an array of lines

*SHOW.LINES*
show.lines

	title  = 'lines' (differ(title) ' ' title, '')
	out(itle)

show.lines.n

	line = lines[i = i + 1]				:f(return)
	empty(line)					:s(show.lines.n)
	differ(titled)					:s(show.lines.titled)

*	Don not list header unless at least one non-empty line

	out('    123456789012345')


	titled = 1

show.lines.titled

	out(lpad(lineid(i),2) ' ' replace(line,' ','.')) :(show.lines.n)

show.lines.end


	define('show.move(move)f,i,ff') 		:(show.move.end)

*	Show a move.

*SHOW.MOVE*
show.move

	out(ident(move) ' show.move argument is NULL ') :s(return)

show.move.i

	gt(i = i + 1,size(text(move)))			:s(show.move.f)
	ff = free(move)[i]
	ident(datatype(ff,'string'))			:s(show.move.fail)
	f = append(f,ff)				:s(show.move.i)

show.move.f

	show.move = 'm(' 
.			lineid(id(move)) ',' 
.			"'" f "',"
.			  "'" text(move) "',"
.			(differ(points(move)) '+' points(move), '')  
.	             ')'
							:(return)
show.movefail

	out('free ff failure ')				:(end)

show.move.end

	define('show.free(free,title)i')		:(show.free.end)

*	Show free array.

*SHOW.FREE*
show.free

	show.free = show.free append(lpad(free[i = i + 1]),3)	:s(show.free)
	show.free = 'Open: ' title ' ' show.free
							:(return)
show.free.end

	define('show.pair(pair)')			:(show.pair.end)

*	Show paired item.

*SHOW.PAIR*
show.pair

	show.pair = '{' lineid(num(pair)) ',' "'" 
.			replace(line(pair),' ','.') "'" '}'	:(return)

show.pair.end

	define('show.play(move)plines,b,r,c,ch,line')	:(show.play.end)

*	Show the board.

*SHOW.PLAY*
show.play

*	Display move in grid with just this move in upper case by 
*	saving the board, playing the move with the text in upper case, 
*	showing it, and then restoring the board to its saved state.

	board = copy (g.board)
	lines = copy(g.lines)
	text(move) = ucase(text(move))
	playmove(move)
	plines = lines(g.board)
	text(move) = lcase(text(move));* restore
	g.board = board
	g.lines = lines

*	Collect the lines of the grid.

	lines = array(15)

show.play.l

	gt(r = r + 1,15) 				:s(show.play.ll)
	plines[r] = show.hline(board,r)			:(show.play.l)

show.play.ll

	r = 0
	out(lpad('',22) '1 1 1 1 1 1'
.		 lpad('',20) '1 1 1 1 1 1')
	out(lpad('', 4) '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5'
.		 lpad('', 2) '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5')

show.play.r

	gt(r = r + 1,15) 				:s(show.play.finish)
	line = lpad(r,2) '|' 
	c = 0

show.play.c

	gt(c = c + 1,15)				:s(show.play.margin)
	ch = ucase(board[r,c])
	b = g.bonus[r,c]
	differ(ch,' ')					:s(show.play.ch)

*	Here if empty cell, see if there is a bonus to be show.played.

	ne(b,1)						:s(show.play.b)

*	Here to show.play empty cell.

	line = line ' -'				:(show.play.c)

show.play.b

* 	Here to show.play bonus.

	ch = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line ch 					:(show.play.c)

show.play.margin

	out(line  plines[r])				:(show.play.r)

show.play.ch

	line  = line ' ' ch 				:(show.play.c)

show.play.finish

	out(lpad('', 4) '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5'
.		 lpad('', 2) '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5')
	out()						:(return)

show.play.end

	define('show.player(pid)player')		:(show.player.end)

*	Show player description.

*SHOW.PLAYER*
show.player

*	data('player(pid,name,kind,rack,total,thirty,highest)')

	player = g.players[pid]
	show.player = 
.		'player('  pid(player)	',"' name(player) '"'  	  	',' 
.		'player.kind.'	( 	
.			eq(kind(player),player.kind.auto) 'auto',
.			eq(kind(player),player.kind.foe)  'foe',
.			eq(kind(player),player.kind.solo) 'solo',
.			eq(kind(player),player.kind.team) 'team', ''
.			        )	','
.		'"' rack(player) '",' total(player) ','
.		(gt(highest(player)) highest(player) ,'')			
.		')'
							:(return)
show.player.end

	define('show.table(tbl,col)ara,i,key')		:(show.table.end)

*	Show a table.

show.table

*	Do nothing if table is empty.

	ident(tbl[-1])					:s(return)
	ara = sort(tbl,col)

show.table.next

*	loop:	Get the next table key.

	key = ara[i = i + 1,1]				:f(return)

*	Skip the special entry showing the table size.

*	eq(key,-1)					:s(show.table.next)

*	Show the entry and continue back to loop.
 
	out(lpad(i,4) ' ' lpad(key,8) ' - > ' ara[i,2])
							:(show.table.next)
show.table.end

	define('show.tiles(tiles)i')			:(show.tiles.end)

*	Show a list of tiles, separated by blanks.

*SHOW.TILES*
show.tiles
	gt(i = i + 1,size(tiles))			:s(return)

	show.tiles = append(show.tiles, ucase(substr(tiles,i,1))) :(show.tiles)

show.tiles.end

	define('show.words(words)i,pos')		:(show.words.end)

*	Show results of words() call.

show.words

	pos = words[i = i + 1,1]			:f(return)
	out('words ' lpad(pos,2) ' ' words[i,2])	:(show.words)

show.words.end

	define('shuffle()tiles,n,passes,r1,r2,ch')	:(shuffle.end)

*	Shuffle the remaining tiles by randomly swapping.players[2] tiles several times.

*SHUFFLE*
shuffle	

	tiles = unpack(g.tiles)
	n = size(g.tiles)
	passes = random(1000) + 500

shuffle.next

	le(passes = passes - 1)				:s(shuffle.done)
	r1 = random(n); r2 = random(n)
	eq(r1,r2)					:s(shuffle.next)
	ch = tiles[r1]
	tiles[r1] = tiles[r2]	
	tiles[r2] = ch					:(shuffle.next)

shuffle.done

	g.tiles = pack(tiles)
							:(return)
shuffle.end



	define('spaces(line)n')				:(spaces.end)

*	Count number of spaces in line.

*SPACES*
spaces

	line len(1) . c =				:f(return)
	spaces = ident(c,' ') spaces + 1		:(spaces)

spaces.end

	define('start(pid)player,tiles,perm,perms,permi,free,offset,i,'
.		'highest,lower,best,n,word,start,score,move,max'):(start.end)

*	Determine best starting.turn. At least one letter in this move 
*	must be in the center square (8,8). The only bonus available is
*	double word, for any word of more than four characters.

*	Find the move the highest score. Given two moves with the same score,
*	prefer the one with the lowest tile cost.
*
*	The return value has the form 'm s' where m is the move 
*	and s is its score.
*
*	There are seven tiles, so we just try all permutations 
*	of length one up to seven.

*START*
start

	max = 7;* maximum number of tiles to play
	player = g.players[pid]
	tiles = rack(player)
	n = 0;* number of tiles to play
	highest = lowest = 0;* best score, lowest cost

*	Assume word will start in column 8

	start = 8

*	Don't use 's' on starting move: save it for later.

	tiles break('s')				:f(start.n)
	tiles = less(tiles,'s')
	max = max - 1

start.n	gt(n = n + 1,max)				:s(start.done)

	kind = size(tiles) '?' n
*	out('start.n kind=' kind)
	perms = g.permutations[kind]			:f(start.n)
	permi = 0

start.word

*	Get next word, check that valid, then see if new high score

	perm = perms[permi = permi + 1]			:f(start.n)
	word = replace(perm,substr('1234567',1,size(tiles)),tiles)

*	out('kind ' kind ' perm ' perm ' word ' word)
	checkword(word)					:f(start.word)
	checkwords = checkwords + 1

*	Score is the value of the tiles unless the word has five or 
*	more characters, in which case the double word bonus 
*	at index twelve can be achieved.

	score = (lt(size(word),5) cost(word), 2 * cost(word))
	
*	See if get bonus for playing seven tiles.

	score = eq(size(word),7) score + 35

*	Add the first word found to set *highest* and *lowest*

	eq(highest,0)					:s(start.new)

	lt(score,highest)				:s(start.word)
	gt(score,highest)				:s(start.new)

*	Here if current best and new move have same score.
*	Prefer the one with the lowest cost.

	lt(cost(word),lowest)				:s(start.new)

start.new

	highest = score
	lowest = cost(word)
	best = word					
							:(start.word)
start.done

*	Start word at position 8, unless word size greater than 
*	five, in which case move it to the left, but making sure 
*	move still covers double-word cell at position twelve.

	offset = (lt(size(best,5) 0, 5 - size(best)))

*	Initialize free array for move.

	free = array(size(best))
	i = 0

start.free

	free[i = i + 1] = 7 + i  + offset		:s(start.free)

	start = move(8 + offset,free,best,highest) :(return)

start.end

	define('state.restore(saved)')		:(state.restore.end)

*	Restore the state of the game from a prior save.

state.restore

	g.grid = 	saved['grid']
	g.bonus = 	saved['bonus']
	g.tileset = 	saved['tiles']
	g.players[1] = 	saved['player.1']
	g.players[2] = 	saved['player.2']
							:(return)
state.restore.end

	define('state.save()')				:(state.save.end)

*	Save the state of the game.

state.save

	state.save = table(10)
	map(state.save,'grid',copy(g.grid))
	map(state.save,'bonus',copy(g.bonus))
	map(state.save,'tiles',copy(g.tileset))
	map(state.save,'player.1',copy(g.players[1]))
	map(state.save,'player.2',copy(g.players[2]))
							:(return)
state.save.end


	define('subarray(ara,start,len)i')		:(subarray.end)

*	Like substr, but returns the sub-array of *ara* starting at 
*	element *start* and consisting of *len* elements

*SUBARRAY*
subarray

	subarray = array(len)

subarray.1

	gt(i = i + 1,len)				:s(return)
	subarray[i] = copy(ara[start + i - 1])		:(subarray.1)		

subarray.end

	define('swap(pid,n)player,tiles')		:(swap.end)

*	Swap N tiles from the first N characters in the tiles 
*	of player with id PID.  If fewer than N tiles remain,
*	set N to the size of the tileset.

*SWAP*
swap	

	player = g.players[pid]
	tiles = rack(player)
	n = gt(n,size(tiles)) size(tiles)
	n = gt(n,size(g.tiles)) size(g.tiles)
	eq(n)						:s(freturn)

swap.next

	swap = substr(g.tiles,1,n)
	g.tiles = substr(g.tiles,n + 1)  substr(tiles,1,n)
							:(return)
swap.end

	define('take(n)')				:(take.end)

*	Take N*tiles from the tileset, or taking all
*	the remaining tiles if fewer than N remain.

*TAKE*
take
	n = gt(n,size(g.tiles)) size(g.tiles)
	eq(n,0)						:s(return)
	take = order(substr(g.tiles,1,n))
	g.tiles = substr(g.tiles, n + 1)		:(return)

take.end

	define('test.perm(rack,perm,num,move,inlines)'
.		'text,lines,iline,i,p,cline')	:(test.perm.end)

*	Test if applying a permutation PERM to a rack RACK yields a valid move.
*	NUM is the line containing the move, and INLINES is a list of
*	the lines from the grid to be used.

*TEST.PERM*
test.perm

*	NOTE: THE LOOP BELOW IS THE CRITICAL INNER LOOP OF THIS PROGRAM.
*	ANY TIME SPENT SPEEDING THINGS UP ELSEWHERE WILL HAVE LITTLE EFFECT.
*	
*	For example, given a move of length 7 with a rack of 7 letters, we
*	need to account for the slightly over 5000 permutations of the letters
*	that can be used here. And note this is just for one possible move ...
*
*	Since most racks will contain duplicate, or even triplicate, instances of
*	the same letter, the table *tried* is used below. This cut the running
*	time of the program by a factor of two when first introduced.
	
	count.perm = count.perm + 1

	seen(perm)				:s(freturn)
	count.cells = count.cells + size(perm)

	g.cln = 0

	text = place(perm,rack)

	lines = copy(inlines);

*	Insert the letters from the tileset corresponding to the permutation
*	into the selected blank cells in the line.  The digit '1' selects 
*	the first tile, the digit '2' the second, and so on.  Then see if 
*	the result gives a valid line. Move to the next permutation if not.  
*	(This is a clever use of replace(), even if I do say so myself.)

	text(move) = perm;* insert permutation digits into free cells
	iline = insert(lines[num],move);* line with permutation digits entered
	checkline(place(iline,rack))			:f(freturn)

*	Move is valid on this line, so check validity on crossing lines.
*	Save the valid lines in *clines* for scoring if move proves valid.

*	We could use the clines() procedure for this, but in this loop every
*	statement counts, so in effect we build clines on the fly.
*	Since almost all permutations will result in junk, we want to 
*	detect junk as soon as possible so we can move on without wasting 
*	needless effort.

	text(move) = text

*	out(ne(g.tracing) 'Find valid first ' 
*		show.move(move) ' ' show.line(line))

	g.clines[g.cln = g.cln + 1] =  pair( id(move), insert(lines[num],move))
	i = 0

*	Check the crossing lines, constructing them as needed, to make sure the
*	move is valid.

test.perm.cross

*	out('find cross ')

*	If next assignment fails, we have finished checking the 
*	permutation without finding a valid move, and so return failure.

	p = free(move)[i = i + 1]			:f(return)
	cline = cline(lines,move,p,substr(rack,substr(perm,i,1),1))
	checkline(line(cline))				:f(freturn)

*	out(ne(g.tracing) 'Find valid checkline ' line(cline))

	text(move) = place(text(move),ucase(rack))

*	out(ne(g.tracing) 'Find text ' text(move))

	g.clines[g.cln = g.cln + 1] = cline		:(test.perm.cross)

test.perm.end

	define('thousands(s)n')				:(thousands.end)

*	Format S with comma's every three digits from right.

*THOUSANDS*
thousands	

	n = size(s)
	thousands = le(n,3) s				:s(return)
	thousands = thousands(substr(s,1,n - 3)) ',' substr(s, n - 2, 3) :(return)

thousands.end

	define('traceoff()')				:(traceoff.end)

*	Initiate tracing.

*TRACEOFF*
traceoff
	&ftrace = &trace = 

	g.scoring = g.tracing = 0
	out('stop TRACING ')

traceoff.end

	define('traceon()')				:(traceon.end)

*	Initiate tracing.

*TRACEON*
traceon

	out('start TRACING')
*	&ftrace = &trace = 1500000
	g.scoring = g.tracing = 1
							:(return)
traceon.end

	define('turn(pid,mode)manual,state,points.player,'
.			'points.fribble') 	:(turn.end)

*	Play turn for player with id PID in a game with mode MODE.

*	Steps are

*	1.	Replenish tiles before making move if managing tiles by hand.

*	2.	Find or enter the move to be played.

*	3.	Make the move by updating the data structures, scores, etc.

*	4.	If not managing tiles by hand, use fribble to update the rack.

*TURN*
turn

	player = g.players[pid]

	ne(f.trace) out('enter turn pid=' pid ' ' show.player(pid))

	eq(g.trace,g.turn) traceon()

*	Replenish tiles before making the move. 

*	This is needed when playing in team mode. 
*	need to enter your tiles from the wwf board.

	eq(f.mode,f.mode.auto)				:s(turn.auto)
	ne(kind(player),player.kind.team)		:s(turn.move)

	rack(player) = replenish(pid)
	ne(f.trace) out('rack pid=' pid '   now ' rack(player))
	ne(f.trace) out(show.player(pid))

turn.move

	log( 'rack ' pid ' "' rack(player) '"')

*	2.	Find or enter the move to be played.

*	Here to pick the next move.
*	You need to enter the foe's move when playing as a team,
*	and your own move when playing a solo game.

	eq(f.mode,f.mode.auto)				:s(turn.auto)
	eq(kind(player),player.kind.foe)		:s(turn.manual)

*	Enable next line to get 'enhanced' mode where Fribble reports 
*	move it would have made

*	eq(kind(player),player.kind.solo)		:s(turn.solo)

	eq(kind(player),player.kind.solo)		:s(turn.manual)
	
turn.auto

*	Here to have fribble find the best move.

	ne(f.trace) out('fribble making move.')

*	ne(kind(player),player.kind.auto) out('computing move ...')

	g.move = find(pid,g.turn)			:f(turn.fail)

*	ne(f.trace) out('auto move ' show.move(g.move))

*	ne(kind(player),player.kind.auto) out('... computed')
							:(turn.make)

turn.manual

*	Here to enter the move manually

	ne(f.trace) out('getting move manually')

	manual = manual()
	ident(datatype(manual),'move')			:f(turn.manual.nomove)
	g.move = manual					:(turn.validate)

turn.manual.nomove

*	Here if manual didn't return a move, so branch 
*	to the corresponding handler.

	manual 'error'					:s(turn.manual.error)
							:($('turn.' move))
turn.solo
*HERE*

*	Here to when playing solo. Get the player's move, then
*	find what fribble would have played, and show the difference.

turn.solo.in

	ne(f.trace) out('getting move manually')

	manual = manual()
	ident(datatype(manual),'move')			:f(turn.solo.nomove)
	out('solo player move ' show.move(manual))
	g.move = manual				:(turn.solo.fribble.havemove)

turn.solo.nomove

*	Here if manual didn't return a move, so branch 
*	to the corresponding handler.

	manual 'error'				:s(turn.manual.error)
	target = $('turn.' manual)
	out('solo no move target datatype ' datatype(target) ' ' target)
	out('turn.solo.nomove ' manual)
						:($('turn.' manual))
turn.solo.move

	eq(g.turn,1) valid.start(manual)	:s(turn.solo.fribble.havemove)
	ne(g.turn,1) valid(manual)		:s(turn.solo.fribble.havemove)
	
	out('invalid move - try again')			:(turn.solo.in)

turn.solo.fribble.havemove

	g.move = manual

*	G.move is the player's valid move.
*	Save the state, find the move fribble would have made, 
*	and report the results to the player.

	state = state.save()	
	move = find(pid, rack)			:s(turn.solo.fribble.move)

*	Here if fribble couldn't find a valid move.

	out('Hmmm ... Fribble unable to find a valid move.')	:(turn.validate)

turn.solo.fribble.move
 
	points.fribble = scoremove(move)
	points.player = scoremove(g.move)

	out('You played the move ' show.move(g.move) ' for ' 
.		number(points.player) ' points.')

	out('Fribble would have played ' show.move(move) ' for ' 
.		number(points(move)) ' points.')

	show.play(makemove(pid,move));* display fribble's move.

	lt(points.player,points.fribble)
.		out('Fribble would have scored ' (points(move) - points.player)
.		 ' more points.')

	eq(points.player,points.fribble)
.		out('Fribble and you would have scored the same - '
.		'Congratulations!')

	gt(points.player,points.fribble)
.		out('You score more (' (points.player - points.fribble)
.		 		    ') points than Fribble.')

	gt(points.player,points.fribble)	out('You are a genius!')
	
*	Put things back where they were.
	
	state.restore(state)

turn.validate

	ne(f.trace) out('validating move ' show.move(g.move))

*	See if move is valid.

	eq(g.turn,1) valid.start(g.move)		:s(turn.make)
	ne(g.turn,1) valid(g.move)			:s(turn.make)

	out('invalid move - try again')			:(turn.manual)

turn.manual.error

	out('eval error ' &errtext)			:(turn.manual)

turn.make
*	3.	Make the move by updating the data structures, scores, etc.

	points(g.move) = scoremove(g.move)

	log.move(pid,g.move)	

*	ne(f.trace) out('making move ' show.move(g.move))

	show.play(makemove(pid,g.move))

turn.replenish

*	4.	Replenish the tiles if managing the tiles automatically.


*	Replenish tiles if necessary. If doing this manually, don't do it here,
*	but at start of next turn.

	eq(g.tilemanager)				:s(turn.done)
*	out('DAVE')
*	out('replenishing pid= ' pid ' ' show.player(player))
	ne(f.trace) out('replenishing pid= ' pid )


*	Here to update rack when fribble is managing the tiles.
*	Remove tiles played on move and then replenish the rack.

	ne(f.trace) out('updating rack pid=' pid)
	rack(player) = less(rack(player), lcase(text(g.move)))
	rack(player) = replenish(pid)			
	ne(f.trace) out('rack pid=' pid '   now ' rack(player))	
							:(turn.done)

turn.pass

	log( 'pass ' pid)
							:(turn.done)
turn.resign

	out('player ' pid ' resigns.')
	log('resign ' pid)				:(turn.done)

turn.swap
	
*	Here in case foe swapped tiles. Report it as such and move on.


	log('swap ' pid)

	out('foe swapped tiles')			:(turn.done)

turn.done

	ne(f.trace) out('turn done')
							:(return)
turn.fail

	out('turn failed - unable to find move.')	:(freturn)

turn.end 

	define('valid.start(move)free,num,text')	:(valid.start.end)

*	Test if MOVE, a suggested starting move, is valid.

*VALID.START*
valid.start

*	If this is a starting move, check that it covers column 8 in row 8, 
*	and is a word in the dictionary.

	free = free(move) 
	text = text(move)

	num = convert(free,'integer')			:f(valid.start.free)

	out('valid.start.start num=' num)

	lt(num,9 - size(text))				:s(valid.start.error)
	gt(num,7 + size(text))				:s(valid.start.error)

valid.start.free

*	Here if free is list of cells. Check that '8' is one of them.

	out('valid.start.start.free ' show.move(valid.start))
	out('valid.start.start.free ' free(valid.start))

	free break('8')					:f(valid.start.error)
	checkword(text(move))				:s(return)f(freturn)

valid.start.start.error

	out('starting move must use column 8.')		:(freturn)

valid.start.end


	define('ucase(s)')				:(ucase.end)

*	Convert argument to upper case.

*UCASE*
ucase

	ucase = replace(s,&lcase,&ucase)		:(return)

ucase.end
	
	define('unpack(line),c,i')			:(unpack.end)

*	Unpack the characters of line LINE to an array of characters.

*UNPACK*
unpack

	unpack = array(size(line))

unpack.ch

	c = substr(line,i = i + 1,1)			:f(return)
	unpack[i] = c					:(unpack.ch)

unpack.end

	define('valid(move)num,i,pos')			:(valid.end)

*	Test if MOVE is a valid move. 

*VALID*
valid
valid.move

*	At least one cell to be occupied by this move must be 
*	adjacent to a used cell.
	
	num = id(move)

valid.u

	gt(i = i + 1,size(text(move)))			:s(freturn)
	pos = free(move)[i]
	adjacent(row(num,pos),column(num,pos)) 		:f(valid.u)s(valid.used)

*	Here if no adjacent cell found, fail.  *
							:(freturn)
valid.used

*	Test that line and all its crossing lines are valid.

	clines(move);* get line and its crossing lines
	i = 0

valid.i

	gt(i = i + 1,g.cln)				:s(return)
	checkline(line(g.clines[i]))			:f(freturn)s(valid.i)

valid.end

	define('vline(g,c)')				:(vline.end)

*	Return the vertical line of grid G corresponding 
*	to column C as a string.

*VLINE*
vline

	c = +c
	vline = g[1,c] g[2,c] g[3,c] g[4,c] g[5,c] 
.		g[6,c] g[7,c] g[8,c] g[9,c] g[10,c]
.		g[11,c] g[12,c] g[13,c] g[14,c] g[15,c]
							:(return)
vline.end

	define('words(s)n,w,pos,i,sp')			:(words.end)

*	Return array of the words in S, fail if no words.
*	The first entry for an array element is the starting index;
*	the second is the word itself.

*WORDS*
words

*	Make sure we'll have blank to start off so initial span() 
*	matches something, and also one at end to break to 
*	in case last word extends to end of line.

	words = table(n)
	s = ' ' s ' '
	pos = 0	
words.sp

*	Account for blank(s) between words.

	s span(' ') . sp =

	ident(s)					:s(words.done)

	pos = pos + size(sp);* point to start of next word

words.w

*	While it is customary to absorb the blank in the 
*	usage below, we leave it in so there will be at least 
*	one blank to satisfy span() when loop back to words.sp

	s break(' ') . w  = 	 			:f(words.done)
	words[pos] = w					
	pos = pos + size(w)				:(words.sp)

words.done

	words = convert(words,'array')			:(return)

words.end

