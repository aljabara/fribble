* Copyright (c) 2017 dave shields

*	Global Variables

*	Global variables have names starting with 'g.' Their initial value is set in the
*	procedure *init()* and its subfunctions.

*	A play is a sequence of one or more cells, represented as an array.  The cells are ordered
*	from left to right for a horizontal play, top to bottom for a vertical play.

*	g.board, array('15,15'), the playing board. Each entry is blank (' ') for unplayed cell, or is the letter played.

*	g.bonus.lines,array(30), is the array of lines corresponding to g.bonus

*	g.dict, array(15), is an array of hashtables  that are non-null for words in the dictionary.

*	g.found counts number of valid moves that were found.

*	g.log is set to append a copy of standard output to
*	log file 'fribble.log'.

	g.log = 1

*	g.maxmoves, maximum number of moves.

	g.maxmoves = 60
	
*	g.lines, array(30), is the array of the lines defined by the rows and columns in the board. 

*	A move is a sequence of empty cells in a row or column such that at least one cell in the sequence 
*	is adjacent to an already occupied cell:
*		*id*	 gives the line number, in the range 1..30;
*		*count*	 is the number of free cells covered by this move;
*		*free*	 is an array of dimension *count* giving the empty cells to be filled by this move;
*		*text*	 is the string of tiles of the move; and
*		*points* is the number of points won by playing this move.

*	A player is represented by

	data('player(pid,name,fribble,rack,total,thirty,highest)')

*	where
*		*pid*		is an integer identifier, either 1 or 2. Player 1 makes the first move
*		*name* 		is the player's name
*		*fribble* 	if not null, requests that fribble make the moves
*		*rack* 		is the player's rack
*		*total*		is the player's current score
*		*thirty* 	is number of moves with scores of 30 or more points.
*		*highest* 	is the player's highest move score.

*	There are three kinds of players.

	player.frible = 1	;* fribble playing on its own
	player.self   = 2	;* you playing against fribble, managed by fribble.
	player.team   = 3	;* you are fribble are playing as a team against another player.

*	g.one and g.two are the players. 

	g.one = player(1)
	g.two = player(2)

	g.players = array(2)	
	g.players[1] = g.one
	g.players[2] = g.two

*	g.bonus,array(15,15) gives the bonus values for the squares on the board:
*		1	for the value of the letter itself,
*		2	for double letter,
*		3	for triple letter, 
*		4	for double word, and
*		5	for triple word.

	data('move(id,count,free,text,points,perm,fid)')

*	A paired line consists of a line number and an associated line. It is used when it is necessary
*	to pass a line of text to a procedure along with line number from where it was derived.

		data('pair(num, line)')

*	g.turn, the number of the current turn
*	g.lastmove, the turn when the last move was made.
*	g.turnlimit, most allowed number of turns if non-zero.

	g.turn = g.lastmove = g.turnlimit = 0

*	g.permutations, a table of the permutations of n=1..7 things taken 1..k at a time.
*	For example, g.perms['7?3'] is permutations of 1..7 taken 3 at a time. Each entry
*	in the table is an array giving the desired set of permutations.

*	g.permutations.count, a table giving the number of permutations of for a given *n* and *k*.

*	g.random_var is used by random() to compute the next pseudo-random value.
*	Gimpel uses integer here, but need to have real.

	g.random_var = 1

*	g.showscore is used to enable tracing of scoring by setting it to nonzero value

	g.showscore = 1
	g.showscore = 

*	g.tiles, a string containing all the characters in the initial bag of characters.

*	g.trace, if not null, begin tracing at the start of move g.trace.

	g.trace =

*	g.tracing, set nonzero when tracing initiated by *g.trace* begins.

*	g.used, array('15,15') tracks the cells in the board that have been used in a move
*	A move made after the first move must have at least tile played in a square adjacent to
*	one that has been used in a prior move.

*	g.used.lines, array(30), is the array of lines defined by the rows and columns of the used grid.

*	g.value, a map from characters to the tile value of that character.

	g.clines = array(8);* for line with move and its crossing lines.
	g.cln = 0;* number of entries in clines.

	g.highest = 0;* highest score
	g.lowest = 0;* lowest cost

*	The variables for row and column numbers are used
*	for the input of moves. They map name to line number.

	r01 = 1; r02 =  2; r03 =  3; r04 =  4; r05 =  5; r06 =  6; r07 =  7; r08 = 8; r09 = 9;
	r1 = 1; r2 =  2; r3 =  3; r4 =  4; r5 =  5; r6 =  6; r7 =  7; r8 = 8; r9 = 9;
	r10 = 10; r11 = 11; r12 = 12; r13 = 13; r14 = 14; r15 = 15;

	c01 = 16; c02 = 17; c03 = 18; c04 = 19; c05 = 20; c06 = 21; c07 = 22; c08 = 23; c09 = 24; 
	c1 = 16; c2 = 17; c3 = 18; c4 = 19; c5 = 20; c6 = 21; c7 = 22; c8 = 23; c9 = 24; 
	c10 = 25; c11 = 26; c12 = 27; c13 = 28; c14 = 29; c15 = 30
	
*	Utility functions

	define('init(dictfile,skip,external)c,i,j,s,t')		:(init.end)

*	Initialize global variables.

*INIT*
init

	init.main(dictfile,skip)

	ident(g.log)					:s(init.clean)

*	Open log file for append.

	output(.logfile,2,'fribble.log[-a]')		:s(init.clean)
	out('unable to open log file')

init.clean

*	Free up code for initializers now that no longer needed.


	init.bonus = init.main = init.dict = init.tileset = init.value = 
			
							:(return)
init.end

	define('init.main(dictfile,skip)c,i,j,s,t')	:(init.main.end)

*	Initialize global variables.

init.main

	g.dict = array(15)
	g.board = array('15,15',' ')
	g.lines = lines(g.board)

	g.used = array('15,15',' ')
	g.used.lines = lines(g.used)

	init.bonus()

*	Initialze permutation map.

	init.perm('perm.txt')

	init.tileset()

	shuffle();* shuffle the tileset

	init.value()

	init.dict(dictfile,skip)
							:(return)
init.main.end

	define('init.bonus()s,row,col,b,c')		:(init.bonus.end)

*	Initialize the bonus squares for the 15x15 grid: 
*		1 for the value of the letter,
*		2 for double letter,
*		3 for triple letter,
*		4 for double word, and
*		5 for triple word.

*INIT.BONUS*
init.bonus
	g.bonus = array('15,15','1')
	s = 	'5 0104 3 0107 3 0109 5 0112 2 0203 4 0206 4 0210 2 0213 '
.		'2 0302 2 0305 2 0311 2 0314 5 0401 3 0404 4 0408 3 0412 4 0415 '
.		'2 0503 2 0507 2 0509 2 0513 4 0602 3 0606 3 0610 4 0614 '
.		'3 0701 2 0705 2 0711 3 0715 4 0804 4 0812 3 0901 2 0905 2 0911 3 0915 '
.		'4 1002 3 1006 3 1010 4 1014 2 1103 2 1107 2 1109 2 1113 '
.		'5 1201 3 1204 4 1208 3 1212 5 1215 2 1302 2 1305 2 1311 2 1314 '
.		'5 1403 4 1406 4 1410 2 1413 5 1504 3 1507 3 1509 5 1512 '

init.bonus.1
	s len(1) . b ' ' len(2) . row len(2) . col ' ' =	:f(init.bonus.next)
	g.bonus[+row,+col] = +b					:(init.bonus.1)
init.bonus.next
	g.bonus.lines = lines(g.bonus)				:(return)
init.bonus.end

	define('init.dict(filename,skip)file,i,n,w,s')		:(init.dict.end)

*	Initialize the global dictionary g.dict.

*INIT.DICT*
init.dict

*	Set hash table sizes according to output of /study/gendict.sbl

	s  = '1 100 1000 4000 9000 15000 23000 28000 25000 20000 15000 11000 8000 5000 3000 '
init.dict.tbl
	gt(i = i + 1,15)				:s(init.dict.tbl.1)
	s break(' ') . n ' ' = 
	g.dict[i] = table(+n)				:(init.dict.tbl)
init.dict.tbl.1
	i = 0


*	Read in a dictionary from a specified file, with one word per line. If 'skip'
*	is non-zero then that number of lines are skipped before adding the next word.
*	This assists the use of smaller dictionaries for testing.

	filename = ident(filename) 'dict.txt'
	skip = (ident(skip) +1, +skip)

	input(.file,3,filename)				:s(init.dict.in)
	out('unable to open input file ' filename)	:(freturn)
	n = 0
init.dict.in
	w = file					:f(init.dict.done)
	gt(size(w),15)					:s(init.dict.in)

*	Process plural words, indicated by 'S' at end

	differ(substr(w,size(w),1),'S')			:s(init.dict.w)
	w = substr(w,1,size(w) - 1)
	g.dict[size(w)][w] = +1
	g.dict[size(w) + 1][w 's'] = +1			:(init.dict.in)
init.dict.w
	g.dict[size(w)][w] = +1
	eq(skip,1)					:s(init.dict.in)
*	here want to skip over entries in the dictionary (for testing)
	n = skip
init.dict.skip
	w = file					:f(init.dict.done)
	gt(n = n - 1,0)					:s(init.dict.skip)f(init.dict.in)
init.dict.done
	endfile(3)					:(return)
init.dict.end

	define('init.perm(filename)line,ifile,n,k,lines,nread')	:(init.perm.end)

*	Initialize the list of possible permutations from a file.

*INIT.PERM*
init.perm

	g.permutations = table(7)
	g.permutations.count = table(100)
	input(.ifile,4, filename)			:s(init.perm.next)
	out('unable to open permutation file ' filename) 	:(freturn)

init.perm.next
	line = ifile					:f(init.perm.done)
	line break('?') . n '?' break(' ') . k ' ' rem . count :f(init.perm.err)
	g.permutations.count[n '?' k] = count
	ara = array(count)
	ai = 0
init.perm.array
	ara[ai = ai + 1] = ifile			:s(init.perm.array)
	g.permutations[n '?' k] = ara			:(init.perm.next)
init.perm.done
	endfile(4)					:(return)
init.perm.err
	out('init.perm error, line ' lines '  '  line) :(freturn)
init.perm.end

	define('init.tileset()ch,n,s')			:(init.tileset.end)

* 	Initialize set of tiles, ignoring the 'blank' tiles for now.
*	Initialize value map from letters to value, ignoring ' ' for now

*INIT.TILESET*
init.tileset
	s = 'a 9 b 2 c 2 d 5 e 13 f 2 g 3 h 4 i 8 j 1 k 1 l 4 m 2 n 5 o 8 p 2 q 1 r 6 s 5 t 7 u 4 v 2 w 2 x 1 y 2 z 1 '
	g.tiles =
init.tileset.ch
	s break(' ') . ch ' ' break(' ') . n ' ' =	:f(return)
	g.tiles = g.tiles dupl(ch,n)			:(init.tileset.ch)
init.tileset.end

	define('init.value()s,c')			:(init.value.end)
*INIT.VALUE*
init.value
	g.value = table(52)
	s = &lcase &ucase

*	Assume value of a tile is one, and correct that below.

init.value.next
*	assume value is 1
	s len(1) . c =					:f(init.value.letters)
	g.value[c] = +1					:(init.value.next)

init.value.letters
	s = 
.	'b 4 c 4 d 2 f 4 g 3 h 3 j 10 k 5 l 2 m 4 n 2 p 4 q 10 u 2 v 5 w 4 x 8 y 3 z 10 '
.	'B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 '
init.value.update
*	update assumptions for letters with value greater than one.
	s break(' ') . c ' ' break(' ') . v ' ' =	:f(return)
	g.value[c] = +v					:(init.value.update)
init.value.end

	define('adjacent(r,c)')				:(adjacent.end)

*	Test if the cell in row *r* and column *c* is adjacent to one that has been used.

*ADJACENT*
adjacent
	gt(r,1) differ(g.used[r - 1,c],' ')			:s(return) ;* cell to the north
	lt(c,15) differ(g.used[r,c + 1],' ')			:s(return) ;* cell to the east
	gt(c,1) differ(g.used[r,c - 1],' ')			:s(return) ;* cell to the west
	lt(r,15) differ(g.used[r + 1,c],' ')			:s(return) ;* cell to the south
							:(freturn)
adjacent.end

	define('append(str,w,ch)')				:(append.end)

*	Append word *w* to string *str*, prefixing with *ch* if *str* is not null, using space if *ch* is null.

*APPEND*
append
	append = (ident(str) w, str (ident(ch) ' ' , ch) w)	:(return)
append.end

	define('bonus.lines()i')			:(bonus.lines.end)

*BONUS.LINES*
bonus.lines
	bonus.lines = array(30)
bonus.lines.next
	gt(i = i + 1,15)				:s(return)
	bonus.lines[i] = hline(g.bonus,i)
	bonus.lines[i + 15] = vline(g.bonus,i)		:(bonus.lines.next)
bonus.lines.end

	define('checkline(line)word')			:(checkline.end)

*	Test if all the words in a line are in the dictionary.

*CHECKLINE*
checkline
	count.checkline = count.checkline + 1
	line span(' ') =
	empty(line)					:s(return)
	line = line ' ';* to simplify breaking out words.
checkline.1
	line span(' ') =
	line break(' ')  . word ' ' =			:f(return);* if line exhausted
	eq(size(word),1)				:s(checkline.1)
	checkword(word)					:f(freturn)s(checkline.1)
checkline.end
	checkwordn = 0

	define('checkword(word)')			:(checkword.end)

*	Test if a word is in the dictionary.

*CHECKWORD*
checkword
	count.checkword = count.checkword + 1

*	Accept words of a single character since they can occur in crossing lines.

	eq(size(word),1)				:s(return)

	word = lcase(word);* in case upper case letters have wrongly crept it.
	differ(g.dict[size(word)][word])		:f(freturn)s(return)
checkword.end

	define('cline(lines,move,p,ch)c,line')		:(cline.end)

*	Return crossing line of p-th cell in move *move*. *ch* gives tile to be played.

*CLINE*
cline
	count.cline = count.cline + 1

*	Cross line of row r, position p, is column p. Cross line of column c, position p, is row p.

	c = (le(id(move),15) p + 15, p);* cross line id
	line = lines[c];* cross line
	p = (le(id(move),15) id(move), id(move) - 15);* position to insert character
	line = substr(line,1,p - 1) ucase(ch) substr(line,p + 1)
	cline = pair(c,line)				:(return)
cline.end

	define('clines(move,upper)p,c,ch,line')		:(clines.end)

*	Update g.clines to contain the line for move *move* and all
*	its crossing lines. Express the letters of the move in upper case
*	(for later scoring) if *upper* is not null.

*CLINES*
clines
	line = g.lines[id(move)]
	p = free(move)[1]

*	First entry is for the line containing the move

	g.cln = 1
	g.clines[1] = pair(id(move), insert(g.lines[id(move)],move,1))
	i = 1

*	On each pass through the loop, we compute the crossing line of the
*	i-th character in the move.
*

clines.i
	p = free(move)[i]

*	Cross line of row r, position p,  is column p. Cross line of column c, position p, is row p.

	c = (le(id(move),15) p + 15, p);* cross line
	line = g.lines[c];* cross line
	p = (le(id(move),15) id(move), id(move) - 15);* position to insert character
	ch = substr(text(move),i,1)
	line = (gt(p,1) substr(line,1,p - 1),'')  (differ(upper) ucase(ch), ch) (lt(p,15) substr(line,p + 1),'')
	g.clines[g.cln = g.cln + 1] = pair(c, (ident(upper) lcase(line), line))
	le(i = i + 1, count(move))			:s(clines.i)f(return)
clines.end

	define('column(num,pos)')			:(column.end)

*	Returns column corresponding to position *pos* in line *num*.

*COLUMN*
column
	column = ((gt(num,15) num - 15, pos))		:(return)
column.end

	define('cost(text)')				:(cost.end)

*	Return the cost of *text*, defined as the sum of the values of the tiles in *text*.

*COST*
cost
	text len(1) . ch =				:f(return)
	cost = cost + g.value[ch]			:(cost)
cost.end

	define('counter(text,count)')			:(counter.end)

*	Output the descriptive text *text* and value *n* of a counter.

*COUNTER*
counter
	out(lpad(text,32) lpad(count,10))		:(return)
counter.end

	define('counters()')				:(counters.end)

*	Output the collected counter metrics.

*COUNTERS*
counters
	out()
	out('Performance metrics:')
	counter('placements found by scan'	, count.scanned	)
	counter('permutations examined'		, count.perm	)
	counter('cells examined'		, count.cells	)
	counter('potential moves found'		, count.moves 	)
	counter('lines checked'			, count.checkline)
	counter('words checked'			, count.checkword)
	counter('clines lines checked'		, count.cline	)
	counter('cross lines checked'		, count.cross	)
	counter('valid moves found'		, count.valid	)
	counter('inserts'			, count.insert)
	counter('contig inserts'		, count.insert.contig)
	counter('split inserts'			, count.insert.split)
							:(return)
counters.end

	define('empty(line)')				:(empty.end)

*	Test if line is empty (null or all blanks).

*EMPTY*
empty

*	In most cases, the first character in line is not null.

	differ(substr(line,1,1),' ')			:s(freturn)
	line span(' ') =
	ident(line)					:s(return)f(freturn)
empty.end
	
	define('endgame()')				:(endgame.end)
	
*	Summarize results at end of game.

*ENDGAME*
endgame
	out('Player ' name(g.one) ' scored ' total(g.one) ' points. Highest move scored ' highest(g.one) ' points.')
	out('Player ' name(g.two) ' scored ' total(g.two) ' points. Highest move scored ' highest(g.two) ' points.')
	out(gt(thirty(g.one)) 'Player ' name(g.one) ' had ' thirty(g.one) ' moves of 30 or more points.')
	out(gt(thirty(g.two)) 'Player ' name(g.two) ' had ' thirty(g.two) ' moves of 30 or more points.')
	counters()
							:(return)
endgame.end

	define('find(pid)player,rack,num,lines,inlines,line,moves,mi,m,perms,perm,permi,fline,tline,iline,cline,highest,lowest,i,p,score,move,tried')	:(find.end)

*	Find all the valid moves and their scores given the current board and the indicated rack.
*	For each line, find the set of all possible moves for that line. 
*	Then for each move check the options (permutations) that can be played from the tileset.
*	For each specific permutation see if the resulting line contains only valid words. 
*	If not, go on to the next permutation.
*	If true, then see if all the lines affected by the move contain only valid words.
*	If not, go on to the next permutation.
*	If so, then add up the scores of all new words created by the move.

*	From amongst the valid moves determine the best move as follows.
*	If two moves have different scores, prefer the one with the higher score.

*	The 'cost' of a move is the sum of the values of the tiles in the move; so 
*	want to keep cost low to save higher value tiles for later moves.
*	If two moves have the same score and different costs, prefer the move with the lower cose.
*	If two moves have the same score and cost, while one uses the letter 's' and the other doesn't, prefer
*	the move that doesn't use the letter 's'.

*	Find returns the best move as defined above, or null if no valid move is found.

*FIND*
find
*	
	player = g.players[pid]
	rack = rack(player)
	lines = copy(g.lines)
	inlines = copy(lines)
	g.highest = 0;* highest score this turn
	g.lowest = 0;* lowest cost this turn
	num = 0
find.line
	gt(num = num + 1,30)				:s(find.done)
	line = lines[num]
*	out(ne(g.tracing) 'Find.line ' lpad(lineid(num),3) ' ' show.line(line))
	moves = scan(pair(num,line),rack)		:f(find.line)
	mi = 0
find.move
	count.moves = count.moves + 1
	move = moves[mi = mi + 1,2]			:f(find.line)
*	out(ne(g.tracing) 'Find.move mi ' mi ' ' show.move(move,'find'))
	points(move) = 
	permi = 0

*	The rack will almost always have at least two, and sometimes three, identical letters.
*	Use tried to track texts that have been tried, to avoid duplicate testing for validity of
*	the same text.
	
	tried = table(100)

	perms = g.permutations[text(move)]		:s(find.perm)

*	Something must be wrong with the requested permutation

	out('fatal permutation request ' text(move)) :(end)

*	NOTE: THE LOOP BELOW IS THE CRITICAL INNER LOOP OF THIS PROGRAM.
*	ANY TIME SPENT SPEEDING THINGS UP ELSEWHERE WILL HAVE LITTLE EFFECT.
*	
*	For example, given a move of length 7 with a rack of 7 letters, we
*	need to account for the slightly over 5000 permutations of the letters
*	that can be used here. And note this is just for one possible move ...
*
*	Since most racks will contain duplicate, or even triplicate, instances of
*	the same letter, the table *tried* is used below. This cut the running
*	time of the program by a factor of two when first introduced.
	
find.perm

	score = g.cln = 0
	perm = perms[permi = permi + 1]			:f(find.move)
	ident(perm)					:s(find.move)

	text = place(perm,rack)

*	See if we have already tested this text.

	differ(tried[text])				:s(find.perm)
	tried[text] = 1;* note that we have reviewed this text

	count.perm = count.perm + 1
	count.cells = count.cells + size(perm)

	lines = copy(inlines);* restore lines to condition on entry

*	Insert the letters from the tileset corresponding to the permutation into the selected blank cells in the line. 
*	The digit '1' selects the first tile, the digit '2' the second, and so on.
*	Then see if the result gives a valid line. Move to the next permutation if not.
*	(This is a clever use of replace(), even if I do say so myself.)

	text(move) = perm;* insert permutation digits into free cells
	iline = insert(lines[num],move);* line with permutation digits entered
	checkline(place(iline,rack))			:f(find.perm)
	perm(move) = perm

*	Move is valid on this line, so check validity on crossing lines.
*	Save the valid lines in *clines* for scoring if move proves valid.

*	We could use the clines() procedure for this, but in this loop every
*	statement counts, so in effect we build clines on the fly.
*	Since almost all permutations will result in junk, we want to detect
*	junk as soon as possible so we can move on without wasting needless effort.

	text(move) = text
*	out(ne(g.tracing) 'Find valid first ' show.move(move) ' ' show.line(line))
	g.clines[g.cln = g.cln + 1] =  pair( id(move), insert(lines[num],move))
	i = 0

*	Check the crossing lines, constructing them as needed,  to make sure they are valid.

find.cross
*	out('find cross ')
	count.cross = count.cross + 1
	p = free(move)[i = i + 1]			:f(find.cross.done)
	cline = cline(lines,move,p,substr(rack,substr(perm,i,1),1))

	checkline(line(cline))				:f(find.perm)

*	out(ne(g.tracing) 'Find valid checkline ' line(cline))

	text(move) = place(text(move),ucase(rack))
*	out(ne(g.tracing) 'Find text ' text(move))

	g.clines[g.cln = g.cln + 1] = cline			:(find.cross)
	
find.cross.done

*	out(ne(g.tracing) 'Find valid move ' show.move(move) ' in ' show.pair(pair(num,line)))

*	Score the line by summing the scores of the lines saved in clines.
	
*	out(ne(g.tracing) 'valid move :' line '  move '  id(move) ' ' count(move) '  '
*.		free(move)[1] '...' free(move)[count(move)] ' ' text(move))
 
	count.valid = count.valid + 1
	move = copy(move)
*	out(ne(g.tracing) 'Find cross ' show.move(move) '  text=' text(move))
*	ne(g.tracing) show.move(move)
*	ne(g.tracing) show.play(move)
*	out(ne(g.tracing) 'Find calling scoremove')
	points(move) = +scoremove(move)	

*	There is bonus of 35 points for playing all the tiles.

	points(move)  = eq(count(move),7) points(move) + 35;
	g.found = g.found + 1
	g.cln = 0;* reset for next permutation
	find = isbest(move) copy(move)			:(find.perm)
find.done
	ident(find)					:s(find.fail)
							:(return)	
find.fail

*	out('find failed ')

*	If *find* is still null, then no move was found, so try to swap three tiles.
*	In either event, take the failure return.
	
	output = ident(find) 'find FAILED, no move found.'

	find = ident(find) order(swap(player,3))
							:(freturn)
find.end
	

	define('getrack(pid,move)confirm')		:(getrack.end)

*	Return rack for player with id *pid* after making move.
*	Get rack from input if *p* is null

*GETRACK*
getrack
	p = g.players[pid]
	ident(p)					:s(getrack.input)

*	Update rack.

	rack(p) = less(rack(p), lcase(text(move))) take(size(text(move))) 
*	Here if can't take any new tiles, so fail for now.

*	Shuffle the tiles so the tile set changes according to the tiles played.
* Not for now, maintain repeatability
*	shuffle()
*	out('shuffled')
							:(return)
getrack.input
	getrack =
	out('Enter rack:')
	getrack = input					:f(end)
	differ(getrack)					:s(getrack.confirm)
	out('no input, retry')				:s(getrack.input)
getrack.confirm
	out("rack now <" getrack ">  Is this correct (y or just ENTER to confirm)?")
	confirm = input
	ident(confirm)					:s(return)
	differ(confirm,'y')				:s(getrack.input)
getrack.end
	

	define('grid(lines,start)i,r,c,line')		:(grid.end)

*	Construct a grid from a sequence of lines beginning at index *start*,
*	(1..15 for rows, 16..30 for columns.

*GRID*
grid
	grid = array('15,15',' ')
	start = ident(start) +1
	start = (le(start,15) 1, 16)
	gt(start,15)					:s(grid.col)

*	Here to build grid from the rows.

	r = 0

grid.nextrow
	gt(r = r + 1,15)				:s(grid.done)
	line = lines[r]					:f(grid.3)
	i = 0
grid.r
*	out('grid r ' r '  ' i + 1 ' ' substr(line,i + 1,1))
	grid[r,i = i + 1] = substr(line,i,1)		:s(grid.r)f(grid.nextrow)

grid.col

*	Here to build grid from the columns.

	c = 14
grid.nextcol
	gt(c = c + 1,30)				:s(grid.done)
	line = lines[c]
	i = 0
grid.c
	grid[i = i + 1,c] = substr(line,i,1)		:s(grid.c)f(grid.nextcol)
grid.done						:(return)
grid.end

	define('hline(g,r)')				:(hline.end)

*	Return the horizontal line of a grid *g* corresponding to row *r* as a string.

*HLINE*
hline
	r = +r
	hline = g[r,1] g[r,2] g[r,3] g[r,4] g[r,5] 
.		g[r,6] g[r,7] g[r,8] g[r,9] g[r,10]
.		g[r,11] g[r,12] g[r,13] g[r,14] g[r,15]
							:(return)
hline.end


	define('insert(line,move,upper)c,f,i,text')		:(insert.end)

*	Insert the text of a move into its free list of empty cells in the line of the move.
*	Express the text in uppre case if *upper* is not null.

*INSERT*
insert
	count.insert = count.insert + 1
	text = (differ(upper) ucase(text(move)), text(move))
	f = free(move)
	c = count(move)
	ne(f[c] - f[1], c - 1)			:s(insert.chars)

*	Here if cells are contiguous. Insert text after part before it, and before part after it.

	count.insert.contig = count.insert.contig + 1

	insert = substr(line, 1, f[1] - 1) text substr(line, f[c] + 1)
	out(ne(size(line),15) 'insert failure ' line)		:s(end)
							:(return)
insert.chars

*	Here if cells not contiguous. Unpack the line, insert the move text, and pack it back up.

	count.insert.split = count.insert.split + 1

	insert = unpack(line)
insert.ch
	gt(i = i + 1,count(move))			:s(insert.done)
	insert[free(move)[i]] = substr(text,i,1)	:(insert.ch)
insert.done
	insert = pack(insert)				:(return)
insert.end

	define('isbest(move)')			:(isbest.end)

*	Test the score of a move to see if it the best yet seen in a turn.

*ISBERT*
isbest
	out(ne(f.showscore) 'Find points(move) ' points(move) '  highest=' g.highest ' lowest=' g.lowest)

	lt(points(move),g.highest)			:s(freturn)
	gt(points(move),g.highest)			:s(isbest.new)

*	Here if points equal, look for lower cost

	lt(cost(text(move)),g.lowest)			:s(isbest.new)
	gt(cost(text(move)),g.lowest)			:s(freturn)

*	Here if same points and cost, see if one uses 's' and the other doesn't.
*	Continue search if current best doesn't use 's'.

	text(find) ? break('s')				:f(freturn)

*	Here if current best uses an 's'. Continue if new move also uses 's'.

	text(move) ? break('s')				:s(freturn)

isbest.new

*	Here to add the new best move.

	g.highest = points(move)
	g.lowest = cost(text(move))
	out(ne(g.tracing) 'find NEW BEST move ' show.move(move))
							:(return)
isbest.end

	define('lcase(s)')				:(lcase.end)

*	Convert argument to lower case.

*LCASE*
lcase
	lcase = replace(s,&ucase,&lcase)		:(return)
lcase.end
	
	define('less(str,sub)before,after')		:(less.end)

*	Less removes the first instance of each character in *sub* from *str*, 
*	where *sub* is a substring of *str*.

less
	ident(str)					:s(return)
	less = str
less.ch
	sub len(1) . ch =				:f(return)	
	less break(ch) . before  ch rem . after
	less = before after				:(less.ch)
less.end

	define('lineid(num)')				:(lineid.end)

*	Returns row or column id corresponding to line number *num*.

*LINEID*
lineid
	lineid = (le(num,15) 'r' lpad(num,2,0), 'c' lpad(num - 15,2,0)) :(return)
lineid.end

	define('lines(g)i')				:(lines.end)

*	Express the grid *g* as a sequence of lines, with the first 15 consisting of the rows
*	and the last 15 consisting of the columns.

*LINES*
lines
	lines = array(30)
lines.next

*	Make sure all entries in lines are in lower case, since we enter moves in g in upper case.

	gt(i = i + 1,15)				:s(return)
	lines[i] = lcase(hline(g,i))
	lines[i + 15] = lcase(vline(g,i))		:(lines.next)
lines.end

	define('makemove(pid,move)player,board,lines')		:(makemove.end)

*	Make a move for player with id *pid*, and return its value.

*MAKEMOVE*
makemove
	player = g.players[pid]
	makemove = move
	out(ne(g.tracing) 'Game move ' show.move(move))
	g.lastmove = g.turn
	total(player)	= total(player) + points(move)
	thirty(player)	= ge(points(move),30) thirty(player) + 1
	highest(player) = gt(points(move),highest(player)) points(move)
	playmove(move)
	out(name(player) ' played ' show.tiles(text(move)) ' starting at ' lineid(id(move)) ', position ' free(move)[1]
.	', for ' points(move) ' points.')
	out('Score is now ' name(g.one) ' ' total(g.one)
.	 ', ' name(g.two) ' ' total(g.two) ', with '  size(g.tiles) ' letters left.')

	out('B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 ')

*	Display move in grid with just this move in upper case by saving the board, playing the move with
*	the text in upper case, showing it, and then restoring the board to its saved state.

	board = copy (g.board)
	lines = copy(g.lines)
	text(move) = ucase(text(move))
	playmove(move)
	text(move) = lcase(text(move));* restore
*	show.grid(g.board)
	g.board = board
	g.lines = lines
*	show.lines(g.lines,'Lines')
*	show.grid(g.used)
	g.used.lines = lines(g.used)
*	Update lines affected by grid changes to maintain consistency.

	g.bonus.lines = lines(g.bonus)

	g.lines = lines(g.board)

*	Fold g.lines into lower case so only new moves made later will display in upper case.

	li = 0
makemove.fold						
	g.lines[li = li + 1] = lcase(g.lines[li])	:s(makemove.fold)

*	Rebuild board since lines have changed.

*	out('rebuilding board')
	g.board = grid(g.lines)				
							:(return)
makemove.end

	define('open(pair)line,spaces,c,i,oi')	:(open.end)

*	Return array containing the indexes of the open (blank) cells in line. Fails if no open cells.

*OPEN*
open
	line = line(pair)
	spaces = spaces(line)
	eq(spaces,0)					:s(freturn)
	open = array(spaces)
	i = ai = 0
open.c
	c = substr(line, i = i + 1, 1)			:f(open.done)
	differ(c,' ')					:s(open.c)
	open[oi = oi + 1] = +i				:(open.c)
open.done
	eq(g.tracing)					:s(return)
	i = 0; c = 
open.done.ch
	c = c lpad(open[i = i + 1],3)		:s(open.done.ch)
*	out(ne(g.tracing) 'Open: ' lpad(lineid(num(pair)),3) ' '  show.hex(line) '|  |' show.line(line) '| is ' c)
							:(return)
open.end

	define('order(tiles)chars,ch,c1,c2,swaps,i,v1,v2')	:(order.end)

*	Sort the tiles in *tiles* according to their value, with least valuable first.
*	Though 's' has a nominal value of 1, its actual value is greater, since almost
*	a third of the words in the dictionary are plurals. Give 's' a value of 5 for
*	the purpose of the sort.

*ORDER*
order
	order = le(size(tiles),2) tiles			:s(return)
	chars = unpack(tiles)
							:(order.loop)
order.next
	eq(swaps,0)					:s(order.done)
	swaps = i = 0						

*	Loop through chars, swapping out of order characters, until all characters are
*	properly ordered.

order.loop
	c1 = chars[i = i + 1]				:f(order.next)
	c2 = chars[i + 1]				:f(order.next)
	v1 = (ident(c1,'s') 5, g.value[c1])
	v2 = (ident(c2,'s') 5, g.value[c2])
	le(v1,v2)					:s(order.loop)
	ch = c2
	chars[i + 1] = c1
	chars[i] = ch
	swaps = swaps + 1				:(order.loop)
order.done
	order = pack(chars)				:(return)
order.end

	define('out(line)')				:(out.end)

*	Output a line.

*OUT*
out
	output = line					
	ident(g.log)					:s(return)
	logfile = line
							:(return)
	
out.end

	define('pack(chars),i')			
	:(pack.end)

*	Pack the array of characters *chars* into a line.

*PACK*
pack

pack.ch
	pack = pack chars[i = i + 1]			:f(return)s(pack.ch)
pack.end

	define('place(txt,rack)')			:(place.end)

*	Place the permutation digits in *txt* with the corresponding tiles from *rack*.

*PLACE
place
	place = replace(txt,substr('1234567',1,size(rack)),rack)
							:(return)
place.end


	define('playmove(move)i,p,r,c,ch')		:(playmove.end)

*	Play move *move*, updating the board and related objects.

*PLAYMOVE*
playmove
	id = id(move)
playmove.ch
	p = free(move)[i = i + 1]			:f(playmove.done)
	r = row(id,p)
	c = column(id,p)
	ch = substr(text(move),p,1)
	g.board[r, c] = substr(text(move),i,1)
	g.used[r,c]   = 1
	g.bonus[r, c] = ' ';* indicate bonus no longer available
							:(playmove.ch)
							:(playmove.ch)
playmove.done
*	out(ne(g.tracing) 'playmove returns')
							:(return)
playmove.end
	
	define('prefix(str,pre)word')			:(prefix.end)
*PREFIX*
prefix

*	Prefix takes a list of space-separated words str and prefixes each
*	with the string pre.

	str = str ' ';* so each word followed by space
prefix.1
	str break(' ') . word span(' ')  =		:f(return)
	prefixcount = prefixcount + 1
	prefix = append(prefix, pre word,'A')		:(prefix.1)
prefix.end

	define('random(n)')				:(random.end)

*	Return integer uniformly distributed in 1,2,...,n. 
*	If n=0 returns real uniformly distributed in the interval [0,1].
*	The Algorithm is based on that in section 16.1 of "Algorithms in SNOBOL4,"
*	James F. Gimpel, John Wiley and Sons, 1976.

*RANDOM*
random	
	g.random_var = remdr(g.random_var * 4676, 414971)
*	random  = g.random_var / convert(414971,'float')
	random  = g.random_var / 414971.0
	random = ne(n) convert(random * n,'integer') + 1
							:(return)
random.end

	define('row(num,pos)')				:(row.end)

*	Returns row corresponding to position *pos* in line *num*.

*ROW*
row
	row = ((le(num,15) num, pos))		:(return)
row.end

	define('scan(pair,rack)num,line,i,pi,open,oi,nopen,n,first,pos,move,sub,len')	:(scan.end)

*	Scan the given line to find the places where a valid move can be made. At least one cell in 
*	a move must be adjacent to an occupied cell.  *line* is the line to be scanned, and *num* gives its
*	position on the board.

*SCAN*
scan
	line = line(pair)
	num = num(pair)
*	out(ne(g.tracing) 'Scan line ' lineid(num) ' ' show.line(line) ' ' show.hex(line))

*	Allocate and fill in *open*, an array giving the positions of the open cells.

	open = open(pair)				:f(scan.done);* fail if no empty cells
	nopen = +prototype(open);* number of open cells in the line
	
	pi = 0
scan.first
	first = open[pi = pi + 1]			:f(scan.done)
	
*	*first* is the position of the first letter in the move.

*	The number of moves *n* that can be made starting at a given position in *open* depends on
*		the number of tiles in the rack.
*		the number of remaining open cells in the line.
	
	n = +size(rack)
	n = gt(n, nopen - pi) nopen - pi;* number of remaining open cells
	
*	Try for moves of length len=n,n-1...1 starting at position *first* in the line.

	len = n + 1;* prime for loop
scan.len
	le(len = len - 1)				:s(scan.first)

*	out(ne(g.tracing) 'Scan first=' first ' left =' (nopen - pi) ' n=' n ' len=' len)

*	At least one cell to be occupied by this move must be adjacent to a used cell.
	
	oi = 0
scan.used
	gt(oi = oi + 1,len)				:s(scan.len)
	pos = open[pi + oi - 1]				:f(scan.first)
*	out(ne(g.tracing) 'Scan oi=' oi ' pos=' pos)
	adjacent(row(num,pos),column(num,pos)) 		:f(scan.used)s(scan.text)

*	If a move of length *len* has no adjacent cells, then no move of lesser length can
*	have adjacent cells, so we can advance to the next possible starting point.

							:(scan.first)
scan.text

*	Here if adjacent cell found. Set text of move to the permutation specification.

	sub = subarray(open,pi,len)			:f(scan.len)
	move = move(num,len,sub,size(rack) '?' len)	:f(scan.len)
*	out(ne(g.tracing) 'Scan move ' show.move(move))
	scan = ident(scan) table()
	count.scanned = count.scanned + 1
	scan[count.scanned] = move			:(scan.len)
scan.done
	ident(scan)					:s(freturn)
	scan = convert(scan,'array')			
 							:(return)
scan.end

	define('scoreline(pair)line,word,words,wi,n,start,ch,i,bonus,mult,val')	:(scoreline.end)

*	Compute the score of a move on a given line. All the letters of the move will be in upper case on the board
*	so the score of the move is the sum of the scores of all the words with upper case letters in them, for
*	both rows and columns. This function should only be called for lines which have an upper case letter in
*	them as a result of the move.

*SCORELINE*
scoreline
	scoreline = 0
	line = line(pair)
	empty(line)					:s(return)
	bonusline = g.bonus.lines[num(pair)]
	line break(&ucase)				:f(scoreline.error)
	words = words(line)				:f(scoreline.done)
	wi = 0
scoreline.word
	start = words[wi = wi + 1,1]			:f(scoreline.done)
	word = words[wi,2]
*	count.scoreline = count.scoreline + 1
	ne(g.showscore) out('scoreline wi=' wi ' start=' start ' word=' word '.' ' count ' count.scoreline)
	word break(&ucase)				:f(scoreline.word)
	n = size(word)

*	Words of just one letter don't contribute to scoreline since they result from a crossing line.

	eq(n,1)						:s(scoreline.word)

	line = substr(line,start)
	bonusline = substr(g.bonus.lines[num(pair)],start);* corresponding part of bonus line

	i = 0
	mult = 1;* multiplier value for double and triple word cases.

scoreline.char
	gt(i = i + 1,n) 				:s(scoreline.char.done)
	ch = substr(word,i,1)
	bonus = +substr(bonusline,i,1)

*	Update scoreline according to value of letter. Always get at least the value 
*	of the letter, and may get double or triple the letter value.
	
	val = g.value[ch]
	scoreline = scoreline + (eq(bonus,2) val * 2,  eq(bonus,3) val * 3, val)

	ne(g.showscore) out('ch=' ch ' val=' val)
*	Update double/triple word multiplier.

	mult = gt(bonus,3) mult * (bonus - 2)		:(scoreline.char)


scoreline.char.done
	scoreline = ne(scoreline) scoreline * mult	
	ne(g.showscore) out('scoreline=' scoreline)
						:(scoreline.word)
scoreline.error
	out('error scoring line with no new move ' line(pair))
	scoreline = 0					:(return)
scoreline.done
*	ne(g.scoremove) out('scoreline returns ' scoreline)
							:(return)
scoreline.end

	define('scoremove(move)i,p')			:(scoremove.end)

*	A move's score is the sum of the scores of its own line and its crossing lines.

*SCOREMOVE*
scoremove

*	In order to determine which words on the board would be formed by making this move,
*	rebuild *clines* but with the new tiles in uppercase. This way, a word is new if and only if
*	it contains an upper case character. The score is then the sum over all the lines of the scores of
*	the words containing an upper-case character. At most one word in each line of the new grid will
*	contain an upper-case character.

	clines(move,1);* generate move's line and its cross lines with move text in upper case.
*	show.clines()
*	out('scoremove move=' show.move(move))
*	out('g.cln=' g.cln)
	i = 0
scoremove.line
*	out('scoremove line' i)
	gt(i = i + 1,g.cln)				:s(scoremove.done)
*	out('scoremove i=' i ' scoremove =' scoremove)
	scoremove = scoremove + scoreline(g.clines[i])	:(scoremove.line)
scoremove.done
	ne(g.showscore) out('scoremove returns ' scoremove)
							:(return)
scoremove.end

	define('show(rack,player)')			:(show.end)

*	Show state of board, used and value grids before start of move.

*SHOW*
show
	out('rack for player ' player ': ' rack)

	show.grid(g.board)
	show.lines(g.lines)
*	show.board(g.bonus,'bonus')
	show.grid(g.used)
							:(return)
show.end

	define('show.board(board,title)b,r,c,ch,line')	:(show.board.end)

*	Show the board.

*SHOW.BOARD*
show.board
	show.header()
show.board.r
	gt(r = r + 1,15) 				:s(show.board.finish)
	line = lpad(r,2) '|' 
	c = 0
show.board.c
	gt(c = c + 1,15)				:s(show.board.margin)
	ch = ucase(board[r,c])
	b = g.bonus[r,c]
	differ(ch,' ')					:s(show.board.ch)

*	Here if empty cell, see if there is a bonus to be show.boarded.

	ne(b,1)						:s(show.board.b)

*	Here to show.board empty cell.

	line = line ' -'				:(show.board.c)
show.board.b

* 	Here to show.board bonus.

	ch = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line ch 					:(show.board.c)
show.board.margin
	out(line '|')					:(show.board.r)
show.board.ch
	line  = line ' ' ch				:(show.board.c);* show.board tile
show.board.finish
	out()						:(return)
show.board.end

	define('show.bonus()b,r,c,l,line')			:(show.bonus.end)

*	Show the board.

*SHOW.BONUS*
show.bonus
	show.header('bonus')
show.bonus.r
	gt(r = r + 1,15) 				:s(show.bonus.finish)
	line = lpad(r,2) '|'
	c = 0
show.bonus.c
	gt(c = c + 1,15)				:s(show.bonus.l)
	l = g.bonus[r,c]
	line = differ(l,' ') line ' ' l 		:s(show.bonus.c)
* Here for blank cell, show.bonus bonus if applicable
	b = g.bonus[r,c]
	eq(b)						:s(show.b)
* 	Here to show bonus
	l = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line l 					:(show.bonus.c)
show.bonus.b
*	Here to show.bonus empty cell.
	line = line ' -'				:(show.bonus.c)
show.bonus.l
	out(line '|')					:(show.bonus.r)
show.bonus.finish
	out()						:(return)
show.bonus.end

	define('show.clines(move,title)i,p,line,num')		:(show.clines.end)

*	Show the clines array of lines

*SHOW.CLINES*
show.clines
*	show.board(g.board)
*	title  = 'clines' (differ(title) ' ' title, '')
*	out(title)
	out(differ(title) 'clines for ' show.move(move))
	out('    123456789012345')
show.clines.n
	le(i = i + 1, g.cln)				:f(return)
	p = g.clines[i]
	num = num(p)					:f(return)
	line = line(p) 
	out(lpad(lineid(num),2) ' '  replace(line,' ','.')) :(show.clines.n)
show.clines.end

	define('show.grid(g)r')				:(show.grid.end)

*	Show a grid.

*SHOW.GRID*
show.grid
	show.header()
show.grid.r
	gt(r = r + 1,15) 				:s(show.grid.done)
	out(show.hline(g,r))				:(show.grid.r)		 
show.grid.done
	show.header()
	out()						:(return)
show.grid.end

	define('show.header(label)')			:(show.header.end)

*SHOW.HEADER*
show.header
	out(differ(label) label)
	out('                     1 1 1 1 1 1')
	out('   1 2 3 4 5 6 7 8 9 0 1 2 3 4 5')	:(return)
show.header.end

	define('show.hex(line)ch,i')				:(show.hex.end)

*	Show line with blanks replaced by hex digits showing their position in the line.

*SHOW.HEX*
show.hex
	ch = substr(line,i = i + 1,1)				:f(return)
	show.hex = show.hex (ident(ch,' ') substr('123456789ABCDEF',i,1), ch) :(show.hex)
show.hex.end

	define('show.hline(g,row)line,ch')		:(show.hline.end)

*	Returns the line corresponding to row *row* in grid *g* with two characters per cell.

*SHOW.HLINE*
show.hline
	line = hline(g,row)
	show.hline = '|'
show.hline.ch
	line len(1) . ch = 				:f(show.hline.done)
	show.hline = show.hline ' ' ch  		:(show.hline.ch)
show.hline.done
	show.hline = show.hline '|'			:(return)
show.hline.end

	define('show.line(line)')			:(show.line.end)

*	Show a line with blanks replaced by '.'

*SHOW.LINE*
show.line
	show.line = replace(line,' ','.')			:(return)
show.line.end

	define('show.lines(lines,title)i,line,titled')	:(show.lines.end)

*	Show the lines that are not empty in an array of lines

*SHOW.LINES*
show.lines
	title  = 'lines' (differ(title) ' ' title, '')
	out(itle)
show.lines.n
	line = lines[i = i + 1]				:f(return)
	empty(line)					:s(show.lines.n)
	differ(titled)					:s(show.lines.titled)
	out('    123456789012345');* don't list header unless at least one non-empty line
	titled = 1
show.lines.titled
	out(lpad(lineid(i),2) ' ' replace(line,' ','.')) :(show.lines.n)
show.lines.end


	define('show.move(move,title)f,i,ff') 			:(show.move.end)

*	Show a move.

*SHOW.MOVE*
show.move
	out(ident(move) title ' show.move null move ') :s(return)
show.move.i
	gt(i = i + 1,count(move))			:s(show.move.f)
	ff = free(move)[i]
	ident(datatype(ff,'string'))			:s(show.fail)
	f = append(f,ff,',')				:s(show.move.i)
show.move.f
	f break(',') ',' ','				:s(show.funny)
	show.move = lineid(id(move)) ':' count(move) ':' f ':'
	show.move = differ(text(move)) show.move text(move) 
	show.move = differ(perm(move)) show.move ':' perm(move)
	show.move = differ(points(move)) show.move  '+' points(move)
*	show.move = differ(fid(move)) show.move ':' fid(move)
							:(return)
show.funny
	out('funny show.move ' f)			:(end)
show.fail
	out('free ff failure ')			:(end)
show.move.end

	define('show.moves(moves,title)i,move,text')	:(show.moves.end)

*	Show an array of moves. Assume each entry has 1) line num, 2) move

*SHOW.MOVES*
show.moves
	ident(moves)					:s(return)
	out('MOVES ' title)
show.moves.loop
	move = moves[i = i + 1,2]			:f(return)
	out(char(9) lpad(i,2) ' ' show.move(move,'J')) :(show.moves.loop)
show.moves.end
	
	define('show.open(open,title)i')			:(show.open.end)

*	Show open array.

*SHOW.OPEN*
show.open
	show.open = show.open append(lpad(open[i = i + 1]),3)	:s(show.open)
	show.open = 'Open: ' title ' ' show.open
							:(return)
show.open.end

	define('show.pair(pair)')			:(show.pair.end)

*	Show paired item.

*SHOW.PAIR*
show.pair
	show.pair = '{' lineid(num(pair)) ',' "'" replace(line(pair),' ','.') "'" '}'	:(return)
show.pair.end

	define('show.play(move)plines,b,r,c,ch,line')	:(show.play.end)

*	Show the board.

*SHOW.PLAY*
show.play

*	Display move in grid with just this move in upper case by saving the board, playing the move with
*	the text in upper case, showing it, and then restoring the board to its saved state.

	board = copy (g.board)
	lines = copy(g.lines)
	text(move) = ucase(text(move))
	playmove(move)
	plines = lines(g.board);* capture lines with move letters in upper case
	text(move) = lcase(text(move));* restore
*	show.grid(g.board)
	g.board = board
	g.lines = lines
*	show.lines(g.lines,'Lines')

*	Collect the lines of the grid

	lines = array(15)
show.play.l
	gt(r = r + 1,15) 				:s(show.play.ll)
	plines[r] = show.hline(board,r)			:(show.play.l)
show.play.ll
	r = 0
	out(lpad('',22) '1 1 1 1 1 1'
.		 lpad('',20) '1 1 1 1 1 1')
	out(lpad('', 4) '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5'
.		 lpad('', 2) '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5')

show.play.r
	gt(r = r + 1,15) 				:s(show.play.finish)
	line = lpad(r,2) '|' 
	c = 0
show.play.c
	gt(c = c + 1,15)				:s(show.play.margin)
	ch = ucase(board[r,c])
	b = g.bonus[r,c]
	differ(ch,' ')					:s(show.play.ch)

*	Here if empty cell, see if there is a bonus to be show.played.

	ne(b,1)						:s(show.play.b)

*	Here to show.play empty cell.

	line = line ' -'				:(show.play.c)
show.play.b

* 	Here to show.play bonus.

	ch = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line ch 					:(show.play.c)
show.play.margin
	out(line  plines[r])				:(show.play.r)
show.play.ch
	line  = line ' ' ch 				:(show.play.c);* show.play tile
show.play.finish
	out(lpad('', 4) '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5'
.		 lpad('', 2) '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5')
	out()						:(return)
show.play.end

	define('show.player(pid)player')		:(show.player.end)

*	Show player description.

*SHOW.PLAYER*
show.player
	output = 'show.player pid=' pid
	player = g.players[pid]
	out(	 'pid='  pid(player)	' " name(player) "' 
.		(differ(rack(player))	' rack |'	rack(player) '|','')
.		(gt(total(player))	' total '	total(player)   ,'')
.		(gt(highest(player))	' highest '	highest(player) ,''))
							:(return)
show.player.end

	define('show.tiles(tiles)i')			:(show.tiles.end)

*	Show a list of tiles, separated by blanks.

*SHOW.TILES*
show.tiles
	gt(i = i + 1,size(tiles))			:s(return)
	show.tiles = append(show.tiles, ucase(substr(tiles,i,1))) :(show.tiles)
show.tiles.end

	define('show.words(words)i,pos')		:(show.words.end)

*	Show results of words() call.

show.words
	pos = words[i = i + 1,1]			:f(return)
	out('words ' lpad(pos,2) ' ' words[i,2])	:(show.words)
show.words.end

	define('shuffle()tiles,n,r1,r2,ch')		:(shuffle.end)

*	Shuffle the remaining tiles by randomly swapping two tiles several times.

*SHUFFLE*
shuffle	
	tiles = unpack(g.tiles)
	n = size(g.tiles)  * 2
	lt(n,5)						:s(shuffle.done)
shuffle.next
	le(n = n - 1)					:s(shuffle.done)
	r1 = random(n); r2 = random(n)
	eq(r1,r2)					:s(shuffle.next)
	ch = tiles[r1]
	tiles[r1] = tiles[r2]	
	tiles[r2] = ch					:(shuffle.next)
shuffle.done
	g.tiles = pack(tiles)
							:(return)
shuffle.end

	define('spaces(line)n')				:(spaces.end)

*	Count number of spaces in line.

*SPACES*
spaces
	line len(1) . c =				:f(return)
	spaces = ident(c,' ') spaces + 1		:(spaces)
spaces.end

	define('start(pid)player,tiles,perm,perms,permi,free,offset,i,highest,lower,best,n,word,start,score,move')	:(start.end)

*	Determine best starting.turn. At least one letter in this move must be in the center square (8,8).
*	The only bonus available is double word, for any word of more than four characters.

*	Find the move the highest score. Given two moves with the same score, prefer the one with
*	the lowest tile cost.
*
*	The return value has the form 'm s' where m is the move and s is its score.
*
*	There are seven tiles, so we just try all permutations of length one up to seven.

*START*
start
	player = g.players[pid]
	tiles = rack(player)
	n = 0;* number of tiles to play
	highest = lowest = 0;* best score, lowest cost
	start = 8;* assume word will start in column 8

	
	tiles break('s')				:f(start.n)
	tiles = less(tiles,'s')

start.n	gt(n = n + 1,6)					:s(start.done)
*	play at most six tiles for now.
	kind = size(tiles) '?' n
	perms = g.permutations[kind]			:f(start.n)
	permi = 0
start.word
*	get next word, check that valid, then see if new high score
	perm = perms[permi = permi + 1]			:f(start.n)
	word = replace(perm,substr('1234567',1,size(tiles)),tiles)
*	out('kind ' kind ' perm ' perm ' word ' word)
	checkword(word)					:f(start.word)
	checkwords = checkwords + 1

*	Score is the value of the tiles unless the word has five or more characters, in which
*	case the double word bonus at index twelve can be achieved.

	score = (lt(size(word),5) cost(word), 2 * cost(word))

*	Add the first word found to set *highest* and *lowest*

	eq(highest,0)					:s(start.new)

	lt(score,highest)				:s(start.word)
	gt(score,highest)				:s(start.new)

*	Here if current best and new move have same score. Prefer the one with the lowest cost.

	lt(cost(word),lowest)				:s(start.new)

start.new
	highest = score
	lowest = cost(word)
	best = word					
							:(start.word)
start.done

*	Start word at position 8, unless word size greater than five, in which case move it to the left, but
*	making sure move still covers double-word cell at position twelve.

	offset = (lt(size(best,5) 0, 5 - size(best)))

*	Initialize free array for move.

	free = array(size(best))
	i = 0
start.free
	free[i = i + 1] = 7 + i  + offset		:s(start.free)

	start = move(8 + offset,size(best),free,best,highest) :(return)

start.end

	define('subarray(ara,start,len)i')		:(subarray.end)

*	Like substr, but returns the sub-array of *ara* starting at element *start* and
*	consisting of *len* elements

*SUBARRAY*
subarray
	subarray = array(len)
subarray.1
	gt(i = i + 1,len)				:s(return)
	subarray[i] = copy(ara[start + i - 1])		:(subarray.1)		
subarray.end

	define('swap(pid,n)player,tiles')		:(swap.end)

*	Swap *n* tiles from the first *n* characters in *tiles* of player with id *pid*. 
*	If fewer than *n* tiles remain, set *n* to the size of the tileset.

*SWAP*
swap	
	player = g.players[pid]
	tiles = rack(p)
	n = gt(n,size(tiles)) size(tiles)
	n = gt(n,size(g.tiles)) size(g.tiles)
	eq(n)						:s(freturn)
swap.next
	swap = substr(g.tiles,1,n)
	g.tiles = substr(g.tiles,n + 1)  substr(tiles,1,n)
							:(return)
swap.end

	define('take(n)')				:(take.end)

*	Take *n* tiles from the tileset, unless there are fewer than *n* tiles left,
*	in which case return the reamining tiles.

*TAKE*
take
	g.tracing = 0
	n = gt(n,size(g.tiles)) size(g.tiles)
	take = order(substr(g.tiles,1,n))
	g.tiles = substr(g.tiles, n + 1)
*	out('take<' take '> g.tiles<' g.tiles '>')
							:(return)
take.end

	define('traceoff()')				:(traceoff.end)

*	Initiate tracing.

*TRACEOFF*
traceoff
	&ftrace = &trace = g.tracing = 
	out('stop TRACING ')
traceoff.end

	define('traceon()')				:(traceon.end)

*	Initiate tracing.

*TRACEON*
traceon
	out('start TRACING')
	&ftrace = &trace = 1500000
	g.tracing = 1
							:(return)
traceon.end

	define('ucase(s)')				:(ucase.end)

*	Convert argument to upper case.

*UCASE*
ucase
	ucase = replace(s,&lcase,&ucase)		:(return)
ucase.end
	
	define('unpack(line),c,i')			:(unpack.end)

*	Unpack the characters of line *line* to an array of characters.

*UNPACK*
unpack
	unpack = array(size(line))
unpack.ch
	c = substr(line,i = i + 1,1)			:f(return)
	unpack[i] = c					:(unpack.ch)
unpack.end

	define('validmove(move)num,i,pos')		:(validmove.end)

*	Test if move is valid.

*VALIDMOVE*
validmove
	show.grid(g.used)

*	At least one cell to be occupied by this move must be adjacent to a used cell.
	
	num = id(move)
validmove.u
	gt(i = i + 1,count(move))			:s(freturn)
	pos = free(move)[i]
	adjacent(row(num,pos),column(num,pos)) 		:f(validmove.u)s(validmove.used)

*	Here if no adjacent cell found, fail.  *
							:(freturn)
validmove.used
	out('validmove used ok')

*	Test that line and all its crossing lines are valid.

	clines(move);* get line and its crossing lines
	i = 0
validmove.i
	gt(i = i + 1,g.cln)				:s(return)
	checkline(line(g.clines[g.cln]))		:f(freturn)s(validmove.i)
validmove.end

	define('vline(g,c)')				:(vline.end)

*	Return the vertical line of a grid *g* corresponding to column *c* as a string.

*VLINE*
vline
	c = +c
	vline = g[1,c] g[2,c] g[3,c] g[4,c] g[5,c] 
.		g[6,c] g[7,c] g[8,c] g[9,c] g[10,c]
.		g[11,c] g[12,c] g[13,c] g[14,c] g[15,c]
							:(return)
vline.end

	define('words(s)n,w,pos,i,sp')			:(words.end)

*	Return array of the words in s, fail if no words.
*	The first entry for an array element is the starting index;
*	the second is the word itself.

*WORDS*
words

*	Make sure we'll have blank to start off so initial span() matches something, 
*	and also one at end to break to in case last word extends to end of line.

	words = table(n)
	s = ' ' s ' '
	pos = 0	
words.sp

*	Account for blank(s) between words.

	s span(' ') . sp =

	ident(s)					:s(words.done)

	pos = pos + size(sp);* point to start of next word
words.w

*	While it is customary to absorb the blank in the usage below, we leave it in 
*	so there will be at least one blank to satisfy span() when loop back to words.sp

	s break(' ') . w  = 	 			:f(words.done)
	words[pos] = w					
	pos = pos + size(w)				:(words.sp)
words.done
	words = convert(words,'array')			:(return)
words.end

	define('m(id,pos,text)f,fi')			:(m.end)

*	Create move with given id, starting position and text.
*	The move occupies consecutive cells.

*M*
m

*	Build free cell list.

	f = array(size(text))
m.f
	f[fi = fi + 1] = pos + (fi - 1)			:s(m.f)

	m = move(id,size(text),f,text)			
	out('m id ' id '  size ' size(text) ' f[1]' f[1] ' f[count]=' f[size(text)] ' text='  text)
							:(return)
m.end

	define('mf(id,list,text)free,fi,pos,free')	:(mf.end)

*	Define move from id, list of free cells, and text.
*	*f* is a comma-separated list of positions

*MF*
mf
	list = list ',';* to assist loop
	free = array(size(text))
mf.l
	list break(',') . pos ','  =			:f(mf.m)
	free[fi = fi + 1] = pos				:(mf.l)
mf.m
	out(ne(fi, size(text)) 'mf size mismatch')	:s(end)
	mf = move(id,size(text),free,text)		:(return)
mf.end

	define('foe()')					:(foe.end)

*	Enter foe's move.

*FOE*
foe
	out("enter foe's move")
	foe = eval(input)				:f(you.fail)
	out(differ(datatype(foe),'move') " need to enter foe's move, try again.") :f(you)s(return)
foe.end

	define('you()')					:(you.end)

*	Make your move

*YOU*
you
	out('enter your move')
	you = eval(input)				:f(you.fail)
	out(differ(datatype(you),'move') " need to enter your move, try again.") :s(you)
	makemove(you,move)				:s(return)f(freturn)
you.end

	define('r()')					:(r.end)

*	Enter your rack

*R*
r
	out('enter your rack')
	r = input					:s(return)
	out('no input, try again')			:(r)

r.end


	define('resign()')				:(resign.end)

*	Resign

resign
	

resign.end
	define('put.move(move)f,i,ff') 			:(put.move.end)

*	Write move in form acceptable for later reading.

*PUT.MOVE*
put.move

*	Test if all cells in move are contiguous.

	ne(count(move) - 1, free(move)[count(move)] - free(move)[1])	:s(put.move.i)


	put.move = 'm( ' lineid(id(move)) ',' free(move)[1] ",'" text(move) "')"	:(return)

put.move.i
	gt(i = i + 1,count(move))			:s(put.move.f)

	ff = free(move)[i]
	f = append(f,ff,',')				:s(put.move.i)

put.move.f

	put.move = 'mf(' lineid(id(move)) ',' "'" f "','" text(move) "')" :(return) 
							:(return)
put.move.end

	define('put.player(pid)player')				:(put.player.end)

*	Create player description in form acceptable for later reading

*	data('player(pid,name,fribble,rack,total,thirty,highest)')

put.player

	player = g.players[pid]
	put.player = "player(" pid ",'" name(p) "'," fribble(p) ",'" rack(p)  ")"
.							:(return)
put.player.end

	define('put.rack(pid,r)player')				:(put.rack.end)

*	Create description of rack *r* of player with id *pid* in format that can be read back.

put.rack
	player = g.players[pid]
	putrack = "rack(" pid(p) ",'" rack(p) "')"	:(return)
put.rack.end
