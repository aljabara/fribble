*	Copyright 2017, David Shields

	define('concord()')				:(concord.end)

*	Build concordance for a sbl program, by reading the program
*	source from standard input and, for each word in the program,
*	writing out, in alpabetical order, lines consisting of the word
*	followed by a list of the line numbers of the lines that
*	reference the word.
*	

concord

	output = 'enter concord'

	&anchor = &trim = 1
*	&dump = 3
	digits = span('0123456789')
	id.pat = breakx('&' &lcase &ucase '._0123456789')
	label = span(&lcase &ucase '.')
	punctuation = '~!@#$%^&()-+=[]<>,?/'
	letter = any(&lcase &ucase)
	tab = char(9)
	whitespace = span(' ' tab)
	word.pat = span('&' &lcase &ucase '.0123456789')

*	Skip is list of words to be omitted.
*	Do not skip 'define' and 'data' to include function
*	and date definitions in output.

	g.skip = table()
	s = 	' ident differ break breakx span any notany rem '
.		'lt le gt ge eq ne return end input output '
.		'size char table array string integer prototype '
.		'lpad rpad anchor trim dump stlimit '

skip.next
	
	s break(' ') . word ' ' =			:f(skip.done)
	g.skip[word] = 1				:(skip.next)

skip.done

*	WORDS is a table of words found.
*	For each WORD in WORDS, REFLIST is a table mapping WORD 
*	to a table of the lines containing an instance of WORD.

*	The key -1 is used to maintain a count of the number 
*	of entries in a table.

	g.words = table()
	g.words[-1] = 0

*	LINES is a table mapping source line numbers to the line text.

	g.lines = table()
	g.lines[-1] = 0

	g.g.linenum = 0

*	REFS is a list, in increasing order, of the lines that reference a
*	particular word. LIST is a string consisting of line numbers separated
*	by a space. LAST is the most recent line containing a use of the word.
*	This assists is detecting multiple uses of a word in a line. 
*	Consider, for example, the statement 'i = i + 1'.
*	REFLIST is a map from a word to the REFS for it.
	
	data('refs(list,last)')

	g.reflist = table(1000)

line

*	Read next line. Maintain a count of the number of lines in line.n.

	line = input 					:f(return)
	g.linenum = g.linenum + 1

	g.lines[-1] = g.lines[-1] + 1
	g.lines[g.lines[-1]] = lpad(g.linenum,6) tab line

*	Skip empty lines.

	s = line
	s whitespace =
	ident(s)					:s(line)

*	Skip comments and directives.

	line any('*-')					:s(line)

*	Look for period at start of line, indicating a continuation.
*	Remove the period.

	line '.' = 	

	:(nolabel)
*	Look for label at start of line. If found, remove it and
*	add the label to the skip table.

	line letter 					:f(nolabel)
*	output = 'label word[' word '] line [' line ']' 
	g.skip[word] = 1					

nolabel

*	Eliminate leading whitespace.

	line whitespace rem . rest = rest

*	See if define statement, on which case replace quotes
*	with spaces to expose function name and arguments as words.

	line 'define('					:f(define.done)

	line = replace(line, "'"," ")
	line = replace(line, '"'," ")

define.done

	line whitespace =

*	Remove quoted strings.

single

	line break("'") . first  "''" = first rem . rest = first rest	:s(single)
	
double

	line break('"') . first  '"' = first rem . rest = first rest	:s(double)

*	Remove success/failure labels at end of line.


	line breakx(':') . first ':' any('sf(') rem . rest = first
	line = trim(line)

*	Replace punctuation and operators with spaces.

	line = replace(line,punctuation,dupl(' ',size(punctuation)))

*	Replace tabs with spaces, and then replace runs of spaces with a single space.

	line = replace(line,tab,' ')

compact line break(' ') . first '  ' rem . rest = first ' ' rest  :s(compact)

*	Prepare for word loop.

	line = trim(line) ' '

word

	line whitespace =
	ident(line)					:s(line)

*	Skip integer constants.

	line digits =					:s(word)
	line '-' digits =				:s(word)

	line word.pat . word =				:f(line)
	word whitespace rem . rest = rest

*	Skip words in the skip table.

	differ(g.skip[word])				:s(word)

*	Skip words with three or fewer characters.

	le(size(word),3)				:s(word)

*	Here on first seeing a word.

	g.words[-1] = g.words[-1] + 1
	g.words[word] = 1
	g.reflist[word] = refs(,g.linenum)

word.seen

*	Add this line to the list of the lines containing the word.

	newref(word)					:(word)
	
concord.end

	define('listlines()i,n')			:(listlines.end)

*	List the source lines of the program. First write the
*	number of lines and then write the text of all the source lines.

listlines

	n = g.lines[-1]				
	output = n

listlines.next

	le(i = i + 1, n)				:f(return)
	output = g.lines[i]				:(listlines.next)

listlines.end

	define('newref(word)ref')			:(newref.end)

*	Add this line to the list of references for WORD, avoiding
*	adding a new entry in the same line as the most recent
*	use of WORD.

newref

	ref = g.reflist[word]
	eq(g.linenum,last(ref))	 			:s(return)
	list(ref) = list(ref) ' ' last(ref)
	last(ref) = g.linenum				
	output = 'leave ref word [' word ']  list [' list(ref) '] last [' last(ref)
							:(return)

newref.end

	define('listrefs()n,word,this,wi')			:(listrefs.end)
*	Here after scanning the file. Sort the word
*	dictionary in alphabetical order.

listrefs
	output = 'enter listrefs'

	n = g.words[-1]
	g.words[-1] =
	g.words = sort(g.words,1)
	wi = 0

listrefs.word	

	le(wi = wi + 1,n)					:f(return)
	word = g.words[wi,1]
	this = g.reflist[word]
	output = word ' ' list(this) ' ' last(this)		:(listrefs.word)

listrefs.end

*	Main program.

	concord()
	listrefs()
	listlines()
end 
