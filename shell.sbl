* Copyright (c) 2017 dave shields

-include "lib.sbl"

*	s.ok is set to one if last 'eval' command succeeded, zero if it failed.

	s.ok = 0

*	s.ops is the list of shell commands. 

	s.ops = 
. 'board clear eval help init letters move quit score search start tiles valid '

*	s.opabbrev maps abbreviated input to corresponding op.
*	You need specify only first one or more characters
*	in the operation name.

	s.opabbrev = table(100)

	s.letters = &lcase &ucase

*	s.v is set to value of last 'eval' operation.

	define('shell.setup()')				:(shell.setup.end)

shell.setup

*	Initialize the shell.

	op.init()
							:(return)
shell.setup.end

	define('op.init()ops,key,op')			:(op.init.end)

*	Initialize s.optable to acceptable abbreviations for shell operations. 
*	Acceptable abbreviations consist of the initial two or more characters
*	of the operation, up to the full command name itself.


op.init
	ops = s.ops
op.init.next
	ops break(' ') . op ' ' =			:f(return)
	key = op
	s.opabbrev[substr(key,1,1)] = op
op.init.op
	s.opabbrev[key] = op
	key = substr(key,1,size(key) - 1)	:f(op.init.next)
	gt(size(key),1)			:s(op.init.op)f(op.init.next)
op.init.end


*	Simple 'shell' for fribble. 

*	Read commands from terminal and execute them. 
*	This is meant mainly for debugging, testing
*	and as a way to learn how fribble operates.

*	There is only one player, 'you'.


	&stlimit = -1
	&anchor = &trim = 1

	shell.setup()

*	g.dict = g.permutations = 
*	&dump = 3

	init()


	one = player(1,'You')
	g.one = one
	g.two = player(2,'Nobody')
	total(g.one) = g.turn = g.lastmove = g.turnlimit = 0
	total(g.two) = 0

	shell.setup()

*	Fribble shell.

	tab = char(9)
	out('starting shell')
shell

shell.next
	out('op?')
	linein = input ' '					:f(shell.end)
*	out('linein =' linein '.')
	linein span(s.letters) . opin span(' ') rem . operand :s(shell.next.ok)
	operand = trim(operand)
	out('fail opin =' opin ' operand=' operand '.') :(shell.next)
shell.next.ok
	opin = lcase(opin)
	op = s.opabbrev[opin]
	out('op ' opin ' operand ' operand '.')
*	out('op abbrev =' op)
	differ(op)					:s(shell.op)
	out('unknown op: ' op)				:(shell.next)

shell.op						:($('shell.' op))

shell.board
	show.board(g.board)				:s(loop)

shell.clear

*	Clear the board
	g.board = array('15,15',' ')			:(shell.next)

shell.end
	out('shell end of input - bye')		:(end)
shell.eval
	out('evaluating ' operand)
	s.v = eval(operand)				:s(shell.eval.succeed)f(shell.eval.fail)
shell.eval.succeed
	s.ok = 1					:(shell.next)
shell.eval.fail
	out('eval failed, ' &errtext)
	s.ok = 0					:(shell.next)

shell.help
	out(rpad('board',14) 	tab  'show board')
	out(rpad('clear',14) 	tab  'clear board')
	out(rpad('eval' ,14) 	tab 'evaluation expression')
	out(rpad('help' ,14) 	tab 'help')
	out(rpad('init' ,14) 	tab 're-initialize global variable')
	out(rpad('letters',14)  tab 'show values of letters')
	out(rpad('move' ,14)	tab 'enter move')
	out(rpad('quit' ,14) 	tab 'exit shell')
	out(rpad('score' ,14) 	tab 'score move')
	out(rpad('search' ,14)	tab 'search dictionary for matching words')
	out(rpad('start' ,14) 	tab 'make starting move')
	out(rpad('rack tiles',14) 	tab 'set rack to tiles, default "fribble"')
	out(rpad('valid' ,14) 	tab 'validate move')
							:(shell.next)
shell.init
	init()						:(shell.next)
	
shell.letters
	out('B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 ')
							:(shell.next)

shell.move
	out('move not implemented')	
							:(shell.next)

shell.quit
	out('exiting')					:(end)

shell.score
	out('score not implemented')			:(shell.next)

*	Complete assignment statemtn

	op break(' ') span(' ') =
	out('evaluating ' op)
	exp = eval(op)					:(shell.next)

shell.search

*	Search dictionary for matching words

	out('search not yet implemented')

shell.start

*	Make starting move using current tiles, default to 'fribble'

	rack(g.one) = ident(rack(g.one)) 'fribble'
	move = start(g.one)
	makemove(g.one,move)
	show.play(move)
							:(shell.next)

shell.tiles

*	Read tiles from rest of command line.

	tiles = operand
	gt(size(tiles,7)) out('truncating to seven tiles')
	tiles = gt(size(tiles,7)) substr(tiles,1,7)
	rack(g.one) = tiles
	out('rack now ' tiles)
							:(shell.next)

	differ(g.trace) tracer()

	out(ne(g.maxmoves) gt(g.turn,g.maxmoves) 'Game over -  too many turns.')  :s(shell.over)

	out('Move ' g.turn ' for player ' name(player) ', with tiles ' show.tiles(rack(player),'A') '.')
	differ(fribble(player))				:s(shell.fribble)

shell.you.move

*	Here for you to make a move

	show.board(g.board)
	out('your tiles: ' show.tiles(rack(player)))
	out('make your move ')
	text = input					:f(shell.eof)
	out('you entered ' text)
	ident(text,'quit')				:s(shell.over)
	ident(text,'resign')				:s(shell.resign)
	move = eval(text)
	ident(datatype(move),'MOVE')			:s(shell.validmove)
	out('evaluating ' text)
	eval(text)
							:(shell.you.move)
shell.validmove
	show.move(move)
	out((validmove(move) ' valid move','invalid move'))	:(shell.next)

shell.scoremove
	
	clines(move,1)
	show.clines()
*	g.showscore = 1
	points(move) = findscore()
	out('move is worth ' points(move) ' points.')
							:(shell.next)
	out('do you want to make this move (y or just ENTER for yes, no otherwise)?')
	ans = input					:f(shell.eod)
	ident(ans)					:s(shell.moveon)
	ident(ans,'y')					:s(shell.moveon)
							:(shell.you.move)
*shell.move
shell.moveon
	makemove(player,move)
	show.play(move)
							:(shell.next)
*shell.swap
*	rack(player) = swap(player,3)
*	out('Player ' name(player) ' swapped tiles.')
*	out('Player ' name(player) ' now has tiles ' show.tiles(rack(player))) :(shell.turn)
shell.eof
	out('end of input - shell over')		:(return)
end
