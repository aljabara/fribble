* This software is licensed under the MIT License, contained in the file LICENSE.

* Copyright (c) 2016 dave shields

*	Global Variables

*	Here are the global variables. Each has a name starting with 'g.' Their initial value is set in the
*	procedure *init()*.

*	Each cell in the playing board is represented by a program-defined datatype *cell*.
*	A cell is occupied, or is  'played,' if it has been played on a previous move. Initially no cell is occupied.

	data('cell(row,column,tile,bonus,new)')

*	where

*		*row* is the row number, in range 1..15

*		*column* is the column number, in range 1..15

*		*tile*	the letter that has been played in this cell, or null if empty

*		*bonus* is null or else bonus type for this cell ('dw','dl', etc)

*		*new*	letter being tried in this cell for this turn. That is, we mark a cell as 'new' when we
*			are trying out a potential move.

*	g.board, array('15,15'), the playing board. Each entry is a *cell*. 

*	A play is a sequence of one or more cells, represented as an array.  The cells are ordered
*	from left to right for a horizontal play, top to bottom for a vertical play.

*	g.dict, a map on words that is non-null for words in the dictionary.

*	g.move, array(7), is an array giving a possible move. Each entry is a cell marked as *new*.
*		When the best move has been found, the cells
*		are added to the board, the score for all
*		newly formed words is determined, and the
*		*new* indicator is removed.

*	g.len is the number of entries currently in the move list.

*	g.lines, array(30), is the array of the lines defined by the
*		rows and columns in the board. 

*	g.perms, a table of the permutations of n=1..7 things taken 1..k at a time.
*	For example, g.perms['7?3'] is permutations of 1..7 taken 3 at a time, as a string with
*	entries separated by a space.

*	g.rack, a string containing the current rack. Plays are made using the characters from the rack.

*	g.tileset, a string containing all the characters in the initial bag of characters.

*	g.value, a map from characters to the tile value of that character.


*	Utility functions

	define('init(dictfile,skip)c,i,j,s,t')		:(init.end)

*	Initialize global variables.

init
	init.board()
	init.bonus()

*	Initialize set of moves.

	g.move = array(7);* at most seven tiles can be played at a time
	g.len = 0

*	Initialze permutation map.

	init.perm('../perm.txt')

	init.tileset()

	init.value()

	init.dict(dictfile,skip)
							:(return)
init.end

	define('add(str,word)')				:(add.end)

*	add word to string str, prefixing with a space if str is not null.
*	this aids in building list of words separated by spaces.

add
	add = ident(str) word				:s(return)
	add = str ' ' word				:(return)
add.end

	define('isadjacent(r,c)')			:(adjacent.end)

*	Succeeds if cell (r,c) is adjacent to an occupied cell on
*	board, fails otherwise.

isadjacent

*	Test neighboring cells to see if any one is occupied.
*	Note that may examine cells outside the playing board, in which
*	case the attempt to get the value of the cell will fail.

	differ(tile(g.board[r - 1,c]))			:s(return)
	differ(tile(g.board[r - 1,c]))			:s(return)
	differ(tile(g.board[r,c - 1]))			:s(return)
	differ(tile(g.board[r,c + 1]))			:s(return)
						:(freturn)
adjacent.end

	define('backwords()ara,key,val,i')	:(backwords.end)

*	use dictionary g.dict to build dictionary with the words reversed.

backwords
	ara = convert(g.dict,'array')
*	backwords = table(20000)
	backwords = table()


backwards.1
	key = ara[i = i + 1,1]				:f(return)
	val = ara[i,2]
	backwords[key] = reverse(val)			:(backwords.1)
backwords.end

	define('blanks(line)n')				:(blanks.end)

*	Count number of blanks in line.

blanks
	line len(1) . c =				:f(return)
	blanks = ident(c,' ') blanks + 1		:(blanks)
blanks.end

	define('cells(move)r,c,t,text,i,n')		:(cells.end)

*	Return the cells that comprise a move, by which we mean a list consisting of a series of one or more
*	placements, each consisting of a string of one or more characters followed by a signed integer with
*	a specified form. The signed integer identifies where the placement is in a row (plus sign) or
*	along a column (minus sign). The cell is indicated by multiplying the row number by one hundred and adding the
*	column number.

cells
	move break('+-') . text len(1) . sign rem . rc
	output = 'text ' text '|' sign '|' rc

	n = size(text)
	cells = array(size(text) ',3')
	ident(sign,'+')					:s(cells.h)
	ident(sign,'-')					:s(cells.v)
	output = 'improper type in move ' move		:(freturn)
cells.h
	i = i + 1
	gt(i,n)						:s(return)
	cells[i,1] = +(rc / 100)			:f(return)
	cells[i,2] = remdr(rc,100)
	cells[i,3] = substr(text,i,1)
	c. = c + 1					:(cells.h)
cells.v
	i = i + 1
	gt(i,n)						:s(return)
	cells[i,1] = +(rc / 100)			:f(return)
	cells[i,2] = +remdr(rc,100);
	cells[i,3] = substr(text,i,1)
	r = r + 1					:(cells.v)
cells.end

	define('clean()row,col,c')			:(clean.end)

*	Clean up the board after deciding on a move.
*	For each new cell, clear the bonus value and the new indicator.

clean
	row = 0; col = 0;
clean.nextrow
	gt(row = row + 1, 15)				:s(return)
	col = 0;
clean.nextcell
	gt(col = col + 1, 15)				:s(clean.nextrow)
	c = g.board[row,col]
	ident(new(c))					:s(clean.nextcell)
	bonus(c) = new(c) =				:(clean.nextcell)
clean.end
	
	define('display()b,r,c,l,line')				:(display.end)

*	Display the board on standard output

display
	output =
	output = '    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15'
display.r
	gt(r = r + 1,15) 				:s(display.finish)
	line = lpad(r,2) '|'
	c = 0
display.c
	gt(c = c + 1,15)				:s(display.l)
	l = tile(g.board[r,c])
	line = differ(l,' ') line ' ' ucase(l) ' ' 	:s(display.c)
* Here for blank cell, display bonus if applicable
	b = bonus(g.board[r,c])
	ident(b)					:s(display.b)
* 	Here to display bonus
	l = (eq(b,1) 'dl', eq(b,2) 'tl', eq(b,3) 'dw', eq(b,4) 'tw')
	line = line l ' '				:(display.c)
display.b
*	Here to display empty cell.
	line = line ' - '				:(display.c)
display.l
	output = line '|'				:(display.r)
display.finish
	output =					:(return)
display.end

	define('first(line)')				:(first.end)

*	Return index of first blank in line, or fail if none.

first
	ident(line)					:s(freturn)
	line len(1) . c 
	differ(c,' ')					:s(first.1)
	first = 1					:(return)
first.1
	line span(&lcase) . c				:f(freturn)
	first = size(c) + 1
	gt(first,15)					:s(freturn)f(return)
first.end
	
	define('hline(r)')				:(hline.end)

*	Return the horizontal line of the board corresponding to row r as a string.

hline
*	lt(r,1)						:s(freturn)
*	gt(r,15)					:s(freturn)
	hline = tile(g.board[r,1]) tile(g.board[r,2]) tile(g.board[r,3]) tile(g.board[r,4]) tile(g.board[r,5]) 
.		tile(g.board[r,6]) tile(g.board[r,7]) tile(g.board[r,8]) tile(g.board[r,9]) tile(g.board[r,10])
.		tile(g.board[r,11]) tile(g.board[r,12]) tile(g.board[r,13]) tile(g.board[r,14]) tile(g.board[r,15])
							:(return)
hline.end

	define('init.board()row,col')			:(init.board.end)

*	Initialize the playing board.

init.board
	g.board = array('15,15')
init.board.row
	gt(row = row + 1, 15)				:s(return)
	col = 0
init.board.col
	gt(col = col + 1, 15)				:s(init.board.row)
	g.board[row,col] = cell(row,col,' ')
							:(init.board.col)
init.board.end

	define('init.bonus()s,row,col,b,c')		:(init.bonus.end)

*	Initialize the bonus squares for the 15x15 grid, using 1 for double letter,
*	2 for triple letter, 3 for double word, and 4 for triple word.

init.bonus
	s =     '1 0203 1 0212 1 0302 1 0305 1 0311 1 0312 1 0314 1 0503 1 0613 1 0705 1 0711 '
.		'1 0905 1 0911 1 1103 1 1109 1 1113 1 1302 1 1305 1 1311 1 1314 1 1403 1 1413 '
.		'2 0107 2 0109 2 0404 2 0412 2 0606 2 0610 2 0701 2 0715 2 0901 2 0915 2 1006 '
.               '2 1010 2 1304 2 1312 2 1507 2 1509 '
.		'3 0206 3 0210 3 0408 3 0602 3 0614 3 0804 3 0812 3 1002 3 1014 3 1208 3 1406 3 1410 '
.		'4 0104 4 0112 4 0401 4 0415 4 1101 4 1115 4 1504 4 1512 '
init.bonus.1
	s len(1) . b ' ' len(2) . row len(2) . col ' ' =	:f(return)
	c = g.board[+row,+col]
	bonus(c) = +b						:(init.bonus.1)
init.bonus.end

	define('init.dict(filename,skip)file,n,w,s')		:(init.dict.end)

*	Initialize the global dictionary g.dict.
*	g.wwf is list of words not in enable1.txt word list but known to be accepted as valid by wwf.

	g.wwf = 'qi brr zen zep '

init.dict

*	Read in a dictionary from a specified file, with one word per line. If 'skip'
*	is non-zero then that number of lines are skipped before adding the next word.
*	This assists the use of smaller dictionaries for testing.

	filename = ident(filename) '../dict.txt'
	skip = (ident(skip) +1, +skip)
	g.dict = table(100000)

*	add words from g.wwf list to dictionary

	s = g.wwf
init.dict.wwf.1
	s break(' ') . w ' ' =				:f(init.dict.wwf.2)
	g.dict[w] = +1					:(init.dict.wwf.1)
init.dict.wwf.2

	input(.file,3,filename)				:s(init.dict.in)
	output = 'unable to open input file ' filename	:(freturn)
	n = 0
init.dict.in
	w = file					:f(init.dict.done)
	gt(size(w),15)					:s(init.dict.in)
	g.dict[w] = +1
	eq(skip,1)					:s(init.dict.in)
*	here want to skip over entries in the dictionary (for testing)
	n = skip
init.dict.skip
	w = file					:f(init.dict.done)
	gt(n = n - 1,0)					:s(init.dict.skip)f(init.dict.in)
init.dict.done
	endfile(3)					:(return)
init.dict.end

	define('init.perm(filename)line,ifile,n,k,lines')	:(init.perm.end)

*	Initialize the list of possible permutations from a file.

init.perm
	g.permutations = table(100)
	input(.ifile,4, filename)			:s(init.perm.1)
	output = 'unable to open permutation file ' filename 	:(freturn)
*	read first line and merge to process permutation description line
	line = ifile					:f(init.perm.done)s(init.perm.2)
	lines = 1
init.perm.1
	line = ifile					:f(init.perm.done)
	lines = lines + 1
init.perm.2
	line '; ' break('?') . n '?' break(' ') . k ' ' rem . count :f(init.perm.err)
init.perm.k
	line = ifile					:f(init.perm.done)
	lines = lines + 1
*	add blank at end of list to simplify later iterations over the list
	g.permutations[n '?' k] = line ' '		:(init.perm.1)
init.perm.done
	endfile(4)					:(return)
init.perm.err
	output = 'init.perm error, line ' lines '  '  line :(freturn)
init.perm.end

	define('init.tileset()s,n')			:(init.tileset.end)

* 	Initialize set of tiles, ignoring the 'blank' tiles for now.
*	Initialize value map from letters to value, ignoring ' ' for now

init.tileset
	s = 'a 9 b 2 c 2 d 5 e 13 f 2 g 3 h 4 i 8 j 1 k 1 l 4 m 2 n 5 o 8 p 2 q 1 r 6 s 5 t 7 u 4 v 2 w 2 x 1 y 2 z 1 '
	g.tileset =
init.tileset.1
	s break(' ') . c ' ' break(' ') . n ' ' =	:f(return)
	g.tileset = g.tileset dupl(c,n)			:(init.tileset.1)
init.tileset.end

	define('init.value()s,c')			:(init.value.end)
init.value
	g.value = table(26)
	s = &lcase
init.value.next
*	assume value is 1
	s len(1) . c =					:f(init.value.finish)
	g.value[c] = 1					:(init.value.next)
init.value.finish
*	g.value[' '] = 1
*	update assumptions for letters with value greater than one.

	g.value['d'] = g.value['l'] = g.value['n'] = g.value['p'] = g.value['u'] = g.value['w'] =  +2
	g.value['g'] = g.value['h'] = g.value['y'] = +3
	g.value['b'] = g.value['c'] = g.value['f'] = g.value['m'] = g.value['p'] = g.value['w'] = +4
	g.value['k'] = g.value['v'] = +5
	g.value['x'] = +8
	g.value['j'] = g.value['q'] = g.value['z'] = 10
							:(return)
init.value.end


	define('isword(word,words)')			:(isword.end)

*	Words is a map on words. Succeeds if words is defined for the specified word,
*	fails otherwise.
isword
	differ(words[word])				:s(return)f(freturn)

isword.end

	define('last(string)w')				:(last.end)

*	Return index of last space in string, or null if no space in string

last
	last = first(reverse(line))			:f(freturn)
	last = 16 - last				:(return)
last.end

	define('less(str,ch)before,after')		:(less.end)

*	Removes the first instance of character ch in str.

less
	ident(str)					:s(return)
	str break(ch) . before len(1) rem . after	:f(less.1)
	less = before after				:(return)
less.1
	less = ident(substr(s,1,1),ch) substr(s,2)	:s(return)
	less = str					:(return)
less.end

	define('lines()i')				:(lines.end)

lines
	lines = array(30)
lines.next
	gt(i = i + 1,7)					:s(return)
	lines[i] = hline(i)
	lines[i + 7] = vline(i)				:(lines.next)
lines.end

	define('open(tiles)best.score,best.word,n,w,start')	:(open.end)

*	Determine best opening move. At least one letter in this move must be in the center square (8,8).
*	The only bonus available is double word, for any word of more than four characters.
*
*	The return value has the form 'm s' where m is the move and s is its score.
*
*	There are seven tiles, so we just try all permutations of length one up to seven.

open
	n = 0;* number of tiles to play
	best = 0;* best score
	start = 8;* assume word will start in column 8

open.1	le(n = n + 1,7)					:f(open.finish)
	perms = permutations(tiles,n)
open.2
*	get next word, check that valid, then see if new high score
	perms break(' ') . w ' ' =			:f(open.1)
	permwords = permwords + 1
	validword(w)					:f(open.2)
	validwords = validwords + 1
	le(oscore(w),best.score)			:s(open.2)
	best.word = w
	best.score = oscore(w)
	open = lt(size(best.word),6) 'h0808' best.word ' ' best.score	:s(open.2)
*	Here if longer open word, move a space to the left
	start = 7
	open = 'h0807' best.word ' ' best.score		:(open.2)
open.finish						
	n = 0
open.finish.1
	gt(n = n + 1,size(best.word))			:s(return)
	tile(g.board[8,start - 1 + n]) = substr(best.word,n,1)		
							:(open.finish.1)
open.end

	define('oscore(word)i,c')			:(oscore.end)

*	Compute the score of an initial word, which is always played horizontally starting at the center 
*	square (row=8, column = 8).
oscore
	word len(1) . c =				:f(oscore.finish)
	oscore = oscore + g.value[c]			:(oscore)
oscore.finish
*	Double word score if length greater than four, so bonus at (8,12) is achieved.
	lt(size(word),5)				:s(return)
	oscore = oscore + oscore			:(return)
oscore.end

	define('permutations(s,k,d)')			:(permutations.end)

*	Return permutations of s taken k at a time.

permutations
	permutations = g.permutations[size(s) '?' k]		:f(freturn)
	d = substr('1234567',1,size(s))
	permutations = replace(permutations,d,s)			:(return)
permutations.end

	define('prefix(str,pre)word')			:(prefix.end)
prefix

*	Prefix takes a list of space-separated words str and prefixes each
*	with the string pre.


	str = str ' ';* so each word followed by space
prefix.1
	str break(' ') . word span(' ')  =		:f(return)
	prefixcount = prefixcount + 1
	prefix = add(prefix, pre word)			:(prefix.1)
prefix.end

	define('random(n)')

*	Return integer uniformly distributed in 1,2,...,n. If n=0 returns real uniformly distributed
*	in the interval [0,1].
*	The Algorithm is based in that in section 16.1 of "Algorithms in SNOBOL4," James F. Gimpel, John Wiley and Sons, 1976.

*	Gimpel uses integer here, but need to have real.
	random_var = convert(1,'real')

							:(random.end)
random	random_var = remdr(random_var * 4676, 414971)

	random  = random_var / 414971
	random = ne(n,0) convert(random * n,'integer') + 1
							:(return)
random.end

	define('random_rack()i')				:(random_rack.end)

*	Return random set of seven tiles from the initial set of tiles.
*	This is used for testing.

random_rack
	gt(i = i + 1,7)					:s(return)
	random_rack = random_rack substr(g.tileset,random(size(g.tileset)),1)	:(random_rack)
random_rack.end

	define('score(cells)r,i,c,t,v,b,dw,tw')		:(score.end)

*	score a sequence of cells

score
	r = cells[i = i + 1,1]				:f(score.done)
	c = cells[i,2]
	t = cells[i,3]
	v = g.value[cells[i,3]]
	b = bonus[g.board[r,c]]
	ident(b)					:s(score)
	score = eq(b,1) score + 2 * v
	score = eq(b,2) score * 3 * v
	dw = eq(b,3) dw + 1
	tw = eq(b,4) tw + 1
							:(score)
score.done

*	apply double/triple word bonuses
	score = eq(dw,1) score * 2
	score = eq(dw,2) score * 4
	score = eq(tw,1) score * 3
	score = eq(tw,2) score * 9
							:(return)
score.end

	define('ucase(s)')				:(ucase.end)

*	Convert argument converted to upper case

ucase
	ucase = replace(s,&lcase,&ucase)		:(return)
ucase.end
	
	define('validword(w)')				:(validword.end)

*	Succeeds if w is in the global dictionary, fails otherwise.

validword
	differ(g.dict[w])				:s(return)f(freturn)
validword.end
	define('validateline(line)word')			:(validateline.end)

*	Succeeds if all the words in the line are in the dictionary, fails otherwise.

validateline
	line = line ' '
validateline.1
	line span(' ') =
	ident(line)					:s(return)
	line break(' ') . word span(' ') =
	valid( word)					:f(freturn)s(validateline.1)
validateline.end

	define('validatelines()i,lines')			:(validatelines.end)

*	Succeeds if every line in the board has only valid words.

validatelines
	lines = lines()
validatelines.next
	gt(i = i + 1,30)				:s(return)
	validateline(lines[i])				:f(freturn)s(validatelines.next)
validatelines.end



	define('vline(c)')				:(vline.end)

*	Return the vertical line of the board corresponding to column c as a string.

vline
*	lt(c,1)						:s(freturn)
*	gt(c,15)					:s(freturn)
	vline = tile(g.board[1,c]) tile(g.board[2,c]) tile(g.board[3,c]) tile(g.board[4,c]) tile(g.board[5,c]) 
.		tile(g.board[6,c]) tile(g.board[r.7,c]) tile(g.board[8,c]) tile(g.board[9,c]) tile(g.board[10,c])
.		tile(g.board[11,c]) tile(g.board[12,c]) tile(g.board[13,c]) tile(g.board[14,c]) tile(g.board[15,c])
							:(return)
vline.end

	define('words(s)i,w')				:(words.end)

*	Return number of space-separated words in s

words
	s = s  ' '
	words = 0
words.1
	s break(' ') . w span(' ') =			:f(return)
	words = words + 1				:(words.1)
words.end

