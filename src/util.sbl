* This software is licensed under the MIT License, contained in the file LICENSE.

* Copyright (c) 2016 dave shields

*	Global Variables

*	Here are the global variables. Each has a name starting with 'g.' Their initial value is set in the
*	procedure *init()*.

*	g.board, array('15,15'), the playing board. Each entry is blank (' ') for unplayed cell, or is the letter played.

*	A play is a sequence of one or more cells, represented as an array.  The cells are ordered
*	from left to right for a horizontal play, top to bottom for a vertical play.

*	g.dict, a map on words that is non-null for words in the dictionary.

*	g.alone, array('15,15') tracks the *alone* cells in the board. A cell is *alone* if it is empty and all its
*	neighbors are empty. A move made after the first move cannot consist only of cells that are alone. 
*	That is, at least one tile in a valid move must be adjacent to a tile played in a previous move.

*	g.alone.lines, array(30), is the array of lines defined by the rows and columns of the alone grid.

*	g.board.lines, array(30), is the array of the lines defined by the rows and columns in the board. 

*	g.perms, a table of the permutations of n=1..7 things taken 1..k at a time.
*	For example, g.perms['7?3'] is permutations of 1..7 taken 3 at a time, as a string with
*	entries separated by a space.

*	g.rack, a string containing the current rack. Plays are made using the characters from the rack.

*	g.tileset, a string containing all the characters in the initial bag of characters.

*	g.value, a map from characters to the tile value of that character.

*	g.line is used to hold a line from the board when trying all the possible moves for that line.

*	g.avail, array(15), is the result of applying the procedure available() to g.line.

*	g.scores, array(), used to accumulate scores of valid moves during a turn.
*	g.nscores, number of current entries in g.score

*	A move consists of sequence of cells in a row or column.
*	*id* gives the line number, in the range 1..30. *count* is the number of free cells covered by this move.
*	*free* is an array of dimension *count* giving the empty cells to be filled by this move.
	data('move(id,count,free,text)')

*	g.bonus,array(15,15) gives the bonus values for the squares on the board, using 
*		1 for the value of the letter itself
*		2 for double letter,
*		3 for triple letter, 
*		4 for double word, 
*		5 for triple word.

*	g.bonus.lines,array(30), is the array of lines corresponding to g.bonus

*	Utility functions

	define('init(dictfile,skip)c,i,j,s,t')		:(init.end)

*	Initialize global variables.

init
	g.board = array('15,15',' ')

	g.alone = array('15,15','1')

	g.scores =  array(1000)
	g.nscores = 0

	init.bonus()

*	Initialize set of moves.

	g.move = array(7);* at most seven tiles can be played at a time
	g.len = 0

*	Initialze permutation map.

	init.perm('../perm.txt')

	init.tileset()

	init.value()

	init.dict(dictfile,skip)
							:(return)
init.end

	define('add(str,word)')				:(add.end)

*	add word to string str, prefixing with a space if str is not null.
*	this aids in building list of words separated by spaces.

add
	add = ident(str) word				:s(return)
	add = str ' ' word				:(return)
add.end

	define('after(num)')				:(after.end)

*	Find the line 'after' line *num*. This is either the row below or the column to the right, or
*	null if line *num* is at the edge of the board

after
	after = (eq(num,1) '', eq(num,15) '',g.board.lines[num + 1])	:(return)
after.end

	define('available(line)blanks,c,i')			:(available.end)

*	Return array containing the indexes of the blank cells in line. Fails if no blanks.
available
	c = substr(line, i = i + 1, 1)				:f(available.1)
	differ(c,' ')						:s(available)
	blanks = blanks + 1					:(available)
available.1
	eq(blanks,0)						:s(freturn)
	available = array(blanks)
	i = ai = 0
available.2
	c = substr(line, i = i + 1, 1)				:f(return)
	differ(c,' ')						:s(available.2)
	available[ai = ai + 1] = +i				
	output = 'ai ' lpad(ai,2) '  ' +i
								:(available.2)
available.end

	define('before(num)')				:(before.end)

*	Find the line 'before' line *num*. This is either the row above or the column to the left, or
*	null if line *num* is at the edgs of the board

before
	before = (eq(num,1) '', eq(num,16) '',g.board.lines[num - 1])	:(return)
before.end
	
	define('blanks(line)n')				:(blanks.end)

*	Count number of blanks in line.

blanks
	line len(1) . c =				:f(return)
	blanks = ident(c,' ') blanks + 1		:(blanks)
blanks.end

	define('bonus.lines()i')			:(bonus.lines.end)

bonus.lines
	bonus.lines = array(30)
bonus.lines.next
	gt(i = i + 1,15)				:s(return)
	bonus.lines[i] = hline(g.bonus,i)
	bonus.lines[i + 15] = vline(g.bonus,i)		:(bonus.lines.next)
bonus.lines.end

	define('cells(move)r,c,t,text,i,n')		:(cells.end)

*	Return the cells that comprise a move, by which we mean a list consisting of a series of one or more
*	placements, each consisting of a string of one or more characters followed by a signed integer with
*	a specified form. The signed integer identifies where the placement is in a row (plus sign) or
*	along a column (minus sign). The cell is indicated by multiplying the row number by one hundred and adding the
*	column number.

cells
	move break('+-') . text len(1) . sign rem . rc
	output = 'text ' text '|' sign '|' rc

	n = size(text)
	cells = array(size(text) ',3')
	ident(sign,'+')					:s(cells.h)
	ident(sign,'-')					:s(cells.v)
	output = 'improper type in move ' move		:(freturn)
cells.h
	i = i + 1
	gt(i,n)						:s(return)
	cells[i,1] = +(rc / 100)			:f(return)
	cells[i,2] = remdr(rc,100)
	cells[i,3] = substr(text,i,1)
	c. = c + 1					:(cells.h)
cells.v
	i = i + 1
	gt(i,n)						:s(return)
	cells[i,1] = +(rc / 100)			:f(return)
	cells[i,2] = +remdr(rc,100);
	cells[i,3] = substr(text,i,1)
	r = r + 1					:(cells.v)
cells.end
	
	define('checkline(line)word')			:(checkline.end)

*	Succeeds if all the words in the line are in the dictionary, fails otherwise.

checkline
	line = line ' '
checkline.1
	line span(' ') =
	ident(line)					:s(return)
	line break(' ') . word span(' ') =
	valid( word)					:f(freturn)s(checkline.1)
checkline.end

	define('checklines()i,lines')			:(checklines.end)

*	Succeeds if every line in the board has only valid words.

checklines
	lines = lines(g.board)
checklines.next
	gt(i = i + 1,30)				:s(return)
	checkline(lines[i])				:f(freturn)s(checklines.next)
checklines.end

	define('checkword(w)')				:(checkword.end)

*	Succeeds if w is in the global dictionary, fails otherwise.

checkword
	differ(g.dict[w])				:s(return)f(freturn)
checkword.end

*	define('clean()row,col,c')			:(clean.end)
*
**	Clean up the board after deciding on a move.
**	For each new cell, clear the bonus value and the new indicator.
*
*clean
*	row = 0; col = 0;
*clean.nextrow
*	gt(row = row + 1, 15)				:s(return)
*	col = 0;
*clean.nextcell
*	gt(col = col + 1, 15)				:s(clean.nextrow)
*	c = g.board[row,col]
*	ident(new(c))					:s(clean.nextcell)
*	bonus(c) = new(c) =				:(clean.nextcell)
*clean.end
	
	define('display()b,r,c,l,line')			:(display.end)

*	Display the board on standard output

display
	output = 'display()'
	output = '                      1 1 1 1 1 1'
	output = '    1 2 3 4 5 6 7 8 9 0 1 2 3 4 5'
display.r
	gt(r = r + 1,15) 				:s(display.finish)
	line = lpad(r,2) '|'
	c = 0
display.c
	gt(c = c + 1,15)				:s(display.l)
	l = g.board[r,c]
	b = g.bonus[r,c]
	line = ident(b,' ') line '  ' l 		:s(display.c)
* Here for blank cell, display bonus if applicable
	line = ident(b,' ') line '  '			:s(display.c)
* 	Here to display bonus
	l = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line l 					:(display.c)
display.b
*	Here to display empty cell.
	line = line ' -'				:(display.c)
display.l
	output = line '|'				:(display.r)
display.finish
	output =					:(return)
display.end


	define('display.alone()b,r,c,l,line')				:(display.alone.end)

*	Display the board on standard output

display.alone
	output = 
	output = '                      1 1 1 1 1 1'
	output = '    1 2 3 4 5 6 7 8 9 0 1 2 3 4 5'
display.alone.r
	gt(r = r + 1,15) 				:s(display.alone.finish)
	line = lpad(r,2) '|'
	c = 0
display.alone.c
	gt(c = c + 1,15)				:s(display.alone.l)
	l = g.alone[r,c]
	line = line lpad(l,2)		 		:s(display.alone.c)
display.alone.l
	output = line '|'				:(display.alone.r)
display.alone.finish
	output =					:(return)
display.alone.end

	define('display.bonus()b,r,c,l,line')			:(display.bonus.end)

*	Display the board on standard output

display.bonus
	output =  'display bonus'
	output = '                      1 1 1 1 1 1'
	output = '    1 2 3 4 5 6 7 8 9 0 1 2 3 4 5'
display.bonus.r
	gt(r = r + 1,15) 				:s(display.bonus.finish)
	line = lpad(r,2) '|'
	c = 0
display.bonus.c
	gt(c = c + 1,15)				:s(display.bonus.l)
	l = g.bonus[r,c]
	line = differ(l,' ') line ' ' l 		:s(display.bonus.c)
* Here for blank cell, display.bonus bonus if applicable
	b = g.bonus[r,c]
	eq(b)						:s(display.b)
* 	Here to display bonus
	l = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line l 					:(display.bonus.c)
display.bonus.b
*	Here to display.bonus empty cell.
	line = line ' -'				:(display.bonus.c)
display.bonus.l
	output = line '|'				:(display.bonus.r)
display.bonus.finish
	output =					:(return)
display.bonus.end

	define('first(line)')				:(first.end)

*	Return index of first blank in line, or fail if none.

first
	ident(line)					:s(freturn)
	line len(1) . c 
	differ(c,' ')					:s(first.1)
	first = 1					:(return)
first.1
	line span(&lcase) . c				:f(freturn)
	first = size(c) + 1
	gt(first,15)					:s(freturn)f(return)
first.end
	
	define('hline(grid,r)')				:(hline.end)

*	Return the horizontal line of a grid corresponding to row r as a string.

hline
	hline = grid[r,1] grid[r,2] grid[r,3] grid[r,4] grid[r,5] 
.		grid[r,6] grid[r,7] grid[r,8] grid[r,9] grid[r,10]
.		grid[r,11] grid[r,12] grid[r,13] grid[r,14] grid[r,15]
							:(return)
hline.end

	define('init.bonus()s,row,col,b,c')		:(init.bonus.end)

*	Initialize the bonus squares for the 15x15 grid, using 1 for double letter,
*	2 for triple letter, 3 for double word, and 4 for triple word.

init.bonus
	g.bonus = array('15,15',' ')
	s = 	'5 0104 3 0107 3 0109 5 0112 2 0203 4 0206 4 0210 2 0213 '
.		'2 0302 2 0305 2 0311 2 0314 5 0401 3 0404 4 0408 3 0412 4 0415 '
.		'2 0503 2 0507 2 0509 2 0513 4 0602 3 0606 3 0610 4 0614 '
.		'3 0701 2 0705 2 0711 4 0715 4 0804 4 0812 3 0901 2 0905 2 0911 3 0915 '
.		'4 1002 3 1006 3 1010 4 1014 2 1103 2 1107 2 1109 2 1113 '
.		'5 1201 3 1204 4 1208 3 1212 5 1215 2 1302 2 1305 2 1311 2 1314 '
.		'5 1403 4 1406 4 1410 2 1413 5 1504 3 1507 3 1509 5 1512 '

init.bonus.1
	s len(1) . b ' ' len(2) . row len(2) . col ' ' =	:f(init.bonus.next)
	output = 'init.bonus  row ' row '  col ' col '  b ' b
	g.bonus[+row,+col] = +b					:(init.bonus.1)
init.bonus.next
	g.bonus.lines = lines(g.bonus)				:(return)
init.bonus.end

	define('init.dict(filename,skip)file,n,w,s')		:(init.dict.end)

*	Initialize the global dictionary g.dict.
*	g.wwf is list of words not in enable1.txt word list but known to be accepted as valid by wwf.

	g.wwf = 'qi brr zen zep ' 'dave shields '

init.dict

*	Read in a dictionary from a specified file, with one word per line. If 'skip'
*	is non-zero then that number of lines are skipped before adding the next word.
*	This assists the use of smaller dictionaries for testing.

	filename = ident(filename) '../dict.txt'
	skip = (ident(skip) +1, +skip)
	g.dict = table(100000)

*	add words from g.wwf list to dictionary

	s = g.wwf
init.dict.wwf.1
	s break(' ') . w ' ' =				:f(init.dict.wwf.2)
	g.dict[w] = +1					:(init.dict.wwf.1)
init.dict.wwf.2

	input(.file,3,filename)				:s(init.dict.in)
	output = 'unable to open input file ' filename	:(freturn)
	n = 0
init.dict.in
	w = file					:f(init.dict.done)
	gt(size(w),15)					:s(init.dict.in)
	g.dict[w] = +1
	eq(skip,1)					:s(init.dict.in)
*	here want to skip over entries in the dictionary (for testing)
	n = skip
init.dict.skip
	w = file					:f(init.dict.done)
	gt(n = n - 1,0)					:s(init.dict.skip)f(init.dict.in)
init.dict.done
	endfile(3)					:(return)
init.dict.end

	define('init.perm(filename)line,ifile,n,k,lines')	:(init.perm.end)

*	Initialize the list of possible permutations from a file.

init.perm
	g.permutations = table(100)
	input(.ifile,4, filename)			:s(init.perm.1)
	output = 'unable to open permutation file ' filename 	:(freturn)
*	read first line and merge to process permutation description line
	line = ifile					:f(init.perm.done)s(init.perm.2)
	lines = 1
init.perm.1
	line = ifile					:f(init.perm.done)
	lines = lines + 1
init.perm.2
	line '; ' break('?') . n '?' break(' ') . k ' ' rem . count :f(init.perm.err)
init.perm.k
	line = ifile					:f(init.perm.done)
	lines = lines + 1
*	add blank at end of list to simplify later iterations over the list
	g.permutations[n '?' k] = line ' '		:(init.perm.1)
init.perm.done
	endfile(4)					:(return)
init.perm.err
	output = 'init.perm error, line ' lines '  '  line :(freturn)
init.perm.end

	define('init.tileset()s,n')			:(init.tileset.end)

* 	Initialize set of tiles, ignoring the 'blank' tiles for now.
*	Initialize value map from letters to value, ignoring ' ' for now

init.tileset
	s = 'a 9 b 2 c 2 d 5 e 13 f 2 g 3 h 4 i 8 j 1 k 1 l 4 m 2 n 5 o 8 p 2 q 1 r 6 s 5 t 7 u 4 v 2 w 2 x 1 y 2 z 1 '
	g.tileset =
init.tileset.1
	s break(' ') . c ' ' break(' ') . n ' ' =	:f(return)
	g.tileset = g.tileset dupl(c,n)			:(init.tileset.1)
init.tileset.end

	define('init.value()s,c')			:(init.value.end)
init.value
	g.value = table(52)
	s = &lcase &ucase

*	Assume value of a tile is one, and correct that below.

init.value.next
*	assume value is 1
	s len(1) . c =					:f(init.value.letters)
	g.value[c] = +1					:(init.value.next)

init.value.letters
	s = 
.	'b 4 c 4 d 2 f 4 g 3 h 3 j 10 k 5 l 2 m 4 n 2 p 4 q 10 u 2 v 5 w 4 x 8 y 3 z 10 '
.	'B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 '
init.value.update
*	update assumptions for letters with value greater than one.
	s break(' ') . c ' ' break(' ') . v ' ' =	:f(return)
	g.value[c] = +v					:(init.value.update)
init.value.end

	define('insert(mov,str)i,count,free')		:(insert.end)

*	Insert the characters in *str* into the available empty cells of *chars* in the move *mov*.

insert
	insert = unpack(id(mov))
	free = free(mov)
	count = count(mov)
insert.1
	gt(i = i + 1,count)				:(return)
	insert[free[i]] = substr(str,i,1)		:(insert.1)
insert.end

	define('isword(word,words)')			:(isword.end)

*	Words is a map on words. Succeeds if words is defined for the specified word,
*	fails otherwise.
isword
	differ(words[word])				:s(return)f(freturn)

isword.end

	define('last(string)w')				:(last.end)

*	Return index of last space in string, or null if no space in string

last
	last = first(reverse(line))			:f(freturn)
	last = 16 - last				:(return)
last.end

	define('less(str,ch)before,after')		:(less.end)

*	Removes the first instance of character ch in str.

less
	ident(str)					:s(return)
	str break(ch) . before len(1) rem . after	:f(less.1)
	less = before after				:(return)
less.1
	less = ident(substr(s,1,1),ch) substr(s,2)	:s(return)
	less = str					:(return)
less.end

	define('grid(lines,start)i,r,c,line')			:(grid.end)

*	Construct a grid from a sequence of lines beginning at index *start* (1..15 for rows, 16..30 for columns).
	gt(start,15)
	gt(start,15)

grid
	grid = array('15,15',' ')
	gt(start,15)					:(grid.cols)

*	Here to build grid from set of horizontal rows.

	r = 0; i = 0

grid.1
	gt(r = r + 1,15)				:s(return)
	line = lines[r]					:f(grid.3)
	i = 0
grid.2
	grid[r,i = i + 1] = substr(line,i,1)		:(grid.2)
grid.3

*	Here to build the columns from the updated rows.

	c = 0; i = 0
grid.4  
	gt(c = c + 1,15)				:s(return)
	i = 0
grid.5
	grid[i = i + 1,c] = substr(line,i,1)		:(grid.5)
grid.end
	define('lines(grid)i')				:(lines.end)

*	Express the grid as a sequence of lines, with the first 15 consisting of the rows
*	and the last 15 consisting of the columns.

lines
	lines = array(30)
lines.next
	gt(i = i + 1,15)				:s(return)
	lines[i] = hline(grid,i)
	lines[i + 15] = vline(grid,i)			:(lines.next)
lines.end

	define('open(tiles)best.score,best.word,n,w,start')	:(open.end)

*	Determine best opening move. At least one letter in this move must be in the center square (8,8).
*	The only bonus available is double word, for any word of more than four characters.
*
*	The return value has the form 'm s' where m is the move and s is its score.
*
*	There are seven tiles, so we just try all permutations of length one up to seven.

open
	n = 0;* number of tiles to play
	best = 0;* best score
	start = 8;* assume word will start in column 8

open.1	le(n = n + 1,7)					:f(open.finish)
	perms = permutations(tiles,n)
open.2
*	get next word, check that valid, then see if new high score
	perms break(' ') . w ' ' =			:f(open.1)
	permwords = permwords + 1
	checkword(w)					:f(open.2)
	checkwords = checkwords + 1
	le(oscore(w),best.score)			:s(open.2)
	best.word = w
	best.score = oscore(w)
	open = lt(size(best.word),6) 'h0808' best.word ' ' best.score	:s(open.2)
*	Here if longer open word, move a space to the left
	start = 7
	open = 'h0807' best.word ' ' best.score		:(open.2)
open.finish						
	n = 0
open.finish.1
	gt(n = n + 1,size(best.word))			:s(return)
	g.board[8,start - 1 + n] = substr(best.word,n,1)		
							:(open.finish.1)
open.end

	define('oscore(word)i,c')			:(oscore.end)

*	Compute the score of an initial word, which is always played horizontally starting at the center 
*	square (row=8, column = 8).
oscore
	word len(1) . c =				:f(oscore.finish)
	oscore = oscore + g.value[c]			:(oscore)
oscore.finish
*	Double word score if length greater than four, so bonus at (8,12) is achieved.
	lt(size(word),5)				:s(return)
	oscore = oscore + oscore			:(return)
oscore.end

	define('permutations(s,k,d)')			:(permutations.end)

*	Return permutations of s taken k at a time.

permutations
	permutations = g.permutations[size(s) '?' k]		:f(freturn)
	d = substr('1234567',1,size(s))
	permutations = replace(permutations,d,s)			:(return)
permutations.end

	define('pack(chars),c,i')			:(pack.end)

*	Pack an array of characters into a line

pack
	pack = 	chars[1] chars[2] chars[3] chars[4] chars[5]
.		chars[6] chars[7] chars[8] chars[9] chars[10]
.		chars[11] chars[12] chars[13] chars[14] chars[15]
pack.end

	define('place(num)line,alone,nopen,ai,first,max,n,last,nplaces')	:(place.end)

*	Find all the places where a move can be made in the line specified by *num*. *num* values from 1 .. 30

place
	place = table()
	line = g.board.lines[num]
	g.line = line
	alone = g.alone.lines[num]

*	Allocate and fill in avail, an array giving the positions of the open cells.

	g.avail = available(line)				:f(return);* fail if no empty cells
	nopen = prototype(g.avail);* number of open cells

*	Prepare for loop, since decrement nopen at start of search at a given empty cell.

	nopen = nopen + 1
	ai = 0

place.next
*	Here to find all the possible moves starting at the next open cell, first.

	first = g.avail[ai = ai + 1]			:f(place.done)

	nopen = nopen - 1;* count down since we are accounting for this open cell in this pass through the loop.
	le(nopen)					:s(return)

*	Let max be the most tiles we can play on this line. We can't play more tiles than the number of 
*	blank cells in this line, and we can't play more tiles than we have.

	max = nopen
	max = gt(max,size(g.rack)) size(g.rack)

	n = 0

place.next.n
	gt(n = n + 1,max)				:s(place.next)

	last = g.avail[ai + n - 1];			:f(place.fail)

*	Skip this move if all its cells are alone.

	substr(alone, first, last - first + 1) break(' '):f(place.next.n)

*	Add cell to candidate list, as triple (first cell, last cell,number of cells to play)

	place[nplace = nplace + 1] = move(num,n,subarray(g.avail,ai,n))	:(place.next.n)

place.done
							:(return)
place.end

	define('placeword(r,c,w)ch')			:(placeword.end)


*	Add a word to the board (used for testing)
placeword
	c = c - 1
placeword.1
	w len(1) . ch =					:f(return)
	g.board[r, c = c + 1] = ch
*	Mark self and adjoining squares as no longer alone
	g.alone[r,c] = ' '    ;* self
	g.alone[r - 1,c] = ' ';* cell to the north
	g.alone[r,c + 1] = ' ';* cell to the east
	g.alone[r,c - 1] = ' ';* cell to the west
	g.alone[r + 1,c] = ' ';* cell to the south
							:(placeword.1)
placeword.end

	define('prefix(str,pre)word')			:(prefix.end)
prefix

*	Prefix takes a list of space-separated words str and prefixes each
*	with the string pre.

	str = str ' ';* so each word followed by space
prefix.1
	str break(' ') . word span(' ')  =		:f(return)
	prefixcount = prefixcount + 1
	prefix = add(prefix, pre word)			:(prefix.1)
prefix.end

	define('random(n)')

*	Return integer uniformly distributed in 1,2,...,n. If n=0 returns real uniformly distributed
*	in the interval [0,1].
*	The Algorithm is based in that in section 16.1 of "Algorithms in SNOBOL4," James F. Gimpel, John Wiley and Sons, 1976.

*	Gimpel uses integer here, but need to have real.
	random_var = convert(1,'real')

							:(random.end)
random	random_var = remdr(random_var * 4676, 414971)

	random  = random_var / 414971
	random = ne(n,0) convert(random * n,'integer') + 1
							:(return)
random.end

	define('random_rack()i')				:(random_rack.end)

*	Return random set of seven tiles from the initial set of tiles.
*	This is used for testing.

random_rack
	gt(i = i + 1,7)					:s(return)
	random_rack = random_rack substr(g.tileset,random(size(g.tileset)),1)	:(random_rack)
random_rack.end

	define('score(lines)line,word,words,start,wi,ch,i,bonus,wscore,double,triple,val')	:(score.end)

*	Compute the score of a move. All the letters of the move will be in upper case on the board
*	so the score of the move is the sum of the scores of all the words with upper case letters in them, for
*	both rows and columns


score
	line = lines[i = i + 1] ' '			:f(return)
	output = 'score ' line
	line break(&ucase)				:f(score)
	start = 1
	output = 'score ' i ' ' line
	words = words(line)
	output  = 'words proto ' prototype(words)
score.next
	start = words[wi = wi + 1,1]			:f(score)
	word = words[wi,2]
	output = 'score.next ' word '.'

*	Single letters don't contribute to score since the come from intersecting line.

	eq(size(word),1)				:s(score.next)
	output = 'word 1 ' word
	word break(&ucase)				:f(score)
score.find.done
	output = 'line.done  start ' start ' line ' line '.'
	line = substr(line,start)
	bonus = substr(g.bonus.lines[i],start) 
	output = 'score line  ' line
	output = 'bonus line  ' bonus
	wscore = 0; double = 0; triple = 0
*SCOR
score.nextch
	word len(1) . ch =				:f(score.word)
	bonus len(1) . b
	val = +g.value[ch]
	output = 'WSCORE- '  ch '  ' wscore
	output = 'score ch ' ch '   val ' val '  double ' double '  triple ' triple '  bon:' bon ':'
	wscore = ident(bon,' ') wscore + 1		:s(score.nextch);* default is one point per letter
	bon = +bon
	output = 'WSCORE0 ' wscore
	output = ' score ' wscore
	wscore = eq(bon,1) wscore + val + val		:s(score.nextch);* double letter	
	output = 'WSCORE1 ' wscore
	output = '  score ' wscore
	wscore = eq(bon,2) wscore + val + val + val	:s(score.nextch);* triple letter
	output = 'WSCORE2 ' wscore
	output = '   score ' wscore
	output = 'predouble ' wscore 
	double = eq(bon,3) double + 1			:s(score.nextch);* double word
	output = 'WSCORE3 ' wscore
	output = '    score ' wscore
	triple = eq(bon,4) triple + 1			:s(score.nextch);* triple word
	output = 'WSCORE4 ' wscore
	output = '     score ' wscore
							:(score.nextch)
score.word
	output = 'double ' double '  triple ' triple
	output = 'score.word start ' wscore
	wscore = eq(double) eq(triple) wscore + val;* if not double or triple word bonus
*	May have two double or triple word bonus squares in a line
	wscore = ne(double) 2 * wscore;* double word(s)
	wscore = eq(double,2) 2 * wscore;* double word(s)
	wscore = ne(triple) wscore * 3;* triple word
	wscore = eq(triple,2) wscore * 3;* triple word
	output = 'score.word end   ' wscore
	score = score + wscore				:(score.next)
score.end

	define('subarray(ara,start,len)i')		:(subarray.end)

*	Like substr, but returns the sub-array of *ara* starting at element *start* and
*	consisting of *len* elements

subarray
	subarray = array(len)
subarray.1
	gt(i = i + 1,len)				:s(return)
	subarray[i] = ara[start + i - 1]		:(subarray.1)		
subarray.end

	define('ucase(s)')				:(ucase.end)

*	Convert argument converted to upper case

ucase
	ucase = replace(s,&lcase,&ucase)		:(return)
ucase.end
	
	define('unpack(line),c,i')			:(unpack.end)

*	Unpack the characters of line to array of characters.

unpack
	unpack = array(15)
unpack.1
	line len(1) . c =				:f(return)
	unpack[i = i + 1] = substr(line,i,1)		:(unpack.1)
unpack.end

	define('vline(grid,c)')				:(vline.end)

*	Return the vertical line of a grid corresponding to column c as a string.

vline
	vline = grid[1,c] grid[2,c] grid[3,c] grid[4,c] grid[5,c] 
.		grid[6,c] grid[7,c] grid[8,c] grid[9,c] grid[10,c]
.		grid[11,c] grid[12,c] grid[13,c] grid[14,c] grid[15,c]
	out
							:(return)
vline.end

	define('wordcount(s)i,w')				:(wordcount.end)

*	Return number of words in s, fail if no words

wordcount
	s break(&ucase &lcase)					:f(freturn)
	s = s  ' '
	wordcount = 0
wordcount.1
	s break(' ') . w span(' ') =			:f(return)
	wordcount = wordcount + 1				:(wordcount.1)
wordcount.end

	define('words(s)n,w,pos')					:(words.end)

*	Return array of the words in s, fail if no words.
*	The first entry for an array is the starting index,
*	the second entry is the word itself.

words
	n = wordcount(s)					:f(freturn)
	s = s ' '
	words = table(n)
	pos = 1;* first word has no preceding space.
words.1
*	Replace the blank with ? 
	s break(' ') . w ' ' = 					:f(words.done)
	words[pos] = w					
	pos = pos + size(w) + 1;* set to start of next word
								:(words.1)
words.done
	words = convert(words,'array')				:(return)
words.end
	
	define('best(rack)i,chars,line,places,p,first,last,mov,n,perm,saveline,i)')		:(best.end)

*	Determine best move given current position on the board and rack.

best
	
	g.board.lines = lines(g.board)
	g.alone.lines = lines(g.alone)
	chars = array(15); 

best.line

	line = g.board.lines[num = num + 1]		:f(best.done)		


	i = 0
	line = g.board.lines[num];* recover line
	
*	Find all the places that tiles can be put.

	places = convert(place(num),'array')
	p = 0
best.next
	mov = places[p = p + 1,2]
	output = 'id ' lpad(id(mov),4) char(9) lpad(count(id),4) char(9) free(mov)[1] ':' free(mov[count])
*	Save the current line so can restore to it as needed
	move.line = g.board.lines[num]
	perm = g.permutations(size(rack),n)		:f(move.error)
*	perm = replace(perm,'1234567',rack)
	try(mov,perm)
	
*	Iterate over the permutations for this set of placements
	
best.perm.next
	perm break(' ') . p ' ' =			:f(best.perm.done)
*	Now substitute tiles from permutation into the empty cells for this move
best.perm
best.end

*	try(mov,perm)

	define('try(mov,perm)n,num,first,free,perms,oldlines,i,ci,perm,,newline,board,')		:(try.end)

*	Given a move *mov* and a list *permutations* of permutations to be tried for the move,
*	try all the moves than can be made, see which are valid, and add their scores to g.scores

try
	n  = count(mov)
	num = id(mov)
	first = free(mov)[1]
	perms = g.permutations(size(g.rack),n)
	perms = replace(perm,substr('1234567',1,n),substr(g.rack,1,n))
	oldlines = copy(g.board.lines[num])

	i = first - 1; ci = 0
try.next
	perms break(' ') . perm ' ' =		:f(try.done)

*	Insert the digits from this permutation into the selected blank cells in the line. 
*	The digit '1' selects the first tile, the digit '2' the second, and so on.

	newline = pack(insert(mov,perm))

*	Here with choice substituted. Now rebuild the line and see if it is valid.

	checkline(newline)					:f(try.next)

*	NOTE We don't have to check all the lines, just the ones that are affected. For example if tiles are 
*	placed in rows 3, in positions 5-8, then only need check row 3 and columns 5-8.

	newlines = copy(oldlines)
	newlines[num] = newline
	board = grid(newlines,num)
*	For now, check the whole grid, after updating to reflect the new row (or column).
	newlines = lines(board)

*	The new line is valid. Now see if all other lines are still valid
	i = 0
try.line.next
	gt(i = i + 1,30)				:s(try.valid)
	eq(i,num)					:s(try.line.next);* have already checked this line
	checkline(newlines[i])				:f(try.invalid)s(try.line.next)

try.invalid

*	Here if new line not valid, ...
							:(try.next)

try.valid

*	Here if valid move. Compute its score.
*	In order to determine which words on the board would be formed by making this move,
*	rebuild the board but with the new tiles in uppercase. This way, a word is new if and only if
*	it contains an upper case character. 

	g.board.lines[num] = oldline;
	newline = pack(insert(mov,ucase(substr(g.rack,1,n))))
	newlines[num] = newline
	board = grid(newlines,num)
	newlines = lines(board)
*	Eventually, in next part, will just visit lines that may have changed, and add up their scores.
	g.scores[mov] = score(newlines)
							:(try.next)
try.end
	
MAIN
*	Test place()
	output = 'test place'

	&anchor = &trim = 1
*	&ftrace = 1000
*	&dump = 3

	init(,1000)

	display()
	g.rack = 'catnose'


	placeword(1,4,'SHIELDS')

	g.board.lines = lines(g.board)
	g.alone.lines = lines(g.alone)
	
	display()
*	display.alone()
	output = 'bonus '
	display.bonus()

	wordcount = wordcount('dave shields')
	words = words('dave shieLds')
	n = words('dave shields')
	output = wordcount 
	output = words[1,1] ':' words[1,2]
	output = words[2,1] ':' words[2,2]

	mylines = lines(g.board)
	sc  = score(mylines)
	output = 'score(1) ' sc

	g.dict = g.permutations = g.scores = g.alone = g.board = g.value = 
end
END
	output = 'place '
loop	key = ara[i = i + 1,1]				:f(loop.done)
	mov = ara[i,2]
	output = lpad(i,4) char(9)  ' id ' id(mov) char(9) '  count ' count(mov) char(9) ': ' free(mov)[1] ' :  ' free(mov)[count(mov)]
							:(loop)
loop.done
	output = 'loop.done ' i
	:(done)
finis	output = 'finis'	:(end)
done
*	output = 'permwords ' permwords '  checkwords ' checkwords '  oscoren ' oscoren
end
	tabl = place(1)
	
	ara = convert(tabl,'array')
	i = 0

	define('range(line)start,finish,i,c,p')				:(start.end)
*	Look for first instance of upper case character in line, then return that
*	indexs of the starting and ending characters in that word.

range
	line break(any(&ucase)) @ p			:f(freturn)
	chars = unpack(line)
*	loop back to find first blank or the range of the line
range.1
	c = chars[i = i - 1]				:f(range.2)
	differ(c,' ')					:s(range.1)
range.2
	start = (gt(i) i, 1)
*	loop forward to find first blank after the word of the index of the last chracter in the line
	i = p
range.3
	c = chars[i = i + 1]				:f(range.4)
	differ(c,' ')					:s(range.1)
range.4
	finish = (le(i,15) i, 15)
	range = start ':' finish			:(return)
range.end

	i = kk
	first = (gt(i) i, 1)
	first = 

	i = lt(i,1) 1;* if word starts at
	k
