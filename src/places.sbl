-include "util.sbl"


	define('occupied(kind,num)')					:(occupied.end)

*	Return a line corresponding to a board row or column with non-blank character in each position corresonding
*	to a non-blank cell. Kind is 'h' for horiztonal (row) line, 'v' for a vertical (column) line. *num* is
*	the number of the line, in range 1..15.

occupied
	occupied = dupl(' ',15)
	ident(kind,'v')							:s(occupied.v)

*	Here for horizontal line, corresponding to row *num*.


	define('place(num)avail,ai,si,nb,s')				:(place.end)

*	Find all the places where a move can be made in the line specified by *num*. *num* values from 1 .. 15
*	correspond to row *num*, while values in the range 16..30 correspond to column *num* - 15.


place
	line = (lt(num,16) hline(i), vline(i))
*	get adjacent lines
	adj1 = (lt(num,16) hline(num - 1), vline(num - 1))
	adj2 = (lt(num,16) hline(num + 1), vline(num + 1))
	s = line
	nb = 0
	places = table()
*	Find number of open cells.

place.1
	s line(1) . c =						:f(place.2)
	differ(c,' ')						:s(place.1)
	nopen = nopen + 1					:(place.1)
place.2

*	Fail if no open cells in line.

	eq(nopen,0)						:s(freturn)

*	Allocate and fill in avail, an array giving the positions of the open cells.

	avail = array(nopen)
	s = line
	si = ai = 0
place.3
	c = substr(line, si = si + 1, 1)			:f(place.4)
	differ(c,' ')						:s(place.3)
	avail[ai = ai + 1] = si					:(place.3)
place.4
	
;	lb is the index of the leftmost (first) open square, or null if none = avail[1]
;	rb is the index of the rightmost (last) open square, or null if none = avail[no]

	rb = avail[nopen]
	
	ai = 0

place.5

*	Here to find all the possible moves starting at the open cell at index ai in the line.
*	Update left boundary.
	gt(ai = ai + 1,len)					:(...)

	lb = avail[ai = ai + 1]					:f(place.?)
*	Find maximum number of tiles that can be played starting at this position
	max = nopen - ai + 1
*	But can play no more than the number of tiles at hand
	max = gt(max,size(g.rack)) size(g.rack)

*	Now try all the placements of length 1 ... max


	p = avail[lb];* starting cell
place.6
	next = 
	max = 
	nopen = nopen - 1;* number of opens that 

*	Now find all the move that can start at position lb.

;	starting at lb, try all plays of 1 ... np

;	can play no more than nopen tiles
	np = nopen
;	but there are at most seven tiles
	np = gb(nopen,7) 7
;	and can only play tiles if there is room for them
	np = lt(nopen,nr) nopen
	
	ai = 0
place.next.lb
	lb = avail[ai = ai + 1]				:s(place.finish)
*	Initial right boundary is lb, will extend as probe further
	rb = lb
	len = 0
place.next.len
	gt(len = len + 1,max)				:s(place.next.lb)
*	Here to play len tiles starting at lb
*	Check that at least one of these cells has a neighbot
	i = 0
	neighbor = 
place.neighbor	
	gt(i = i + 1, len)				:s(place.no.neighbor)
	rb = avail[i]

*	Test if preceding cell (if any) is occupied
	differ(substr(line,i - 1,1,' '))		:s(place.has.neighbor)
*	Test if following cell (if any) is occupied
	differ(substr(line,i + 1,1),' ')		:s(place.has.neighbor)
*	Test if corresponding cell in first neighbor is occupied
	differ(substr(adj1,i,1),' ')			:s(place.has.neighbor)
*	Test if corresponding cell in second neighbor is occupied
	differ(substr(adj2,i,1),' ')			:s(place.has.neighbor)
							:(place.neighbor)
place.no.neighbor
*	Here if no cell in proposed list neighbor, so increase length
							:(place.next.len)
place.has.neighbor

*	Add cell to candidate list
	place[lb ':' rb] = 1
	output= lb ':' rb
							:(place.nextlen)
place.finish
	place = tbl					:(return)
							:(place.
place.end



end
