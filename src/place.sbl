* This software is licensed under the MIT License, contained in the file LICENSE.

* Copyright (c) 2016 dave shields

-include "util.sbl"


	define('after(num)')

*	Find the line 'after' line *num*. This is either the row below or the column to the right, or
*	null if line *num* is at the edge of the board

after

	after = (eq(num,1) '', eq(num,16) '',line(num + 1))	:(return)
after.end
	
	define('before(num)')

*	Find the line 'before' line *num*. This is either the row above or the column to the left, or
*	null if line *num* is at the edgs of the board

before

	before = (eq(num,1) '', eq(num,16) '',line(num - 1))	:(return)
before.end
	
*	define('occupied(kind,num)')					:(occupied.end)

*	Return a line corresponding to a board row or column with non-blank character in each position corresonding
*	to a non-blank cell. Kind is 'h' for horiztonal (row) line, 'v' for a vertical (column) line. *num* is
*	the number of the line, in range 1..15.

*occupied
*	occupied = dupl(' ',15)
*	ident(kind,'v')							:s(occupied.v)
*
*	Here for horizontal line, corresponding to row *num*.
*
*occupied.end

	define('place(num)avail,ai,si,nb,s')				:(place.end)

*	Find all the places where a move can be made in the line specified by *num*. *num* values from 1 .. 30


place
	line = g.lines(num)
	output = 'enter place num ' num ' line ' line '.'
*	get adjacent lines
	after = after(num)
	before = before(num)
	s = line
	place = table()
*	Find number of open cells.

place.1
	s len(1) . c =						:f(place.2)
	differ(c,' ')						:s(place.1)
	nopen = nopen + 1					:(place.1)
place.2

*	Fail if no open cells in line.

	eq(nopen,0)						:s(freturn)

	output = 'place num ' num ' nopen ' nopen ' ' before ':' after ':' 
*	Allocate and fill in avail, an array giving the positions of the open cells.

	avail = array(nopen)
	s = line
	si = ai = 0
place.3
	c = substr(line, si = si + 1, 1)			:f(place.4)
	differ(c,' ')						:s(place.3)
	avail[ai = ai + 1] = si					:(place.3)
place.4
	
*	lb is the index of the leftmost (first) open square, or null if none = avail[1]
*	rb is the index of the rightmost (last) open square, or null if none = avail[no]

	rb = avail[nopen]
	
	ai = 0

place.next

*	Here to find all the possible moves starting at the open cell at index ai in the line.
*	Update left boundary.
	gt(ai = ai + 1,len)					:s(place.finish)
	lb = avail[ai]	

*	Find maximum number of additional tiles that can be played starting at this position

	nopen = nopen - 1;* account for playing a tile at *lb*.

	max = nopen
*	But can play no more than the number of tiles at hand
	max = gt(max,size(g.rack)) size(g.rack)

*	Now try all the placements of length 1 ... max

place.6
*	starting at lb, try all plays of 1 ... np

*	can play no more than nopen tiles
	np = nopen
*	but there are at most seven tiles
	np = gb(nopen,7) 7
*	and can only play tiles if there is room for them
	np = lt(nopen,nr) nopen
	
	ai = 0
place.next.lb
	lb = avail[ai = ai + 1]				:s(return)
	nopen = nopen - 1
*	Initial right boundary is lb, will extend as probe further
	rb = lb
	n = 0
place.next.n
	gt(n = n + 1,max)				:s(place.next.n)
*	Here to play len tiles starting at lb
*	Check that at least one of these cells has a neighbot
	i = 0
	neighbor = 

*	We say a cell has a friend if an adjoining cell has been part of previous move.
*	For a move to be valid, at least one character in the word must have a friend.

place.friend	
	gt(i = i + 1, len)				:s(place.no.friend)

*	Test if preceding cell (if any) is occupied

	differ(substr(line,i - 1,1,' '))		:s(place.has.friend)


*	Test if following cell (if any) is occupied

	differ(substr(line,i + 1,1),' ')		:s(place.has.friend)

*	Test if corresponding cell in line before is occupied.

	differ(substr(before,i,1),' ')			:s(place.has.friend)

*	Test if corresponding cell in line after is occupied.

	differ(substr(after,i,1),' ')			:s(place.has.friend)
							:(place.friend)
place.no.friend
*	Here if no cell in proposed list has friend, so increase length
							:(place.next.len)
place.has.friend

*	Add cell to candidate list
	output = 'placing ' lb ':' rb
	place[lb ':' rb] = 1
	output = lb ':' rb
							:(place.next.n)
place.end

*	Test place()

	&anchor = &trim = 1
*	&ftrace = 1000
	&dump = 3

	init(,1000)
	output = 'start place test'
	placeword(8,2,'dave')
	placeword(8,8,'shields')
	display()

	g.lines = lines()
	tbl = place(8)

	ara = sort(tbl)
loop	key = ara[i = i + 1,1]				:f(done)
	output = key					:(loop)
done
	output = 'permwords ' permwords '  validwords ' validwords '  oscoren ' oscoren
	g.dict = g.permutations =
end
