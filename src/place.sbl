*	define('place(num)avail,ai,si,nb,s')				:(place.end)
	define('place(num)')				:(place.end)

*	Find all the places where a move can be made in the line specified by *num*. *num* values from 1 .. 30


place
*	output = 'place num ' num
	line = g.lines[num]
	output = 'enter place num ' num ' line ' line '.'
*	get adjacent lines
	after = after(num)
	before = before(num)
	s = line
	place = table()
*	Find number of open cells.
	nopen = blanks(line)

*	Fail if no open cells in line.

	eq(nopen,0)						:s(freturn)

	output = 'place num ' num ' nopen ' nopen ' ' before ':' after ':' 
*	Allocate and fill in avail, an array giving the positions of the open cells.

	avail = array(nopen)
	s = line
	si = ai = 0
place.3
	c = substr(line, si = si + 1, 1)			:f(place.4)
	differ(c,' ')						:s(place.3)
	avail[ai = ai + 1] = si					:(place.3)
place.4
	
*	lb is the index of the leftmost (first) open square, or null if none = avail[1]
*	rb is the index of the rightmost (last) open square, or null if none = avail[no]

	rb = avail[nopen]
	
	ai = 0

place.next

*	Here to find all the possible moves starting at the open cell at index ai in the line.
*	Update left boundary.
	gt(ai = ai + 1,len)					:s(place.finish)
	lb = avail[ai]	

*	Find maximum number of additional tiles that can be played starting at this position

	nopen = nopen - 1;* account for playing a tile at *lb*.

	max = nopen
*	But can play no more than the number of tiles at hand
	max = gt(max,size(g.rack)) size(g.rack)

*	Now try all the placements of length 1 ... max

place.6
*	starting at lb, try all plays of 1 ... np

*	can play no more than nopen tiles
	np = nopen
*	but there are at most seven tiles
	np = gb(nopen,7) 7
*	and can only play tiles if there is room for them
	np = lt(nopen,nr) nopen
	
	ai = 0
place.next.lb
	lb = avail[ai = ai + 1]				:s(return)
	nopen = nopen - 1
*	Initial right boundary is lb, will extend as probe further
	rb = lb
	n = 0
place.next.n
	gt(n = n + 1,max)				:s(place.next.n)
*	Here to play len tiles starting at lb
*	Check that at least one of these cells has a neighbot
	i = 0
	neighbor = 

*	We say a cell has a friend if an adjoining cell has been part of previous move.
*	For a move to be valid, at least one character in the word must have a friend.

place.friend	
	gt(i = i + 1, len)				:s(place.no.friend)

*	Test if preceding cell (if any) is occupied

	differ(substr(line,i - 1,1,' '))		:s(place.has.friend)


*	Test if following cell (if any) is occupied

	differ(substr(line,i + 1,1),' ')		:s(place.has.friend)

*	Test if corresponding cell in line before is occupied.

	differ(substr(before,i,1),' ')			:s(place.has.friend)

*	Test if corresponding cell in line after is occupied.

