* tThis software is licensed under the MIT License, contained in the file LICENSE.

* Copyright (c) 2016 dave shields

*	Global Variables

*	Here are the global variables. Each has a name starting with 'g.' Their initial value is set in the
*	procedure *init()*.

*	A play is a sequence of one or more cells, represented as an array.  The cells are ordered
*	from left to right for a horizontal play, top to bottom for a vertical play.


*	g.alone, array('15,15') tracks the *alone* cells in the board. A cell is *alone* if it is empty and all its
*	neighbors are empty. A move made after the first move cannot consist only of cells that are alone. 
*	That is, at least one tile in a valid move must be adjacent to a tile played in a previous move.
*	g.board, array('15,15'), the playing board. Each entry is blank (' ') for unplayed cell, or is the letter played.

*	g.alone.lines, array(30), is the array of lines defined by the rows and columns of the alone grid.

*	g.bonus.lines,array(30), is the array of lines corresponding to g.bonus

*	g.dict, array(15), is an array of hashtables  that are non-null for words in the dictionary.

*	g.empty.board is a copy of the initial g.board (a board with no cells occupied).

*	g.found counts number of valid moves that were found.
	
*	g.lines, array(30), is the array of the lines defined by the rows and columns in the board. 

*	A move is a sequence of empty cells in a row or column such that at least one cell in the sequence 
*	is adjacent to an already occupied cell:
*		*id* gives the line number, in the range 1..30;
*		*count* is the number of free cells covered by this move;
*		*free* is an array of dimension *count* giving the empty cells to be filled by this move;
*		*text* is the string of tiles of the move; and
*		*points* is the number of points won by playing this move.

*	A player is represented 

	data('player(name,rack,total,moves)')

*	where
*		name is the player's name
*		rack is the player's rack
*		score is the player's current score
*		moves counts the number of moves made by the player
	

*	g.bonus,array(15,15) gives the bonus values for the squares on the board:
*		1 for the value of the letter itself,
*		2 for double letter,
*		3 for triple letter, 
*		4 for double word, and
*		5 for triple word.

	data('move(id,count,free,text,points,perm,fid)')

*	A paired line consists of a line number and an associated line. It is used when it is necessary
*	to pass a line of text to a procedure along with line number from where it was derived.

		data('pair(num, line)')

*	g.turn, the number of the current turn
*	g.lastmove, the turn when the last move was made.

	g.turn = g.lastmove = 0

*	g.permutations, a table of the permutations of n=1..7 things taken 1..k at a time.
*	For example, g.perms['7?3'] is permutations of 1..7 taken 3 at a time, as a string with
*	entries separated by a space.

*	g.permutations.count, a table giving the number of permutations of for a given *n* and *k*.

*	g.rack, a string containing the current rack. Plays are made using the characters from the rack.

*	g.random_var is used by random() to compute the next pseudo-random value.
*	Gimpel uses integer here, but need to have real.

	g.random_var = 1

*	g.showscore is used to enable tracing of scoring by setting it to nonzero value

	g.showscore =

*	g.tiles, a string containing all the characters in the initial bag of characters.

*	g.trace, if not null, begin tracing at the start of move g.trace.

	g.trace = 22
	g.trace =

*	g.tracing, set nonzero when tracing initiated by *g.trace* begins.

*	g.value, a map from characters to the tile value of that character.

	&anchor = &trim = 1

*	Utility functions

	define('init(dictfile,skip)c,i,j,s,t')		:(init.end)

*	Initialize global variables.

*INIT*
init
	init.main(dictfile,skip)			:(return)

*	Free up code for initializers now that no longer needed.

	init.bonus = init.main = init.dict = init.tileset = init.value = 	:(return)
init.end

	define('init.main(dictfile,skip)c,i,j,s,t')	:(init.main.end)

*	Initialize global variables.

init.main
	g.dict = array(15)
	g.board = array('15,15',' ')
	g.empty.board = copy(g.board)
	g.lines = lines(g.board)

	g.alone = array('15,15','1')
	g.alone.lines = lines(g.alone)

	init.bonus()

*	Initialze permutation map.

	init.perm('../perm.txt')

	init.tileset()
	shuffle();* shuffle the tileset

	init.value()

	init.dict(dictfile,skip)
							:(return)
init.main.end

	define('init.bonus()s,row,col,b,c')		:(init.bonus.end)

*	Initialize the bonus squares for the 15x15 grid: 
*		1 for the value of the letter,
*		2 for double letter,
*		3 for triple letter,
*		4 for double word, and
*		5 for triple word.

*INIT.BONUS*
init.bonus
	g.bonus = array('15,15',+1)
	s = 	'5 0104 3 0107 3 0109 5 0112 2 0203 4 0206 4 0210 2 0213 '
.		'2 0302 2 0305 2 0311 2 0314 5 0401 3 0404 4 0408 3 0412 4 0415 '
.		'2 0503 2 0507 2 0509 2 0513 4 0602 3 0606 3 0610 4 0614 '
.		'3 0701 2 0705 2 0711 4 0715 4 0804 4 0812 3 0901 2 0905 2 0911 3 0915 '
.		'4 1002 3 1006 3 1010 4 1014 2 1103 2 1107 2 1109 2 1113 '
.		'5 1201 3 1204 4 1208 3 1212 5 1215 2 1302 2 1305 2 1311 2 1314 '
.		'5 1403 4 1406 4 1410 2 1413 5 1504 3 1507 3 1509 5 1512 '

init.bonus.1
	s len(1) . b ' ' len(2) . row len(2) . col ' ' =	:f(init.bonus.next)
	g.bonus[+row,+col] = +b					:(init.bonus.1)
init.bonus.next
	g.bonus.lines = lines(g.bonus)				:(return)
init.bonus.end

	define('init.dict(filename,skip)file,i,n,w,s')		:(init.dict.end)

*	Initialize the global dictionary g.dict.

*INIT.DICT*
init.dict

*	Set hash table sizes according to output of ../study/gendict.sbl

	s  = '1 100 1000 4000 9000 15000 23000 28000 25000 20000 15000 11000 8000 5000 3000 '
init.dict.tbl
	gt(i = i + 1,15)				:s(init.dict.tbl.1)
	s break(' ') . n ' ' = 
	g.dict[i] = table(+n)				:(init.dict.tbl)
init.dict.tbl.1
	i = 0


*	Read in a dictionary from a specified file, with one word per line. If 'skip'
*	is non-zero then that number of lines are skipped before adding the next word.
*	This assists the use of smaller dictionaries for testing.

	filename = ident(filename) '../dict.txt'
	skip = (ident(skip) +1, +skip)

	input(.file,3,filename)				:s(init.dict.in)
	output = 'unable to open input file ' filename	:(freturn)
	n = 0
init.dict.in
	w = file					:f(init.dict.done)
	gt(size(w),15)					:s(init.dict.in)

*	Process plural words, indicated by 'S' at end

	differ(substr(w,size(w),1),'S')			:s(init.dict.w)
	w = substr(w,1,size(w) - 1)
	g.dict[size(w)][w] = +1
	g.dict[size(w) + 1][w 's'] = +1			:(init.dict.in)
init.dict.w
	g.dict[size(w)][w] = +1
	eq(skip,1)					:s(init.dict.in)
*	here want to skip over entries in the dictionary (for testing)
	n = skip
init.dict.skip
	w = file					:f(init.dict.done)
	gt(n = n - 1,0)					:s(init.dict.skip)f(init.dict.in)
init.dict.done
	endfile(3)					:(return)
init.dict.end

	define('init.perm(filename)line,ifile,n,k,lines,nread')	:(init.perm.end)

*	Initialize the list of possible permutations from a file.

*INIT.PERM*
init.perm
	g.permutations = table(7)
	g.permutations.count = table(100)
	input(.ifile,4, filename)			:s(init.perm.next)
	output = 'unable to open permutation file ' filename 	:(freturn)
init.perm.next
	line = ifile					:f(init.perm.done)
	line break('?') . n '?' break(' ') . k ' ' rem . count :f(init.perm.err)
	g.permutations.count[n '?' k] = count
	ara = array(count)
	ai = 0
init.perm.array
	ara[ai = ai + 1] = ifile			:s(init.perm.array)
	g.permutations[n '?' k] = ara			:(init.perm.next)
init.perm.done
	endfile(4)					:(return)
init.perm.err
	output = 'init.perm error, line ' lines '  '  line :(freturn)
init.perm.end

	define('init.tileset()ch,n,s')			:(init.tileset.end)

* 	Initialize set of tiles, ignoring the 'blank' tiles for now.
*	Initialize value map from letters to value, ignoring ' ' for now

*INIT.TILESET*
init.tileset
	s = 'a 9 b 2 c 2 d 5 e 13 f 2 g 3 h 4 i 8 j 1 k 1 l 4 m 2 n 5 o 8 p 2 q 1 r 6 s 5 t 7 u 4 v 2 w 2 x 1 y 2 z 1 '
	g.tiles =
init.tileset.ch
	s break(' ') . ch ' ' break(' ') . n ' ' =	:f(return)
	g.tiles = g.tiles dupl(ch,n)			:(init.tileset.ch)
init.tileset.end

	define('init.value()s,c')			:(init.value.end)
*INIT.VALUE*
init.value
	g.value = table(52)
	s = &lcase &ucase

*	Assume value of a tile is one, and correct that below.

init.value.next
*	assume value is 1
	s len(1) . c =					:f(init.value.letters)
	g.value[c] = +1					:(init.value.next)

init.value.letters
	s = 
.	'b 4 c 4 d 2 f 4 g 3 h 3 j 10 k 5 l 2 m 4 n 2 p 4 q 10 u 2 v 5 w 4 x 8 y 3 z 10 '
.	'B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 '
init.value.update
*	update assumptions for letters with value greater than one.
	s break(' ') . c ' ' break(' ') . v ' ' =	:f(return)
	g.value[c] = +v					:(init.value.update)
init.value.end

	define('append(str,w,ch)')				:(append.end)

*	Append word *w* to string *str*, prefixing with *ch* if *str* is not null, using space if *ch* is null.

*APPEND*
append
	ident(w)	:s(append.fail)
	ch = ident(ch) ' '
	append = ident(str) w				:s(return)
	append = str ch w				:(return)
append.fail
	 output = 'null ch to append ' w :(end)
append.end

	define('available(line)blanks,c,i')		:(available.end)

*	Return array containing the indexes of the blank cells in line. Fails if no blanks.

*AVAILABLE*
available
	c = substr(line, i = i + 1, 1)			:f(available.1)
	differ(c,' ')					:s(available)
	blanks = blanks + 1				:(available)
available.1
	eq(blanks,0)					:s(freturn)
	available = array(blanks)
	i = ai = 0
available.2
	c = substr(line, i = i + 1, 1)			:f(return)
	differ(c,' ')					:s(available.2)
	available[ai = ai + 1] = +i				
							:(available.2)
available.end

	define('blanks(line)n')				:(blanks.end)

*	Count number of blanks in line.

*BLANKS*
blanks
	line len(1) . c =				:f(return)
	blanks = ident(c,' ') blanks + 1		:(blanks)
blanks.end

	define('bonus.lines()i')			:(bonus.lines.end)

*BONUS.LINES*
bonus.lines
	bonus.lines = array(30)
bonus.lines.next
	gt(i = i + 1,15)				:s(return)
	bonus.lines[i] = hline(g.bonus,i)
	bonus.lines[i + 15] = vline(g.bonus,i)		:(bonus.lines.next)
bonus.lines.end

	define('checkline(line)iline,word')			:(checkline.end)

*	Succeeds if all the words in the line are in the dictionary, fails otherwise.

*CHECKLINE*
checkline
	count.checkline = count.checkline + 1
	line span(' ') =
	empty(line)					:s(return)
	iline = line
	line = line ' ';* to simplify breaking out words.
checkline.1
	line span(' ') =
	ident(line)					:s(checkline.done)
	line break(' ')  . word ' ' =			:f(checkline.done);* if line exhausted
	eq(size(word),1)				:s(checkline.1)
	checkword(word)					:f(freturn)s(checkline.1)

*	output = 'checkword VALID<' word '>'  :(checkline.1)
*			:(checkline.1)

	checkword(word)					:s(checkline.1)

checkline.failed
				:(freturn)
checkline.done
*	output = gt(g.turn,21) 'checkline VALID ' iline
							:(return)
checkline.end

	define('checkword(w)')				:(checkword.end)

*	Succeeds if w is in the global dictionary, fails otherwise.

*CHECKWORD*0
checkword
	eq(size(w),1)					:s(return)
	count.checkword = count.checkword + 1
	differ(g.dict[size(w)][w])			:f(freturn)s(return)
*	differ(g.dict[size(w)][w])			:f(freturn)s(checkword.good)
checkword.bad
	output = 'invalid blank at start of checkword ' w :(end)
checkword.good
*	output =  'checkword VALID ' w			
							:(return)
checkword.end

	define('cline(lines,move,p,ch,rack)line,i,r,c')		:(cline.end)

*	Return crossing line of p-th cell in move *move*. *ch* gives tile to be played.

*CLINE*
cline
	count.cline = count.cline + 1

	gt(id(move),15)					:s(cline.col)
	r = id(move)
	c = p;* crossing line is column p.
	line = lines[c + 15];* column p
	line = (eq(r,1) '',substr(line,1,r - 1)) ch (eq(r,15) '', substr(line,r + 1)) 
*	output = 'cline ' num(move) ' p ' p '  c ' c
	cline = pair(p + 15,line)			:(cline.done)
cline.col
	r = p;* crossing line is row p
	c = id(move) - 15
	line = lines[p];* crossing line is row p.
	line = (eq(c,1) '',substr(line,1,c - 1)) ch (eq(c,15) '', substr(line,c + 1))  
*	output = 'cline ' num(move) ' p ' p '  c ' c
	cline = pair(p,line)				:(cline.done)
cline.done
*	output = 'CLINE ' show.move(move) ' p ' p  "'" ch "'" ' -> ' show.pair(cline) ' ' show.hex(line(cline))
							:(return)
cline.end


	define('cost(text)')				:(cost.end)

*	Return the cost of *text*, defined as the sum of the values of the tiles in *text*.

*COST*
cost
	text len(1) . ch =				:f(return)
	cost = cost + g.value[ch]			:(cost)
cost.end

	define('counter(text,count)')			:(counter.end)

*	Output the descriptive text *text* and value *n* of a counter.

*COUNTER*
counter
	output = lpad(text,32) lpad(count,10)		:(return)
counter.end

	define('counters()')				:(counters.end)

*	Output the collected counter metrics.

*COUNTERS*
counters
	output = 
	output = 'Performance metrics:'
	counter('placements found by scan'	, count.scanned	)
	counter('permutations examined'		, count.perm	)
	counter('cells examined'		, count.cells	)
	counter('potential moves found'		, count.moves 	)
	counter('lines checked'			, count.checkline)
	counter('words checked'			, count.checkword)
	counter('clines lines checked'		, count.cline	)
	counter('cross lines checked'		, count.cross	)
	counter('valid moves found'		, count.valid	)
							:(return)
counters.end

	define('empty(line)')				:(empty.end)

*	Test if line is empty (null or all blanks).

empty	
	line span(' ') =
	ident(line)					:s(return)f(freturn)
empty.end
	
	define('find(rack)num,lines,inlines,flines,fi,line,moves,mi,m,perms,permi,fline,tline,iline,sline,highest,lowest,i,p,score')	:(find.end)

*	Find all the valid moves and their scores given the current board and the indicated rack.
*	For each line, find the set of all possible moves for that line. 
*	Then for each move check the options (permutations) that can be played from the tileset.
*	For each specific permutation see if the resulting line contains only valid words. 
*	If not, go on to the next permutation.
*	If true, then see if all the lines affected by the move contain only valid words.
*	If not, go on to the next permutation.
*	If so, then add up the scores of all new words created by the move.

*	From amongst the valid moves determine the best move as follows.
*	If two moves have different scores, prefer the one with the higher score.

*	The 'cost' of a move is the sum of the values of the tiles in the move; so 
*	want to keep cost low to save higher value tiles for later moves.
*	If two moves have the same score and different costs, prefer the move with the lower cose.
*	If two moves have the same score and cost, while one uses the letter 's' and the other doesn't, prefer
*	the move that doesn't use the letter 's'.

*	Find returns the best move as defined above, or null if no valid move is found.

*FIND*
find
	lines = copy(g.lines)
	inlines = copy(lines)
	flines = array(8);* for line with move and its crossing lines.
	fi = 0;* number of entries in flines
	highest = 0;* highest score
	lowest = 0;* lowest cost
find.line
	gt(num = num + 1,30)				:s(find.done)
	line = lines[num]
	moves = scan(pair(num,line),rack)			:f(find.line)
*	ne(g.showscore) differ(moves) show.moves(moves,'Scan line ' lpad(num,3),2)
	mi = 0
find.move
	count.moves = count.moves + 1
	move = moves[mi = mi + 1,2]			:f(find.line)
*	output = ne(g.showscore) ' find.move mi ' mi ' ' show.move(move,'find')
	points(move) = 
	perms = g.permutations[size(rack) '?' count(move)]
	ident(perms)					:s(find.move)
	permi = 0
	
find.perm
	score = fi = 0
	perm = perms[permi = permi + 1]			:f(find.move)
	ident(perm)					:s(find.move)

*	output = 'findperm ' perm

	count.perm = count.perm + 1
	count.cells = count.cells + size(perm)

	lines = copy(inlines);* restore lines to condition on entry

*	Insert the letters from the tileset corresponding to the permutation into the selected blank cells in the line. 
*	The digit '1' selects the first tile, the digit '2' the second, and so on.
*	Then see if the result gives a valid line. Move to the next permutation if not.

	text(move) = perm;* insert permutation digits into free cells
	iline = insert(lines[num],move);* line with permutation digits entered
	checkline(place(iline,rack))			:f(find.perm)
	perm(move) = perm

*	Move is valid on this line, so check validity on crossing lines.
*	Save the valid lines in *flines* for scoring if move proves valid.

	text(move) = place(text(move),rack)
*	output = 'find valid move ' show.move(move)
	flines[fi = fi + 1] =  pair( id(move), insert(lines[num],move))
	i = 0

*	Check the crossing lines to make sure they are valid.

find.cross
*	output = 'find cross '
	count.cross = count.cross + 1
	p = free(move)[i = i + 1]			:f(find.cross.done)
	cline = cline(lines,move,p,substr(rack,substr(perm,i,1),1),rack)
	checkline(line(cline))				:f(find.perm)

*	output = 'valid checkline ' line(cline)

	text(move) = place(text(move),ucase(rack))
	flines[fi = fi + 1] = cline
*				pair(
*.		(le(id(move),15) id(move) + 15, id(move) - 15),
*.		insert(line(cline),move))		
					:(find.cross)
	
find.cross.done
*	Score the line by summing the scores of the lines saved in flines.
	
	count.valid = count.valid + 1
	move = copy(move)
*	ne(g.showscore) show.play(move,show.move(move))
*	ne(g.showscore) show.move(move)
	points(move) = +findscore(flines,fi)	
	g.found = g.found + 1
*	output = 'find found ' show.move(move)

	lt(points(move),highest)			:s(find.perm)
	gt(points(move),highest)			:s(find.new)

*	Here if points equal, look for lower cost

	lt(cost(text(move)),lowest)			:s(find.new)
	gt(cost(text(move)),lowest)			:s(find.perm)

*	Here if same points and cost, see if one uses 's' and the other doesn't.
*	Continue search if current best doesn't use 's'.

	text(find) ? break('s')				:f(find.perm)

*	Here if current best uses an 's'. Continue if new move also uses 's'.

	text(move) ? break('s')				:s(find.perm)

find.new

*	Here to add the new best move.

	find = copy(move)
	highest = points(move)
	lowest = cost(text(move))
	fi = 0;* reset for next permutation
*	output = 'find new best move ' show.move(move)
							:(find.perm)
find.done
	ident(find)					:s(find.fail)
							:(return)	
find.fail

*	output = 'find failed '

*	If *find* is still null, then no move was found, so try to swap three tiles.
*	In either event, take the failure return.
	find = ident(find) order(swap(rack,3))
							:(freturn)
find.end
	
	define('findscore(flines,fn)i,move')			:(findscore.end)

*	Find the score of a move by summing the scores of the lines affected by the move.

*	In order to determine which words on the board would be formed by making this move,
*	rebuild the board but with the new tiles in uppercase. This way, a word is new if and only if
*	it contains an upper case character. The score is then the sum over all the lines of the scores of
*	the words containing an upper-case character. At most one word in each line of the new grid will
*	contain an upper-case character.

*FINDSCORE*
findscore

	i = 0
*	output = ne(g.showscore) ' ENTER findscore fn ' fn
findscore.1
	gt(i = i + 1,fn)				:s(findscore.2)
	move = flines[i]
*	output = 'findscore ' lpad(i,2) ' ' num(move) ' ' show.line(line(move)) :(findscore.1)
findscore.2
	i = 0

findscore.next
	gt(i = i + 1,fn)				:s(return)
	findscore = findscore + score(flines[i])	
*	output = ne(g.showscore) 'scoring AFTER  flines, ' show.pair(flines[i]) '  is ' findscore

							:(findscore.next)
findscore.end

	define('game(one,two,max)opn,move,players,i,li,offset,open.word,open.score,n,tiles,moves,li,passed,board') :(game.end)

*	Play a game of fribble. *one* and *two* are players. *max* is the maximum number of moves.

*GAME*
game

	players = array(2)
	players[1] = one
	players[2] = two
	total(one) = total(two) = moves(one) = moves(two) = 0
	rack(one) = take(7)
	rack(two) = take(7)

	g.turn = g.lastmove = 0

game.round
	i = 0
game.turn
	g.turn = g.turn + 1

	output = ne(max) gt(g.turn,max) 'Game over: too many turns.'  :s(game.over)

	le(g.turn, g.lastmove + 5)			:s(g.turn.trace)

*	output = 'Game over: too many turns with no move.'	:s(game.over)

g.turn.trace

	differ(g.trace) tracer()

	p = players[i = i + 1]				:f(game.round)
	le(g.turn, max)			:s(game.continue)

	output = 'Too many moves ( ' moves ').'		:(game.over)

game.continue
	output = 'Move ' g.turn ' for player ' name(p) ', with tiles ' show.tiles(rack(p),'A') '.'

*	output = 'calling find'
	move = (eq(g.turn,1) open(rack(p)), find(rack(p))) :s(game.move)
*	output = 'called find'

*	Here if no move found, in which case the return value is a set of swapped tiles.
*	If *move* is null, then pass.

	differ(move)					:s(game.swap)

	passed = passed + 1

	output = gt(passed,6) ' Too many passed moves.'	:s(game.over)

	output = 'Player ' name(one) ' passes.'		:(game.turn)
	
game.swap
	rack(p) = swap(rack(p),3)
	output = 'Player ' name(p) ' swapped tiles.'	
	output = 'Player ' name(p) ' now has tiles ' show.tiles(rack(p))
							:(game.turn)

game.move
	g.lastmove = turn

	total(p) = total(p) + points(move)

	playmove(move)

*	output = 'played move'
	output = name(p) ' played ' show.tiles(text(move),'B') ' for ' points(move) '.'
.		' The score is now ' name(one) ' ' total(one) ', ' name(two) ' ' total(two) '.'

	show.board(g.board)

*	Display move in grid with just this move in upper case by saving the board, playing the move with
*	the text in upper case, showing it, and then restoring the board to its saves state.

	board = copy (g.board)
	text(move) = ucase(text(move))
	playmove(move)
	show.grid(g.board)
	g.board = board

*	Update rack.
*	output =  'updating rack'

*	Game over if no more tiles would remain.

	output = le(size(rack(p), size(g.tiles))) 'Game over: no more tiles.'	:s(game.over)

	rack(p) = less(rack(p), lcase(text(move))) take(size(text(move))) :s(game.shuffle)

*	Here if can't take any new tiles, so fail for now.

	output = 'Game over: out of tiles, end game. '		:(game.over)

game.shuffle

*	Shuffle the tiles so the tile set changes according to the tiles played.
* Not for now, maintain repeatability
*	shuffle()

*	output = 'shuffled'
*	Update lines affected by grid changes to maintain consistency.

	g.alone.lines = lines(g.alone)
	g.bonus.lines = lines(g.bonus)

	g.lines = lines(g.board)

*	Fold g.lines into lower case so only new moves made later will display in upper case.

	li = 0
game.fold						
	g.lines[li = li + 1] = lcase(g.lines[li])	:s(game.fold)

*	Rebuild board since lines have changed.

*	output = 'rebuilding board'
	g.board = grid(g.lines)				:(game.turn)
game.over						
	output =  'Player ' name(one) ' scored ' total(one) ' points.'
	output =  'Player ' name(two) ' scored ' total(two) ' points.'
							:(return)
game.end

	define('grid(lines,start)i,r,c,line')		:(grid.end)

*	Construct a grid from a sequence of lines beginning at index *start*,
*	(1..15 for rows, 16..30 for columns.

*GRID*
grid
	grid = array('15,15',' ')
	start = ident(start) +1
	start = (lt(start,15) 1, 16)
	gt(start,15)					:s(grid.col)

*	Here to build grid from the rows.

	r = 0

grid.nextrow
	gt(r = r + 1,15)				:s(grid.done)
	line = lines[r]					:f(grid.3)
	i = 0
grid.r
*	output = 'grid r ' r '  ' i + 1 ' ' substr(line,i + 1,1)
	grid[r,i = i + 1] = substr(line,i,1)		:s(grid.r)f(grid.nextrow)

grid.col

*	Here to build grid from the columns.

	c = 14
grid.nextcol
	gt(c = c + 1,30)				:s(grid.done)
	line = lines[c]
	i = 0
grid.c
	grid[i = i + 1,c] = substr(line,i,1)		:s(grid.c)f(grid.nextcol)
grid.done						:(return)
grid.end

	define('hline(g,r)')				:(hline.end)

*	Return the horizontal line of a grid *g* corresponding to row *r* as a string.

*HLINE*
hline
	r = +r
	hline = g[r,1] g[r,2] g[r,3] g[r,4] g[r,5] 
.		g[r,6] g[r,7] g[r,8] g[r,9] g[r,10]
.		g[r,11] g[r,12] g[r,13] g[r,14] g[r,15]
							:(return)
hline.end


	define('insert(line,move)i,utext')		:(insert.end)

*	Insert the text of a move into its free list of empty cells in the line of the move.

*INSERT*
insert
	insert = unpack(line)
	utext = ucase(text(move))
insert.1
	gt(i = i + 1,count(move))			:s(insert.done)
	insert[free(move)[i]] = substr(utext,i,1)	:(insert.1)
insert.done
	insert = pack(insert)				:(return)
insert.end

	define('lcase(s)')				:(lcase.end)

*	Convert argument to lower case.

*LCASE*
lcase
	lcase = replace(s,&ucase,&lcase)		:(return)
lcase.end
	
	define('less(str,sub)before,after')		:(less.end)

*	Less removes the first instance of each character in *sub* from *str*, 
*	where *sub* is a substring of *str*.

less
	ident(str)					:s(return)
	less = str
less.ch
	sub len(1) . ch =				:f(return)	
	less break(ch) . before  ch rem . after
	less = before after				:(less.ch)
less.end

	define('lineid(num)')				:(lineid.end)

*	Returns row or column id corresponding to line number *num*.

*LINEID*
lineid
	lineid = (le(num,15) 'r' lpad(num,2,0), 'c' lpad(num - 15,2,0)) :(return)
lineid.end

	define('lines(g)i')				:(lines.end)

*	Express the grid *g* as a sequence of lines, with the first 15 consisting of the rows
*	and the last 15 consisting of the columns.

*LINES*
lines
	lines = array(30)
lines.next

*	Make sure all entries in lines are in lower case, since we enter moves in g in upper case.

	gt(i = i + 1,15)				:s(return)
	lines[i] = lcase(hline(g,i))
	lines[i + 15] = lcase(vline(g,i))		:(lines.next)
lines.end

	define('open(tiles)perm,perms,permi,free,offset,i,highest,lower,best,n,word,start,score,move')	:(open.end)

*	Determine best opening.turn. At least one letter in this move must be in the center square (8,8).
*	The only bonus available is double word, for any word of more than four characters.

*	Find the move the highest score. Given two moves with the same score, prefer the one with
*	the lowest tile cost.
*
*	The return value has the form 'm s' where m is the move and s is its score.
*
*	There are seven tiles, so we just try all permutations of length one up to seven.

*OPEN*
open
	output = 'enter open'
	n = 0;* number of tiles to play
	highest = lowest = 0;* best score, lowest cost
	start = 8;* assume word will start in column 8

	
	tiles break('s')				:f(open.n)
	tiles = less(tiles,'s')

open.n	gt(n = n + 1,6)					:s(open.done)
*	play at most six tiles for now.
	kind = size(tiles) '?' n
	perms = g.permutations[kind]			:f(open.n)
	permi = 0
open.word
*	get next word, check that valid, then see if new high score
	perm = perms[permi = permi + 1]			:f(open.n)
	word = replace(perm,substr('1234567',1,size(tiles)),tiles)
*	output = 'kind ' kind ' perm ' perm ' word ' word
	checkword(word)					:f(open.word)
	checkwords = checkwords + 1

*	Score is the value of the tiles unless the word has five or more characters, in which
*	case the double word bonus at index twelve can be achieved.

	score = (lt(size(word),5) cost(word), 2 * cost(word))

*	Add the first word found to set *highest* and *lowest*
	eq(highest,0)					:s(open.new)

	lt(score,highest)				:s(open.word)
	gt(score,highest)				:s(open.new)

*	Here if current best and new move have same score. Prefer the one with the lowest cost.

	lt(cost(word),lowest)				:s(open.new)

open.new
	highest = score
	lowest = cost(word)
	best = word					
	output = 'updating.turn ' best ' ' highest ' ' lowest
							:(open.word)
open.done

*	Start word at position 8, unless word size greater than five, in which case move it to the left, but
*	making sure move still covers double-word cell at position twelve.

	offset = (lt(size(best,5) 0, 5 - size(best)))

*	Initialize free array for move.

	free = array(size(best))
	i = 0
open.free
	free[i = i + 1] = 7 + i  + offset			:s(open.free)

	open = move(8 + offset,size(best),free,best,highest) :(return)

open.end

	define('order(tiles)chars,ch,c1,c2,swaps,i,v1,v2')		:(order.end)

*	Sort the tiles in *tiles* according to their value, with least valuable first.
*	Though 's' has a nominal value of 1, its actual value is greater, since almost
*	a third of the words in the dictionary are plurals. Give 's' a value of 5 for
*	the purpose of the sort.

*ORDER*
order
	order = le(size(tiles),2) tiles					:s(return)
	chars = unpack(tiles)
							:(order.loop)
order.next
	eq(swaps,0)					:s(order.done)
	swaps = i = 0						

*	Loop through chars, swapping out of order characters, until all characters are
*	properly ordered.

order.loop
	c1 = chars[i = i + 1]				:f(order.next)
	c2 = chars[i + 1]				:f(order.next)
	v1 = (ident(c1,'s') 5, g.value[c1])
	v2 = (ident(c2,'s') 5, g.value[c2])
	le(v1,v2)					:s(order.loop)
	ch = c2
	chars[i + 1] = c1
	chars[i] = ch
	swaps = swaps + 1				:(order.loop)
order.done
	order = pack(chars)				:(return)
order.end

	define('pack(chars),i')			
	:(pack.end)

*	Pack the array of characters *chars* into a line.

*PACK*
pack

pack.ch
	pack = pack chars[i = i + 1]			:f(return)s(pack.ch)
pack.end

	define('place(txt,rack)')			:(place.end)

*	Place the permutation digits in *txt* with the corresponding tiles from *rack*.

*PLACE
place
	place = replace(txt,substr('1234567',1,size(rack)),rack)
								:(return)
place.end

	define('placecell(r,c,w)ch')			:(placecell.end)

*	Add a word to the board.

*PLACECELL*
placecell
	c = c - 1
placecell.ch
	w len(1) . ch =					:f(return)
	g.board[r, c = c + 1] = ch
	g.bonus[r, c] = ' ';* indicate bonus no longer available
*	Mark self and adjoining squares as no longer alone
	g.alone[r,c] = ' '    ;* self
	g.alone[r - 1,c] = ' ';* cell to the north
	g.alone[r,c + 1] = ' ';* cell to the east
	g.alone[r,c - 1] = ' ';* cell to the west
	g.alone[r + 1,c] = ' ';* cell to the south
							:(placecell.ch)
placecell.end


	define('playmove(move)txt,i,ch')			:(playmove.end)

*	Play move *move*, updating the board and related objects.

*PLAYMOVE*
playmove
*	output = 'playmove ' show.move(move)
	txt = text(move)
playmove.ch
	txt len(1) . ch =				:f(return)
*	output = 'playmove char<' ch '>'
	i = i + 1;* position in text
	id = id(move)
	gt(id,15)					:s(playmove.col)

*	Here to play character in row

*	output = 'calling placecell row ' id ' ' free(move)[i] ' ' ch
	placecell(id,free(move)[i],ch)			
							:(playmove.ch)
playmove.col

*	Here to play character in column

*	output = 'calling placecell col ' id ' ' free(move)[i] ' ' ch
	placecell(free(move)[i],id - 15,ch)		
							:(playmove.ch)
playmove.end
	
	define('prefix(str,pre)word')			:(prefix.end)
*PREFIX*
prefix

*	Prefix takes a list of space-separated words str and prefixes each
*	with the string pre.

	str = str ' ';* so each word followed by space
prefix.1
	str break(' ') . word span(' ')  =		:f(return)
	prefixcount = prefixcount + 1
	prefix = append(prefix, pre word,'A')		:(prefix.1)
prefix.end

	define('random(n)')				:(random.end)

*	Return integer uniformly distributed in 1,2,...,n. 
*	If n=0 returns real uniformly distributed in the interval [0,1].
*	The Algorithm is based in that in section 16.1 of "Algorithms in SNOBOL4,"
*	James F. Gimpel, John Wiley and Sons, 1976.

*RANDOM*
random	
	g.random_var = remdr(g.random_var * 4676, 414971)
	random  = g.random_var / 414971.0
	random = ne(n) convert(random * n,'integer') + 1
							:(return)
random.end

	define('scan(pair,rack)num,line,alone,nopen,ai,first,max,n,last,p,move,moves,fi,lonely,avail')	:(scan.end)

*	Scan the given line to find the places where a valid move can be made. At least one cell in 
*	a move must be adjacent to an occupied cell.  *line* is the line to be scanned, and *num* gives its
*	position on the board.

*SCAN*
scan
	line = line(pair)
	num = num(pair)
	output = differ(g.tracing) 'SCANNING ' num ' ' show.hex(line)
	moves = 0
	alone = g.alone.lines[num]

*	Allocate and fill in avail, an array giving the positions of the open cells.

	avail = available(line)			:f(scan.done);* fail if no empty cells

*	Set lonely to the alone-ness of the cells in avail, so that the i-th character is the
*	alone attribute of the i-th position in the move. A valid move requires that at
*	least cell in the move not be alone.

	i = 0
scan.lonely
	lonely = lonely substr(alone,avail[i = i + 1],1) :s(scan.lonely)
	
	nopen = prototype(avail);* number of open cells

*	Prepare for loop, since decrement nopen at start of search at a given empty cell.

	nopen = nopen + 1
	ai = 0

scan.next
*	Here to find all the possible moves starting at the next open cell, first.

	first = avail[ai = ai + 1]			:f(scan.done)

	nopen = nopen - 1;* count down since we are accounting for this open cell in this pass through the loop.
	le(nopen)					:s(scan.done)

*	Let max be the most tiles we can play on this line. We can't play more tiles than the number of 
*	blank cells remaining in the line, and we can't play more tiles than we have.

	max = nopen
	max = gt(max,size(rack)) size(rack)
* MAX
	max = eq(max,7) 6
	max = eq(max,7) 6
	max = 5
	n = 0

scan.next.n
	gt(n = n + 1,max)				:s(scan.next)

	last = ai + n - 1				:f(scan.fail)
	fi = first - 1

*	Continue to the next postion if all the cells in this move are alone, and hence no valid move is possible.

	substr(lonely,ai,n) ? span('1')		:s(scan.next)
*MOV
	move = move(num,n,subarray(avail,ai,n))
	scan = ident(scan) table()
	count.scanned = count.scanned + 1
	scan[count.scanned] = move			:(scan.next.n)
scan.done
	ident(scan)					:s(freturn)
	scan = convert(scan,'array')				
							:(return)
scan.doner	
	output = 'move.doner'				:(end)
scan.end

	define('score(pair)cline,vline,word,words,n,start,wi,ch,i,bonus,mult,val')	:(score.end)

*	Compute the score of a move on a given line. All the letters of the move will be in upper case on the board
*	so the score of the move is the sum of the scores of all the words with upper case letters in them, for
*	both rows and columns. This function should only be called for lines which have an upper case letter in
*	them as a result of the move.

*SCORE
score
	empty(line(pair))				:s(return)
	output = ne(g.showscore) 'enter score ' show.pair(pair)
	cline = line(pair)
	bonusline = g.bonus.lines[num(pair)]

	eq(g.showscore) 				:s(score.3)
	vline = 
score.1
	gt(i = i + 1,size(cline))			:s(score.2)
	vch = substr(cline,i,1)
	vch = gt(g.value[vch],0) substr('123456789ABCDE',g.value[substr(cline,i,1)],1)
	vline = vline vch				:(score.1)
score.2
	output = 'score value ' vline
	output = 'score       ' cline
	output = 'score bonus ' bonusline  
score.3

	cline break(&ucase)				:f(score.error)
	words = words(cline)				:f(return)
	wi = 0
score.word
	start = words[wi = wi + 1,1]			:f(return)
	word = words[wi,2]
	n = size(word)

*	Single letters don't contribute to score since they result from an crossing line.

	eq(n,1)						:s(score.word);* singletons aren't scored.
	word break(&ucase)				:f(score.word)

	output = ne(g.showscore) 'scoring word ' word ' starting at ' start
	line = substr(cline,start)
	bonusline = substr(g.bonus.lines[num(pair)],start);* corresponding part of bonus line
	i = 0
	mult = 1;* multiplier value for double and triple word cases.

score.char
	gt(i = i + 1,n) 				:s(score.char.done)
	ch = substr(word,i,1)
	bonus = +substr(bonusline,i,1)
	bonus = ident(bonus,' ') 1
	val = +g.value[ch]
	output = ne(g.showscore) ch ' ' val ' ' bonus

*	Update score for letter

	score = lt(bonus,4) score + bonus * val	

*	Update double/word multiplier

	mult = gt(bonus,3) mult * (bonus - 2)

	output = ne(g.showscore) 'score ' ch ' added value ' val ' score now ' score ' mult ' mult
							:(score.char)
score.char.done
	score = score * mult
	output =  ne(g.showscore) 'result SCORE ' score ' for word ' word ' , for ' show.pair(pair)
							:(return)
score.error
	score = 0					:(return)
*	output = 'error scoring line with no new move ' line(pair) :(end)
score.end

	define('show(rack,player)')			:(show.end)

*	Show state of board, alone and value grids before start of move.

show
	output = 'rack for player ' player ': ' rack

	show.board(g.board,'player ' player ' to play')
	show.grid(g.board)
	show.lines(g.lines)
*	show.board(g.bonus,'bonus')
	show.grid(g.alone)
							:(return)
show.end

	define('shuffle()tiles,n,r1,r2,ch')		:(shuffle.end)

*	Shuffle the remaining tiles by randomly swapping two tiles several times.

shuffle	
	tiles = unpack(g.tiles)
	n = size(g.tiles)  * 2
	lt(n,5)						:s(shuffle.done)
shuffle.next
	le(n = n - 1)					:s(shuffle.done)
	r1 = random(n); r2 = random(n)
	eq(r1,r2)					:s(shuffle.next)
	ch = tiles[r1]
	tiles[r1] = tiles[r2]	
	tiles[r2] = ch					:(shuffle.next)
shuffle.done
	g.tiles = pack(tiles)
							:(return)
shuffle.end

	define('subarray(ara,start,len)i')		:(subarray.end)

*	Like substr, but returns the sub-array of *ara* starting at element *start* and
*	consisting of *len* elements

subarray
	subarray = array(len)
subarray.1
	gt(i = i + 1,len)				:s(return)
	subarray[i] = copy(ara[start + i - 1])		:(subarray.1)		
subarray.end

	define('swap(tiles,n)')				:(swap.end)

*	Swap *n* files from the first *n* characters in *tiles*. If fewer than *n* tiles remain,
*	set *n* to the size of the tileset.

swap	
	n = gt(n,size(tiles)) size(tiles)
	n = gt(n,size(g.tiles)) size(g.tiles)
	eq(n)						:s(freturn)
swap.next
	swap = substr(g.tiles,1,n)
	g.tiles = substr(g.tiles,n + 1)  substr(tiles,1,n)
							:(return)
swap.end

	define('take(n)')				:(take.end)

*	Take *n* tiles from the tileset, unless there are fewer than *n* tiles left,
*	in which case return the reamining tiles.

take
	n = gt(n,size(g.tiles)) size(g.tiles)
	take = order(substr(g.tiles,1,n))
	g.tiles = substr(g.tiles, n + 1)
*	output = 'take<' take '> g.tiles<' g.tiles '>'
							:(return)
take.end

*	The initial tileset has many more vowels than consonants, so if we
*	just pick them randomly from the start, we will get racks with
*	almost all vowels. To avoid this, we always shuffle at least one consonant,
*	and shuffle two if n is greater than 5.
*	g.tiles = kk
*	
*	n = le(size(g.tiles),n) size(g.tiles)
*	n = n + 1
*	consonants = (gt(n,5) +2, +1)
*	vowels = 'aeiou'
*	consonants = less(g.tiles) vowels
*	
*	ch any('aeiou')					:s(shuffle.vowel)f(shuffle.consonant)
*shuffle.vowel
*
**	If see vowel and need a consonant, try another random tile.
*
*	ne(consonants)					:s(shuffle.r)f(shuffle.add)
*
*shuffle.consonant
*	consonants = gt(consonants) consonants - 1

	define('tracer()')				:(tracer.end)

*	Initiate tracing at start of move *g.trace*.

tracer
	output = 'enter tracer g.trace ' g.trace ' move now ' g.turn
	ident(g.trace)					:s(return)
	ne(g.turn,g.trace)				:s(return)
	&ftrace = &trace = g.tracing = 1000000		
	output = 'start TRACING ' g.turn ' ' g.tracing
							:(return)
tracer.end

	define('ucase(s)')				:(ucase.end)

*	Convert argument to upper case.

ucase
	ucase = replace(s,&lcase,&ucase)		:(return)
ucase.end
	
	define('unpack(line),c,i')			:(unpack.end)

*	Unpack the characters of line *line* to an array of characters.

unpack
	unpack = array(size(line))
unpack.ch
	c = substr(line,i = i + 1,1)			:f(return)
	unpack[i] = c					:(unpack.ch)
unpack.end

	define('vline(g,c)')				:(vline.end)

*	Return the vertical line of a grid *g* corresponding to column *c* as a string.

vline
	c = +c
	vline = g[1,c] g[2,c] g[3,c] g[4,c] g[5,c] 
.		g[6,c] g[7,c] g[8,c] g[9,c] g[10,c]
.		g[11,c] g[12,c] g[13,c] g[14,c] g[15,c]
							:(return)
vline.end

	define('wordcount(s)i,w')			:(wordcount.end)

*	Return number of words in s, fail if no words

wordcount
	s break(' ')					:f(freturn)
	
	wordcount = 0
wordcount.1
	s break(' ') . w span(' ') =			:f(return)
	wordcount = +wordcount + 1			:(wordcount.1)
wordcount.end

	define('words(s)n,w,pos,i')					:(words.end)

*	Return array of the words in s, fail if no words.
*	The first entry for an array is the starting index,
*	the second entry is the word itself.

words
	n = wordcount(s)				:f(freturn)
	s = s ' '
	words = table(n)
	pos = 1	
	s span(' ') . w =				:f(words.1)
	pos = size(w) + 1;* point to start of first word
words.1
	s break(' ') . w ' ' = ' ' 			:f(words.done)
	words[pos] = w					
	i = i + 1	
	gt(i,n)						:s(words.done)
	
	pos = pos + size(w) + 1;* set to start of next word
							:(words.1)
words.done
	words = convert(words,'array')			:(return)
words.end


