* This software is licensed under the MIT License, contained in the file LICENSE.

* Copyright (c) 2016 dave shields

*	Global Variables

*	Here are the global variables. Each has a name starting with 'g.' Their initial value is set in the
*	procedure *init()*.

*	g.board, array('15,15'), the playing board. Each entry is blank (' ') for unplayed cell, or is the letter played.

*	g.empty.board is a copy of the initial g.board (a board with no cells occupied).
	
*	A play is a sequence of one or more cells, represented as an array.  The cells are ordered
*	from left to right for a horizontal play, top to bottom for a vertical play.

*	g.dict, array(15), is an array of hashtables  that are non-null for words in the dictionary.

*	g.alone, array('15,15') tracks the *alone* cells in the board. A cell is *alone* if it is empty and all its
*	neighbors are empty. A move made after the first move cannot consist only of cells that are alone. 
*	That is, at least one tile in a valid move must be adjacent to a tile played in a previous move.

*	g.alone.lines, array(30), is the array of lines defined by the rows and columns of the alone grid.

*	g.lines, array(30), is the array of the lines defined by the rows and columns in the board. 

*	g.permutations, a table of the permutations of n=1..7 things taken 1..k at a time.
*	For example, g.perms['7?3'] is permutations of 1..7 taken 3 at a time, as a string with
*	entries separated by a space.

*	g.permutations.count, a table giving the number of permutations of for a given *n* and *k*.

*	g.rack, a string containing the current rack. Plays are made using the characters from the rack.

*	g.tileset, a string containing all the characters in the initial bag of characters.

*	g.value, a map from characters to the tile value of that character.

*	A move is a sequence of empty cells in a row or column such that at least one cell in the sequence 
*	is adjacent to an already occupied cell:
*		*id* gives the line number, in the range 1..30;
*		*count* is the number of free cells covered by this move;
*		*free* is an array of dimension *count* giving the empty cells to be filled by this move;
*		*text* is the string of tiles of the move; and
*		*points* is the number of points won by playing this move.

	data('move(id,count,free,text,points,fid)')

*	g.bonus,array(15,15) gives the bonus values for the squares on the board:
*		1 for the value of the letter itself,
*		2 for double letter,
*		3 for triple letter, 
*		4 for double word, and
*		5 for triple word.

*	g.bonus.lines,array(30), is the array of lines corresponding to g.bonus

*	A pairged line consists of a line number and an associated line. It is used when it is necessary
*	to pass a line of text to a procedure along with line number from where it was derived.

		data('pair(num, line)')

*	g.showscore is used to enable tracing of scoring by setting it to nonzero value
	g.showscore = 1

*	Utility functions

	define('init(dictfile,skip)c,i,j,s,t')		:(init.end)

*	Initialize global variables.

init
	init.main(dictfile,skip)			:(return)

*	Free up code for initializers now that no longer needed.

	init.bonus = init.main = init.dict = init.tileset = init.value = 	:(return)
init.end

	define('init.main(dictfile,skip)c,i,j,s,t')	:(init.main.end)

*	Initialize global variables.

init.main
	g.dict = array(15)
	g.board = array('15,15',' ')
	g.empty.board = copy(g.board)
	g.lines = lines(g.board)

	g.alone = array('15,15','1')
	g.alone.lines = lines(g.alone)

	init.bonus()

*	Initialze permutation map.

	init.perm('../perm.txt')

	init.tileset()

	init.value()

	init.dict(dictfile,skip)
							:(return)
init.main.end

	define('init.bonus()s,row,col,b,c')		:(init.bonus.end)

*	Initialize the bonus squares for the 15x15 grid: 
*		1 for the value of the letter,
*		2 for double letter,
*		3 for triple letter,
*		4 for double word, and
*		5 for triple word.

init.bonus
	g.bonus = array('15,15',+1)
	s = 	'5 0104 3 0107 3 0109 5 0112 2 0203 4 0206 4 0210 2 0213 '
.		'2 0302 2 0305 2 0311 2 0314 5 0401 3 0404 4 0408 3 0412 4 0415 '
.		'2 0503 2 0507 2 0509 2 0513 4 0602 3 0606 3 0610 4 0614 '
.		'3 0701 2 0705 2 0711 4 0715 4 0804 4 0812 3 0901 2 0905 2 0911 3 0915 '
.		'4 1002 3 1006 3 1010 4 1014 2 1103 2 1107 2 1109 2 1113 '
.		'5 1201 3 1204 4 1208 3 1212 5 1215 2 1302 2 1305 2 1311 2 1314 '
.		'5 1403 4 1406 4 1410 2 1413 5 1504 3 1507 3 1509 5 1512 '

init.bonus.1
	s len(1) . b ' ' len(2) . row len(2) . col ' ' =	:f(init.bonus.next)
	g.bonus[+row,+col] = +b					:(init.bonus.1)
init.bonus.next
	g.bonus.lines = lines(g.bonus)				:(return)
init.bonus.end

	define('init.dict(filename,skip)file,i,n,w,s')		:(init.dict.end)

*	Initialize the global dictionary g.dict.

init.dict

*	Set hash table sizes according to output of ../study/gendict.sbl

	s  = '1 100 1000 4000 9000 15000 23000 28000 25000 20000 15000 11000 8000 5000 3000 '
init.dict.tbl
	gt(i = i + 1,15)				:s(init.dict.tbl.1)
	s break(' ') . n ' ' = 
	g.dict[i] = table(+n)				:(init.dict.tbl)
init.dict.tbl.1
	i = 0


*	Read in a dictionary from a specified file, with one word per line. If 'skip'
*	is non-zero then that number of lines are skipped before adding the next word.
*	This assists the use of smaller dictionaries for testing.

	filename = ident(filename) '../dict.txt'
	skip = (ident(skip) +1, +skip)

	input(.file,3,filename)				:s(init.dict.in)
	output = 'unable to open input file ' filename	:(freturn)
	n = 0
init.dict.in
	w = file					:f(init.dict.done)
	gt(size(w),15)					:s(init.dict.in)

*	Process plural words, indicated by 'S' at end

	differ(substr(w,size(w),1),'S')			:s(init.dict.w)
	w = substr(w,1,size(w) - 1)
	g.dict[size(w)][w] = +1
	g.dict[size(w) + 1][w 's'] = +1			:(init.dict.in)
init.dict.w
	g.dict[size(w)][w] = +1
	eq(skip,1)					:s(init.dict.in)
*	here want to skip over entries in the dictionary (for testing)
	n = skip
init.dict.skip
	w = file					:f(init.dict.done)
	gt(n = n - 1,0)					:s(init.dict.skip)f(init.dict.in)
init.dict.done
	endfile(3)					:(return)
init.dict.end

	define('init.perm(filename)line,ifile,n,k,lines,nread')	:(init.perm.end)

*	Initialize the list of possible permutations from a file.

*PERM
init.perm
	g.permutations = table(7)
	g.permutations.count = table(100)
	input(.ifile,4, filename)			:s(init.perm.next)
	output = 'unable to open permutation file ' filename 	:(freturn)
init.perm.next
	line = ifile					:f(init.perm.done)
	line break('?') . n '?' break(' ') . k ' ' rem . count :f(init.perm.err)
	g.permutations.count[n '?' k] = count
	ara = array(count)
	ai = 0
init.perm.array
	ara[ai = ai + 1] = ifile			:s(init.perm.array)
	g.permutations[n '?' k] = ara			:(init.perm.next)
init.perm.done
	endfile(4)					:(return)
init.perm.err
	output = 'init.perm error, line ' lines '  '  line :(freturn)
init.perm.end

	define('init.tileset()s,n')			:(init.tileset.end)

* 	Initialize set of tiles, ignoring the 'blank' tiles for now.
*	Initialize value map from letters to value, ignoring ' ' for now

init.tileset
	s = 'a 9 b 2 c 2 d 5 e 13 f 2 g 3 h 4 i 8 j 1 k 1 l 4 m 2 n 5 o 8 p 2 q 1 r 6 s 5 t 7 u 4 v 2 w 2 x 1 y 2 z 1 '
	g.tileset =
init.tileset.1
	s break(' ') . c ' ' break(' ') . n ' ' =	:f(return)
	g.tileset = g.tileset dupl(c,n)			:(init.tileset.1)
init.tileset.end

	define('init.value()s,c')			:(init.value.end)
init.value
	g.value = table(52)
	s = &lcase &ucase

*	Assume value of a tile is one, and correct that below.

init.value.next
*	assume value is 1
	s len(1) . c =					:f(init.value.letters)
	g.value[c] = +1					:(init.value.next)

init.value.letters
	s = 
.	'b 4 c 4 d 2 f 4 g 3 h 3 j 10 k 5 l 2 m 4 n 2 p 4 q 10 u 2 v 5 w 4 x 8 y 3 z 10 '
.	'B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 '
init.value.update
*	update assumptions for letters with value greater than one.
	s break(' ') . c ' ' break(' ') . v ' ' =	:f(return)
	g.value[c] = +v					:(init.value.update)
init.value.end

	define('bestmove(rack,tiles)best,i,moves,mov,found')					:(bestmove.end) 
*	Find the best move, or at least one with no higher score, given the rack *rack*.

bestmove
	g.lines = lines(g.board)
	moves = find(copy(g.lines),rack);* pass copy since find will alter lines. :f(bestmove.nomove)
	best = array(prototype(moves))
	i = 0
bestmove.move
	move = moves[i = i + 1,2]			:f(bestmove.sort)
	best[i,1] = move
	text(move) ? break('123456789')			:f(bestmove.move.1)
*	Here if text contains permutation when it should contain text. Fix that
	text(move)  = ucase(replace(text(move),substr('1234567',1,size(rack)),rack))
bestmove.move.1
	best[i,2] = points(move)			:(bestmove.move)
bestmove.sort
	best = rsort(best,2);* sort with highest score first
	i = 0
bestmove.list
	move = best[i = i + 1,1]			:f(return)
	output = 'best ' lpad(i,2) ' ' show.move(move)	:(bestmove.list)
bestmove.nomove
	output = 'best move found no moves -- time to swap or pass '	:(freturn)
bestmove.end

	define('append(str,w)')				:(append.end)

*	Append word *w* to string *str*, prefixing with a space if *str* is not null.

append
	append = ident(str) w				:s(return)
	append = str ' ' w				:(return)
append.end

	define('available(line)blanks,c,i')		:(available.end)

*	Return array containing the indexes of the blank cells in line. Fails if no blanks.
available
	c = substr(line, i = i + 1, 1)			:f(available.1)
	differ(c,' ')					:s(available)
	blanks = blanks + 1				:(available)
available.1
	eq(blanks,0)					:s(freturn)
	available = array(blanks)
	i = ai = 0
available.2
	c = substr(line, i = i + 1, 1)			:f(return)
	differ(c,' ')					:s(available.2)
	available[ai = ai + 1] = +i				
							:(available.2)
available.end

	define('blanks(line)n')				:(blanks.end)

*	Count number of blanks in line.

blanks
	line len(1) . c =				:f(return)
	blanks = ident(c,' ') blanks + 1		:(blanks)
blanks.end

	define('bonus.lines()i')			:(bonus.lines.end)

bonus.lines
	bonus.lines = array(30)
bonus.lines.next
	gt(i = i + 1,15)				:s(return)
	bonus.lines[i] = hline(g.bonus,i)
	bonus.lines[i + 15] = vline(g.bonus,i)		:(bonus.lines.next)
bonus.lines.end

	define('checkline(line)word')			:(checkline.end)

*	Succeeds if all the words in the line are in the dictionary, fails otherwise.

checkline
	empty(line)					:s(return)
	line span(' ') =
checkline.1
	line break(' ')  . word span(' ') =		:f(checkline.done);* if line exhausted
	eq(size(word),1)				:s(checkline.1)
	checkword(word)					:f(freturn)s(checkline.1)
checkline.done
*	output = 'checkline VALID ' show.line(line)
							:(return)
checkline.end

	define('checkword(w)')				:(checkword.end)

*	Succeeds if w is in the global dictionary, fails otherwise.

checkword
	eq(size(w),1)					:s(return)
	differ(g.dict[size(w)][w])			:s(return)f(freturn)
checkword.end

	define('cline(lines,mov,p,ch,rack)line,i,r,c')		:(cline.end)

*	Return crossing line of p-th cell in move *mov*. *ch* gives tile to be played.

cline
	text(move) = ucase(place(text(move),rack))
	gt(id(mov),15)					:s(cline.col)
	line = lines[p + 15];* column p
	r = id(mov)
	line = (eq(r,1) '',substr(line,1,r - 1)) ch (eq(r,15) '', substr(line,r + 1)) 
	cline = pair(p + 15,line)			:(cline.done)
cline.col
	text(move) = ucase(place(text(move),rack))
	line = lines[p];* row p
	c = id(mov) - 15
	line = (eq(c,1) '',substr(line,1,c - 1)) ch (eq(p,15) '', substr(line,c + 1))  
	cline = pair(p,line)				:(cline.done)
cline.done
*	output = 'CLINE ' show.move(mov) ' p ' p  "'" ch "'" ' -> ' show.pair(cline)
							:(return)
cline.end

	define('empty(line)')				:(empty.end)

*	Test if line is empty (null or all blanks).

empty	
	line span(' ') =
	ident(line)					:s(return)f(freturn)
empty.end
	
	define('find(lines,rack)flines,fi,line,moves,mi,m,perms,permi,fline,tline,iline,sline,found')	:(find.end)

*	Find all the valid moves and their scores given the current board and the indicated rack.
*	For each line, find the set of all possible moves for that line. 
*	Then for each move check the options (permutations) that can be played from the tileset.
*	For each specific permutation see if the resulting line contains only valid words. 
*	If not, go on to the next permutation.
*	If true, then see if all the lines affected by the move contain only valid words.
*	If not, go on to the next permutation.
*	If so, then add up the scores of all new words created by the move.


*FIND
find
	show.lines(lines,'find')
	flines = array(8);* for line with move and its crossing lines.
	fi = 0;* number of entries in flines
find.line
	gt(num = num + 1,30)				:s(find.done)
	line = lines[num]
	moves = scan(pair(num,line),rack)			:f(find.line)
	ne(g.showscore) differ(moves) show.moves(moves,'Scan line ' lpad(num,3),2)
	mi = 0
find.move
	move = moves[mi = mi + 1,2]			:f(find.line)
	output = ne(g.showscore) ' find.move mi ' mi ' ' show.move(move,'find')
	points(move) = 
	perms = g.permutations[size(rack) '?' count(move)]
	permi = 0
	
find.perm
	score = fi = 0
	perm = perms[permi = permi + 1]			:f(find.move)

*	Insert the letters from the tileset corresponding to the permutation into the selected blank cells in the line. 
*	The digit '1' selects the first tile, the digit '2' the second, and so on.
*	Then see if the result gives a valid line. Move to the next permutation if not.

	text(move) = perm;* insert permutation digits into free cells
	iline = insert(lines[num],move);* line with permutation digits entered
	checkline(place(iline,rack))			:f(find.perm)

*	Move is valid on this line, so check validity on crossing lines.
*	Save the valid lines in *flines* for scoring if move proves valid.

	text(move) = ucase(place(text(move),rack))
	flines[fi = fi + 1] =  pair( id(move), insert(lines[num],move))
	i = 0

*	Check the crossing lines to make sure they are valid.

find.cross
	p = free(move)[i = i + 1]			:f(find.cross.done)
	cline = cline(lines,move,p,substr(rack,substr(perm,i,1),1),rack)
	checkline(line(cline))				:f(find.perm)

*	Save the line for possible later scoring if move proves valid.

	text(move) = ucase(place(text(move),rack))
	flines[fi = fi + 1] = pair(
.		(le(id(move),15) id(move) + 15, id(move) - 15),
.		insert(line(cline),move))		:(find.cross)
	
find.cross.done

*	Score the line by summing the scores of the lines saved in flines.
	
	move = copy(move)
	ne(g.showscore) show.play(move,show.move(move))
	points(move) = +findscore(flines,fi)	

*	output = 'setting score for ' show.move(move) ' to ' points(move)
	find = ident(find) table();* create table if will have any entries.
	found = found + 1
	fid(move) = found
	output = 'find adding ' show.move(move) 
	find[found] = move
	fi = 0
							:(find.perm)
find.done

*	Fail if found no moves.

	ident(find)					:s(freturn)
	find = differ(find) convert(find,'array')	:(return)
find.end
	
	define('findscore(flines,fn)i')			:(findscore.end)

*	Find the score of a move by summing the scores of the lines affected by the move.

*	In order to determine which words on the board would be formed by making this move,
*	rebuild the board but with the new tiles in uppercase. This way, a word is new if and only if
*	it contains an upper case character. The score is then the sum over all the lines of the scores of
*	the words containing an upper-case character. At most one word in each line of the new grid will
*	contain an upper-case character.

findscore

	i = 0
	output = ne(g.showscore) ' enter findscore fn ' fn

findscore.next
	gt(i = i + 1,fn)				:s(return)
	findscore = findscore + score(flines[i])	
	output = ne(g.showscore) 'scoring AFTER  flines, ' show.pair(flines[i]) '  is ' findscore

							:(findscore.next)
findscore.end

	define('grid(lines,start)i,r,c,line')		:(grid.end)

*	Construct a grid from a sequence of lines beginning at index *start*,
*	(1..15 for rows, 16..30 for columns.

grid
	grid = array('15,15',' ')
	start = ident(start) +1
	start = (lt(start,15) 1, 16)
	gt(start,15)					:s(grid.col)

*	Here to build grid from the rows.

	r = 0

grid.nextrow
	gt(r = r + 1,15)				:s(grid.done)
	line = lines[r]					:f(grid.3)
	i = 0
grid.r
*	output = 'grid r ' r '  ' i + 1 ' ' substr(line,i + 1,1)
	grid[r,i = i + 1] = substr(line,i,1)		:s(grid.r)f(grid.nextrow)

grid.col

*	Here to build grid from the columns.

	c = 14
grid.nextcol
	gt(c = c + 1,30)				:s(grid.done)
	line = lines[c]
	i = 0
grid.c
	grid[i = i + 1,c] = substr(line,i,1)		:s(grid.c)f(grid.nextcol)
grid.done						:(return)
grid.end

	define('hline(grid,r)')				:(hline.end)

*	Return the horizontal line of a grid corresponding to row r as a string.

hline
	r = +r
	hline = grid[r,1] grid[r,2] grid[r,3] grid[r,4] grid[r,5] 
.		grid[r,6] grid[r,7] grid[r,8] grid[r,9] grid[r,10]
.		grid[r,11] grid[r,12] grid[r,13] grid[r,14] grid[r,15]
							:(return)
hline.end


	define('insert(line,mov)i,p,c,t')		:(insert.end)

*	Insert the text of a move into its free list of empty cells in the line of the move.

insert
	
	insert = unpack(line)
insert.1
	gt(i = i + 1,count(mov))			:s(insert.done)
	p = free(mov)[i]
	insert[p] = substr(text(mov),i,1)		:(insert.1)
insert.done
	insert = pack(insert)				:(return)
insert.end

	define('less(str,ch)before,after')		:(less.end)

*	Removes the first instance of character ch in str.

less
	ident(str)					:s(return)
	str break(ch) . before len(1) rem . after	:f(less.1)
	less = before after				:(return)
less.1
	less = ident(substr(s,1,1),ch) substr(s,2)	:s(return)
	less = str					:(return)
less.end

	define('lineid(num)')				:(lineid.end)

*	Returns row or column id corresponding to line number *num*.

lineid
	lineid = (le(num,15) 'r' lpad(num,2,0), 'c' lpad(num - 15,2,0)) :(return)
lineid.end

	define('lines(grid)i')				:(lines.end)

*	Express the grid as a sequence of lines, with the first 15 consisting of the rows
*	and the last 15 consisting of the columns.

lines
	lines = array(30)
lines.next
	gt(i = i + 1,15)				:s(return)
	lines[i] = hline(grid,i)
	lines[i + 15] = vline(grid,i)			:(lines.next)
lines.end

	define('open(tiles)best.score,best.word,n,w,start,key,permi')	:(open.end)

*	Determine best opening move. At least one letter in this move must be in the center square (8,8).
*	The only bonus available is double word, for any word of more than four characters.
*
*	The return value has the form 'm s' where m is the move and s is its score.
*
*	There are seven tiles, so we just try all permutations of length one up to seven.

open
	n = 0;* number of tiles to play
	best = 0;* best score
	start = 8;* assume word will start in column 8
	output = 'open ' tiles

open.1	le(n = n + 1,7)					:f(open.finish)
	kind = size(tiles) '?' n
	perms = g.permutations[kind]
	permi = 0
open.2
*	get next word, check that valid, then see if new high score
	perm = perms[permi = permi + 1]			:f(open.1)
	w = replace(perm,substr('1234567',1,size(tiles)),tiles)
	checkword(w)					:f(open.2)
	checkwords = checkwords + 1
	le(oscore(w),best.score)			:s(open.2)
	best.word = w
	best.score = oscore(w)
	open = lt(size(best.word),6) '0808+' best.word ' ' best.score	:s(open.2)
*	Here if longer open word, move a space to the left
							:(open.2)
open.finish						
	open = '0807+' best.word ' ' best.score		:(return)
open.end

	define('oscore(word)i,c')			:(oscore.end)

*	Compute the score of an initial word, which is always played horizontally starting at the center 
*	square (row=8, column = 8).
oscore
	word len(1) . c =				:f(oscore.finish)
	oscore = oscore + g.value[c]			:(oscore)
oscore.finish
*	Double word score if length greater than four, so bonus at (8,12) is achieved.
	lt(size(word),5)				:s(return)
	oscore = oscore + oscore			:(return)
oscore.end

	define('pack(chars),c,i')			:(pack.end)

*	Pack an array of characters into a line

pack
	output = ne(+prototype(chars),15) ' ERROR - pack argument not length 15'	:s(end)
	pack = 	chars[1] chars[2] chars[3] chars[4] chars[5]
.		chars[6] chars[7] chars[8] chars[9] chars[10]
.		chars[11] chars[12] chars[13] chars[14] chars[15]
							:(return)
pack.end

	define('place(txt,rack)')			:(place.end)

*	Place the permutation digits in *txt* with the corresponding tiles from *rack*.

place
	place = replace(txt,substr('1234567',1,size(rack)),rack) 	
								:(return)
place.end

	define('placeword(r,c,w)ch')			:(placeword.end)

*	Add a word to the board.

placeword
	c = c - 1
placeword.1
	w len(1) . ch =					:f(placeword.done)
	g.board[r, c = c + 1] = ch
	g.bonus[r, c] = 1;* clear bonus for this cell
*	Mark self and adjoining squares as no longer alone
	g.alone[r,c] = ' '    ;* self
	g.alone[r - 1,c] = ' ';* cell to the north
	g.alone[r,c + 1] = ' ';* cell to the east
	g.alone[r,c - 1] = ' ';* cell to the west
	g.alone[r + 1,c] = ' ';* cell to the south
							:(placeword.1)
placeword.done
	g.alone.lines = lines(g.alone)
	g.lines = lines(g.board);* update g.lines so consistent with updated board.
	g.bonus.lines = lines(g.bonus)
							:(return)
placeword.end

	define('prefix(str,pre)word')			:(prefix.end)
prefix

*	Prefix takes a list of space-separated words str and prefixes each
*	with the string pre.

	str = str ' ';* so each word followed by space
prefix.1
	str break(' ') . word span(' ')  =		:f(return)
	prefixcount = prefixcount + 1
	prefix = append(prefix, pre word)		:(prefix.1)
prefix.end

	define('random(n)')				:(random.end)

*	Return integer uniformly distributed in 1,2,...,n. If n=0 returns real uniformly distributed
*	in the interval [0,1].
*	The Algorithm is based in that in section 16.1 of "Algorithms in SNOBOL4,"
*	James F. Gimpel, John Wiley and Sons, 1976.

*	Gimpel uses integer here, but need to have real.
	random_var = convert(1,'real')

							:(random.end)
random	random_var = remdr(random_var * 4676, 414971)

	random  = random_var / 414971
	random = ne(n,0) convert(random * n,'integer') + 1
							:(return)
random.end

	define('random_rack()i')			:(random_rack.end)

*	Return random set of seven tiles from the initial set of tiles.
*	This is used for testing.

random_rack
	gt(i = i + 1,7)					:s(return)
	random_rack = random_rack substr(g.tileset,random(size(g.tileset)),1)	:(random_rack)
random_rack.end

	define('scan(pair,rack)num,line,alone,nopen,ai,first,max,n,last,p,move,moves,fi,lonely,avail,scanned')	:(scan.end)

*	Scan the given line to find the places where a valid move can be made. At least one cell in 
*	a move must be adjacent to an occupied cell.  *line* is the line to be scanned, and *num* gives its
*	position on the board.

scan
	line = line(pair)
	num = num(pair)
	moves = 0
	alone = g.alone.lines[num]

*	Allocate and fill in avail, an array giving the positions of the open cells.

	avail = available(line)			:f(scan.done);* fail if no empty cells

*	Set lonely to the alone-ness of the cells in avail, so that the i-th character is the
*	alone attribute of the i-th position in the move. A valid move requires that at
*	least cell in the move not be alone.

	i = 0
scan.lonely
	lonely = lonely substr(alone,avail[i = i + 1],1) :s(scan.lonely)
	
	nopen = prototype(avail);* number of open cells

*	Prepare for loop, since decrement nopen at start of search at a given empty cell.

	nopen = nopen + 1
	ai = 0

scan.next
*	Here to find all the possible moves starting at the next open cell, first.

	first = avail[ai = ai + 1]			:f(scan.done)

	nopen = nopen - 1;* count down since we are accounting for this open cell in this pass through the loop.
	le(nopen)					:s(scan.done)

*	Let max be the most tiles we can play on this line. We can't play more tiles than the number of 
*	blank cells remaining in the line, and we can't play more tiles than we have.

	max = nopen
	max = gt(max,size(rack)) size(rack)
	max = eq(max,7) 6
	n = 0

scan.next.n
	gt(n = n + 1,max)				:s(scan.next)

	last = ai + n - 1				:f(scan.fail)
	fi = first - 1

*	Continue to the next postion if all the cells in this move are alone, and hence no valid move is possible.

	substr(lonely,ai,n) ? span('1')		:s(scan.next)
	move = move(num,n,subarray(avail,ai,n))
	scan = ident(scan) table()
	scan[scanned = scanned + 1] = move		:(scan.next.n)
scan.done
	ident(scan)					:s(freturn)
	scan = convert(scan,'array')				
							:(return)
scan.doner	
	output = 'move.doner'				:(end)
scan.end

	define('score(pair)cline,vline,word,words,n,start,wi,ch,i,bonus,mult,val')	:(score.end)

*	Compute the score of a move on a given line. All the letters of the move will be in upper case on the board
*	so the score of the move is the sum of the scores of all the words with upper case letters in them, for
*	both rows and columns. This function should only be called for lines which have an upper case letter in
*	them as a result of the move.

*SCORE
score
	empty(line(pair))				:s(return)
	output = ne(g.showscore) 'enter score ' show.pair(pair)
	cline = line(pair)
	bonusline = g.bonus.lines[num(pair)]

	eq(g.showscore) 				:s(score.3)
*	vline = 
*score.1
*	gt(i = i + 1,size(cline))			:s(score.2)
*	vch = substr(cline,i,1)
*	vch = gt(g.value[vch],0) substr('123456789ABCDE',g.value[substr(cline,i,1)],1)
*	vline = vline vch				:(score.1)
*score.2
*	output = 'score value ' vline
	output = 'score       ' cline
	output = 'score bonus ' bonusline  
score.3

	cline break(&ucase)				:f(score.error)
	words = words(cline)				:f(return)
	wi = 0
score.word
	start = words[wi = wi + 1,1]			:f(return)
	word = words[wi,2]
	n = size(word)

*	Single letters don't contribute to score since they result from an crossing line.

	eq(n,1)						:s(score.word);* singletons aren't scored.
	word break(&ucase)				:f(score.word)

	output = ne(g.showscore) 'scoring word ' word ' starting at ' start
	line = substr(cline,start)
	bonusline = substr(g.bonus.lines[num(pair)],start);* corresponding part of bonus line
	i = 0
	mult = 1;* multiplier value for double and triple word cases.

score.char
	gt(i = i + 1,n) 				:s(score.char.done)
	ch = substr(word,i,1)
	bonus = +substr(bonusline,i,1)
	val = +g.value[ch]
*	output = ne(g.showscore) ch ' ' val ' ' bonus

*	Update score for letter

	score = lt(bonus,4) score + bonus * val	

*	Update double/word multiplier

	mult = gt(bonus,3) mult * (bonus - 2)

*	output = ne(g.showscore) 'score ' ch ' added value ' val ' score now ' score ' mult ' mult
							:(score.char)
score.char.done
	score = score * mult
*	output =  'result SCORE ' score ' for word ' word ' , for ' show.pair(pair)
							:(return)
score.error
	score = 0					:(return)
*	output = 'error scoring line with no new move ' line(pair) :(end)
score.end

	define('subarray(ara,start,len)i')		:(subarray.end)

*	Like substr, but returns the sub-array of *ara* starting at element *start* and
*	consisting of *len* elements

subarray
	subarray = array(len)
subarray.1
	gt(i = i + 1,len)				:s(return)
	subarray[i] = copy(ara[start + i - 1])		:(subarray.1)		
subarray.end

	define('ucase(s)')				:(ucase.end)

*	Convert argument to upper case.

ucase
	ucase = replace(s,&lcase,&ucase)		:(return)
ucase.end
	
	define('unpack(line),c,i')			:(unpack.end)

*	Unpack the characters of line to array of characters.

unpack
	unpack = array(15)
	output = ne(size(line),15) ' ERROR - unpack argument not length 15, but is ' size(line)	:s(end)
unpack.1
	unpack[i = i + 1] = substr(line,i,1)		:s(unpack.1)f(return)
unpack.end

	define('vline(grid,c)')				:(vline.end)

*	Return the vertical line of a grid corresponding to column c as a string.

vline
	c = +c
	vline = grid[1,c] grid[2,c] grid[3,c] grid[4,c] grid[5,c] 
.		grid[6,c] grid[7,c] grid[8,c] grid[9,c] grid[10,c]
.		grid[11,c] grid[12,c] grid[13,c] grid[14,c] grid[15,c]
							:(return)
vline.end

	define('wordcount(s)i,w')			:(wordcount.end)

*	Return number of words in s, fail if no words

wordcount
	s break(' ')					:f(freturn)
	
	wordcount = 0
wordcount.1
	s break(' ') . w span(' ') =			:f(return)
	wordcount = +wordcount + 1			:(wordcount.1)
wordcount.end

	define('words(s)n,w,pos,i')					:(words.end)

*	Return array of the words in s, fail if no words.
*	The first entry for an array is the starting index,
*	the second entry is the word itself.

words
	n = wordcount(s)				:f(freturn)
	s = s ' '
	words = table(n)
	pos = 1	
	s span(' ') . w =				:f(words.1)
	pos = size(w) + 1;* point to start of first word
words.1
	s break(' ') . w ' ' = ' ' 			:f(words.done)
	words[pos] = w					
	i = i + 1	
	gt(i,n)						:s(words.done)
	
	pos = pos + size(w) + 1;* set to start of next word
							:(words.1)
words.done
	words = convert(words,'array')			:(return)
words.end

