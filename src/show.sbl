
	define('show.board(board,title)b,r,c,ch,line')	:(show.board.end)

*	Show the board.

show.board
	show.header(title)
show.board.r
	gt(r = r + 1,15) 				:s(show.board.finish)
	line = lpad(r,2) '|' 
	c = 0
show.board.c
	gt(c = c + 1,15)				:s(show.board.margin)
	ch = board[r,c]
	b = g.bonus[r,c]
	differ(ch,' ')					:s(show.board.ch)

*	Here if empty cell, see if there is a bonus to be show.boarded.

	ne(b,1)						:s(show.board.b)

*	Here to show.board empty cell.

	line = line ' - '				:(show.board.c)
show.board.b

* 	Here to show.board bonus.

	ch = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line ch ' '				:(show.board.c)
show.board.margin
	output = line '|'				:(show.board.r)
show.board.ch
	line  = line ' ' ch ' '				:(show.board.c);* show.board tile
show.board.finish
	output =					:(return)
show.board.end

	define('show.bonus()b,r,c,l,line')			:(show.bonus.end)

*	Show the board.

show.bonus
	show.header('bonus')
show.bonus.r
	gt(r = r + 1,15) 				:s(show.bonus.finish)
	line = lpad(r,2) '|'
	c = 0
show.bonus.c
	gt(c = c + 1,15)				:s(show.bonus.l)
	l = g.bonus[r,c]
	line = differ(l,' ') line ' ' l 		:s(show.bonus.c)
* Here for blank cell, show.bonus bonus if applicable
	b = g.bonus[r,c]
	eq(b)						:s(show.b)
* 	Here to show bonus
	l = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line l 					:(show.bonus.c)
show.bonus.b
*	Here to show.bonus empty cell.
	line = line ' -'				:(show.bonus.c)
show.bonus.l
	output = line '|'				:(show.bonus.r)
show.bonus.finish
	output =					:(return)
show.bonus.end

	define('show.header(label)')			:(show.header.end)
show.header
	output = label
	output = '                               1  1  1  1  1  1'
	output = '   1   2  3  4  5  6  7  8  9  0  1  2  3  4  5'	:(return)
show.header.end

	define('show.clines(lines,title)i,line,num')		:(show.clines.end)

*	Show the clines array of lines

show.clines
	title  = 'clines' (differ(title) ' ' title, '')
	output = title
	output = '    123456789012345'
show.clines.n
	num = lines[i = i + 1,1]			:f(return)
	line = lines[i,2]
	output = size(line)
	output = lpad(lineid(num),2) ' '  replace(line,' ','.') :(show.clines.n)
show.clines.end

	define('show.grid(g)r')				:(show.grid.end)

*	Show a grid.

show.grid
	show.header()
show.grid.r
	gt(r = r + 1,15) 				:s(show.grid.done)
	output = show.hline(g,r)			:(show.grid.r)		 
show.grid.done
	output =					:(return)
show.grid.end

	define('show.hex(line)ch,i')				:(show.hex.end)

*	Show line with blanks replaced by hex digits showing their position in the line.

show.hex
	ch = substr(line,i = i + 1,1)				:f(return)
	show.hex = show.hex (ident(ch,' ') substr('0123456789ABCDEF',i,1), ch) :(show.hex)
show.hex.end

	define('show.hline(g,row)line,ch')		:(show.hline.end)

*	Returns the line corresponding to row *row* in grid *g* with two characters per cell.

show.hline
	line = hline(g,row)
	show.hline = rpad(row,2) '|'
show.hline.ch
	line len(1) . ch = 				:f(show.hline.done)
	show.hline = show.hline ' ' ch  ' '		:(show.hline.ch)
show.hline.done
	show.hline = show.hline '|'			:(return)
show.hline.end

	define('show.line(line)')				:(show.line.end)

*	Show a line with blanks replaced by '.'

show.line
	show.line = replace(line,' ','.')			:(return)
show.line.end

	define('show.lines(lines,title)i,line,titled')	:(show.lines.end)

*	Show the lines that are not empty in an array of lines

show.lines
	title  = 'lines' (differ(title) ' ' title, '')
	output = title
show.lines.n
	line = lines[i = i + 1]				:f(return)
	empty(line)					:s(show.lines.n)
	differ(titled)					:s(show.lines.titled)
	output = '    123456789012345';* don't list header unless at least one non-empty line
	titled = 1
show.lines.titled
	output = lpad(lineid(i),2) ' ' replace(line,' ','.') :(show.lines.n)
show.lines.end

	define('show.move(move,title)f,i') 			:(show.move.end)

*	Show a move.

show.move
	gt(i = i + 1,count(move))			:s(show.move.f)
	f = append(f,free(move)[i],',')			:s(show.move);* list the free cells
show.move.f
	show.move = lineid(id(move)) ':' count(move) ':' f ':'
	show.move = differ(text(move)) show.move text(move) 
	show.move = differ(perm(move)) show.move ':' perm(move)
	show.move = differ(points(move)) show.move  '+' points(move)
*	show.move = differ(fid(move)) show.move ':' fid(move)
							:(return)
show.move.end

	define('show.moves(moves,title)i,move,text')	:(show.moves.end)

*	Show an array of moves. Assume each entry has 1) line num, 2) move

show.moves
	ident(moves)					:s(return)
	output = 'MOVES ' title
show.moves.loop
	move = moves[i = i + 1,2]			:f(return)
	output = char(9) lpad(i,2) ' ' show.move(move) :(show.moves.loop)
show.moves.end
	
	define('show.pair(pair)')			:(show.pair.end)

*	Show paired item.

show.pair
	show.pair = '{' lineid(num(pair)) ',' "'" replace(line(pair),' ','.') "'" '}'	:(return)
show.pair.end

	define('show.play(move,title)board,f,r,c,i')	:(show.play.end)

*	Show the results of making move *mov*. 


show.play
	board = copy(g.board)
	text = text(move)
show.play.next
	f = free(move)[i = i + 1]			:f(show.play.done)
	r = (lt(id(move),15) id(move), f)
	c = (gt(id(move),15) id(move) - 15, f)
*	output = 'show.play r ' r ' c ' c ' ch ' substr(text,i,1)
	board[r,c] = substr(txt,i,1)
							:(show.play.next)
show.play.done
	show.board(board,title)			:(return)
show.play.end

	define('show.player(player)')			:(show.player.end)

*	Show player description.

show.player
	output = 'player ' name(player) ', rack |' rack(player) '| score ' score(player) ', moves ' moves(player)
							:(return)
show.player.end

	define('show.tiles(tiles)i')			:(show.tiles.end)

*	Show a list of tiles, separated by blanks.

show.tiles
	gt(i = i + 1,size(tiles))			:s(return)
	show.tiles = append(show.tiles, substr(tiles,i,1))	:(show.tiles)
show.tiles.end
