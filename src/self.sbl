* This sofaware is licensed under the MIT License, contained in the file LICENSE.

* Copyright (c) 2016 dave shields

-include "words.sbl"
-include "show.sbl"

	define('rackout(rack,text)ch')			:(rackout.end)

*	Remove the tiles in *text* from *rack*.

rackout
	rackout = rack
rackout.ch
	text len(1) . ch =				:f(return)
	rackout = less(rackout,ch)			:(rackout.ch)
rackout.end
	
	define('show(rack,player)')			:(show.end)

*	Show state of board, alone and value grids before start of move.

show
	show.board(g.board,'player ' player ' to play')
	output = 'rack ' rack
	show.board(g.board,'player ' player)
	show.alone()
	show.board(g.bonus,'bonus')
							:(return)
show.end

*	Have fribble play itself.

	init()

	rack1 = take(7)
	rack2 = take(7)
	
*	player one makes opening move.

	show(rack1,'one')
	opn = open(rack1)
	output = 'open returns<' opn '>'
	opn break(' ') . open.word ' ' rem . open.score
	output = 'opening word ' open.word
	points1 = 'opening score ' open.score
	ara = array(7);* free array for move
*	Start word at position 8, unless word size greater than five, in which case move it to the left, but
*	making sure move still covers double-word cell at position twelve.

	offset = (lt(size(open.word) 5, 5 - size(open.word)))
	ara[1] = 8 + offset
	ara[2] = 9 + offset
	ara[3] = 10 + offset
	ara[4] = 11 + offset
	ara[5] = 12 + offset
	ara[6] = 13 + offset
	ara[7] = 14 + offset
	output = 'move(' 8 + offset ',' size(open.word) ',ara,' open.word ')' 
	move1 = move(8 + offset,size(open.word),ara,open.word,open.score)
	output = 'opening move ' show.move(move1,'opening move')
	playmove(move1);* play opening move
*	output = 'open placed'
*	output =  'player one opens: ' show.move(move1) ' for ' points(move1) ' points.'
	show.board(g.board,
.	 'player one opens: ' show.move(move1) ' for ' points(move1) ' points.')
	output = 'board displayed'
	rack1 = rackout(rack1,text(move1)) take(size(text(move1)))

player.two

*	player two makes next move.

	moves = moves + 1
	gt(moves, 70)			:s(many.moves)
	show(rack2,'two')
	move2 = find(g.lines,rack)			:f(two.nomove)
	show.board(g.board,
.	 'player two: ' show.move(move2)) ' for ' points(move2) ' points. Score now ' points1 '/' points2 '.'
	rack2 = rackout(rack2,text(move2)) take(size(text(move2)))
							:(player.one);* one's turn
two.nomove
	output ' player two has no move, pass.';* fall through to player one for their turn.

player.one

*	player one makes the next move.

	moves = moves + 1
	gt(moves, 70)			:s(many.moves)
	show(rack1,'one')
	output = 'player one rack ' rack1
	move1 = find(g.lines,rack)			:f(one.nomove)
	points1 = points1 + points(move1)
	playmove(move1,g.tileset)		
	rack1 = rackout(rack1,text(move1)) take(size(text(move1)))
	output = 'rack1 ' rack1
							:(player.two)
one.nomove
	output ' player one has no move, pass.'		:(player.two)

many.moves
	output = 'too many moves.'
no.moves
	output = ' game over, player one ' lpad(points1,4) points1 ', player two ' lpad(points2,4) '.'
end
