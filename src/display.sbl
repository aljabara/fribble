
	define('display.alone()b,r,c,l,line')				:(display.alone.end)

*	Display the board on standard output

display.alone
	display.header('alone')
display.alone.r
	gt(r = r + 1,15) 				:s(display.alone.finish)
	line = lpad(r,2) '|' 
	c = 0
display.alone.c
	gt(c = c + 1,15)				:s(display.alone.l)
	l = g.alone[r,c]
	line = line lpad(l,2)		 		:s(display.alone.c)
display.alone.l
	output = line '|'				:(display.alone.r)
display.alone.finish
	output =					:(return)
display.alone.end

	define('display.board(board,title)b,r,c,ch,line')	:(display.board.end)

*	Display the board on standard output

display.board
	title  = 'board' (differ(title) ' ' title, '')
	display.header(title)
display.board.r
	gt(r = r + 1,15) 				:s(display.board.finish)
	line = lpad(r,2) '|' 
	c = 0
display.board.c
	gt(c = c + 1,15)				:s(display.board.margin)
	ch = board[r,c]
	b = g.bonus[r,c]
	differ(ch,' ')					:s(display.board.ch)

*	Here if empty cell, see if there is a bonus to be display.boarded.

	ne(b,1)						:s(display.board.b)

*	Here to display.board empty cell.

	line = line ' -'				:(display.board.c)
display.board.b

* 	Here to display.board bonus.

	ch = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line ch 					:(display.board.c)
display.board.margin
	output = line '|'				:(display.board.r)
display.board.ch
	line  = line ' ' ch				:(display.board.c);* display.board tile
display.board.finish
	output =					:(return)
display.board.end

	define('display.bonus()b,r,c,l,line')			:(display.bonus.end)

*	Display the board on standard output

display.bonus
	display.header('bonus')
display.bonus.r
	gt(r = r + 1,15) 				:s(display.bonus.finish)
	line = lpad(r,2) '|'
	c = 0
display.bonus.c
	gt(c = c + 1,15)				:s(display.bonus.l)
	l = g.bonus[r,c]
	line = differ(l,' ') line ' ' l 		:s(display.bonus.c)
* Here for blank cell, display.bonus bonus if applicable
	b = g.bonus[r,c]
	eq(b)						:s(display.b)
* 	Here to display bonus
	l = (eq(b,2) 'dl', eq(b,3) 'tl', eq(b,4) 'dw', eq(b,5) 'tw')
	line = line l 					:(display.bonus.c)
display.bonus.b
*	Here to display.bonus empty cell.
	line = line ' -'				:(display.bonus.c)
display.bonus.l
	output = line '|'				:(display.bonus.r)
display.bonus.finish
	output =					:(return)
display.bonus.end

	define('display.tag(tag)')			:(display.tag.end)

*	Display tagged item.


display.tag
	display.tag = '{' lineid(num(tag)) ',' "'" replace(line(tag),' ','.') "'" '}'	:(return)
display.tag.end

	define('display.header(label)')			:(display.header.end)
display.header
	output = ucase(label)
	output = '                      1 1 1 1 1 1'
	output = '    1 2 3 4 5 6 7 8 9 0 1 2 3 4 5'	:(return)
display.header.end

	define('display.clines(lines,title)i,line,num')		:(display.clines.end)

*	Display the clines array of lines

display.clines
	title  = 'clines' (differ(title) ' ' title, '')
	output = title
	output = '    123456789012345'
display.clines.n
	num = lines[i = i + 1,1]			:f(return)
	line = lines[i,2]
	output = size(line)
	output = lpad(lineid(num),2) ' '  replace(line,' ','.') :(display.clines.n)
display.clines.end

	define('display.line(line)')				:(display.line.end)

*	Display a line with blanks replaced by '.'

display.line
	display.line = replace(line,' ','.')			:(return)
display.line.end

	define('display.lines(lines,title)i,line')		:(display.lines.end)

*	Display the lines that are not empty in an array of lines

display.lines
	title  = 'lines' (differ(title) ' ' title, '')
	output = title
	output = '    123456789012345'
display.lines.n
	line = lines[i = i + 1]				:f(return)
	empty(line)					:s(display.lines.n)
	output = lpad(lineid(i),2) ' ' replace(line,' ','.') :(display.lines.n)
display.lines.end

	define('display.move(mov,title)f,i') 			:(display.move.end)

*	Display a move.

display.move
	f = append(f,free(mov)[i = i + 1])		:s(display.move);* list the free cells
	display.move = 	lineid(id(mov)) ':' f ':'
	display.move = differ(text(mov)) display.move text(mov) 
	display.move = differ(points(mov)) display.move  '+' points(mov)
							:(return)
display.move.end

	define('display.moves(moves,title)i,mov')	:(display.moves.end)

*	Display an array of moves. Assume each entry has 1) line num, 2) move

display.moves
	ident(moves)					:s(return)
	output = 'MOVES ' title
display.moves.loop
	mov = moves[i = i + 1,2]			:f(return)
	output = char(9) lpad(i,2) ' ' display.move(mov) :(display.moves.loop)
display.moves.end
	
	define('display.play(mov,title)board,f,r,c,i')	:(display.play.end)

*	Display the results of making move *mov*. 


display.play
	board = copy(g.board)
	txt = text(mov)
display.play.next
	f = free(mov)[i = i + 1]			:f(display.play.done)
	r = (lt(id(mov),15) id(mov), f)
	c = (gt(id(mov),15) id(mov) - 15, f)
*	output = 'display.play r ' r ' c ' c ' ch ' substr(txt,i,1)
	board[r,c] = substr(txt,i,1)
							:(display.play.next)
display.play.done
	display.board(board,title)			:(return)
display.play.end

	define('display.scores()ara,i')			:(display.scores.end)

*	Display an array of scores.

display.scores
	output = 'display g.scores '
	ara = rsort(g.scores,2)
display.scores.next
	output = ara[i = i + 1,1] ' ' lpad(ara[i,2],6)  :s(display.scores.next)f(return)
display.scores.end
