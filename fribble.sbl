* Copyright (c) 2017 dave shields

-include "lib.sbl"

	define('ask(query)response')			:(ask.end)

*	Ask question until you get yes (success) or no (failure) answer.

ask
	out(query)
	output = "respond with 'y', 'yes', 'n', or 'no'"
ask.loop
	response = lcase(input)				:f(freturn)
	response 'yes'					:s(return)
	response 'ye'					:s(return)
	response 'y'					:s(return)
	response 'no'					:s(freturn)
	response 'n'					:s(freturn)
							:(ask)
ask.end
	define('game(one,two)opn,move,players,i,li,offset,open.word,open.score,n,tiles,moves,li,passed,board') :(game.end)

*	Play a game of fribble. *one* and *two* are players. *max* is the maximum number of moves.

*GAME*
game
	players = array(2)
	players[1] = g.one
	players[2] = g.two
game.round
	i = 0
game.turn
	player = players[i = i + 1]				:f(game.round)

	g.turn = g.turn + 1

	out(ne(g.turnlimit) gt(g.turn,g.turnlimit) 'Game over -- too many turns (' g.turnlimit ').') :s(game.over)
	out(gt(g.turn,g.lastmove + 5) 'Game over - too many turns with no move.') :s(game.over)
	out(ne(g.maxmoves) gt(g.turn,g.maxmoves) 'Game over -  too many turns.')  :s(game.over)

	differ(g.trace) eq(g.trace,g.turn) tracer()


	out('Move ' g.turn ' for player ' name(player) (ident(fribble(player)) ', with tiles ' show.tiles(rack(player),'A') '.', '.'))
*	out(ne(g.showscore) 'B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 ')
	out('B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 ')

	differ(fribble(player))				:s(game.you.move)

*	Current player is the foe. Enter their move from the wwf board.

game.foe.move
	show.board(g.board)
	out("enter foe's move")
	text = input					:f(game.eof)
	out('you entered ' text)
	move = eval(text)
	out('datatype move ' datatype(move))
	ident(datatype(move),'move')			:s(game.foe.validmove)
							:(game.foe.move)
game.foe.validmove
	out("Foe's move " show.move(move))
	clines(move)
	show.play(move)
	validmove(move)					:s(game.foe.scoremove)
	out('invalid move ' show.move(move))	:(game.foe.move)

game.foe.scoremove
*	g.showscore = 1
	points(move) = scoremove(move)
	out('move is worth ' points(move) ' points.')
	ask("Do you want to make this move?")		:s(game.foe.moveon)f(game.eod)

game.foe.moveon
	out("Playing foe's move " show.move(move))
	makemove(player,move)
	show.play(move)
							:(game.turn)
game.you.move

*	Here to make your move. 
*	Enter current rack and then let fribble make the move.

	out('your move ' g.turn)
	show.board(g.board)
	rack(player) = enterrack()			:f(game.you.move)
	out('entered rack ' rack(player))
	out('computing ...')

	move = find(pid,g.turn)				:s(game.you.playmove)

	out('unable to find move - end of game ') 	:(game.over)
game.you.playmove
	out('...computed')
	out('fribble generated move ' show.move(move))
	makemove(player,move)
	show.play(move)
game.you.makemove
	out('Make your move on the wwf board.')
	ask("Have you entered the move?")		:s(game.turn)f(game.you.makemove)
game.fribble

*	Here to have fribble make a move

*game.move
*game.moveon
*	makemove(player,move)
*	show.play(move)
*
**	Game over if no more tiles.
*
*	out(eq(size(g.tiles)) 'Game over - no more tiles. ')		:s(game.over)
*	getrack(player,move)					:(game.turn)
*
game.fail

*	Here if no move found.

	out('No move found.')

*	Here if no move found, in which case the return value is a set of swapped tiles. If *move* is null, then pass.

	differ(move)					:s(game.swap)
	passed = passed + 1
	out(gt(passed,6) ' Too many passed moves.')	:s(game.over)
	out('Player ' name(player) ' passes.')		:(game.turn)
	
game.swap
	rack(player) = swap(player,3)
	out('Player ' name(player) ' swapped tiles.')
	out('Player ' name(player) ' now has tiles ' show.tiles(rack(player))) :(game.turn)
game.eof
	out('end of input - game over')		:(game.over)
game.resign
	out('player ' name(player) ' resigns')
game.over						
	endgame()					:(return)
game.end
	define('sw()')					:(sw.end)

*	Swap two tiles for player 'you'

*SW*
sw
	rack(g.two) = swap(g.two,2)			:(return)
sw.end
	define('enterrack()ans')			:(enterrack.end)

*	Enter your rack

enterrack
	out( 'Enter your tiles')
	enterrack = input				:f(game.eof)
	ask("You entered: " enterrack ". Is this correct?") :s(return)f(enterrack)
enterrack.end

*	Play a game against a foe using Fribble to make your moves.
*	You need to enter the opponent's moves and your rack (tileset) on each turn.

*	&stlimit = -1
	&anchor = &trim = 1

	init()

*	w = words('  greedy ab ')
*	show.words(w)

*	You go first, so just enter your tiles and then use start()

	one = player(1,'You',1)
	two = player(2,'Foe')
	g.one = one
	g.two = two
	total(g.one) = total(g.two) = 0

	g.turn = g.lastmove = 0
	g.turnlimit = 

*	g.trace = 15

	game()							:(end)
end
