* Copyright (c) 2017 dave shields

-include "lib.sbl"
	define('main()')				:(main.end)

*MAIN*
main
	&stlimit = -1
	&anchor = &trim = 1
	init()
	output = 'init done'

	output = r01 ' ' c01
	mov = m(r08,8,'shields')
	output = show.move(mov,'test')
	playmove(mov)
	mov = mf(r09,'7,8,11,12','dave')
	clines(mov)
	show.clines()
	output = show.move(mov,'test')
	output = put.move(mov)
	show.play(mov)
*	mov = m(r12,1,'dave')
	mov = m(r10,7,'o')
	validmove(mov)		:s(move.ok)f(move.notok)
move.ok
	output = 'move ok'
	show.play(mov)
*	playmove(mov)
 :(move.next)
move.notok
	output = 'move not ok'
move.next

 :(end)

	you = player(1,'You',1)
	foe = player(2,'Foe')
	g.one = you
	g.two = foe

*	When playing solo, you (we) make the first move.
	match(you,foe)					:s(main.match.done)f(main.match.fail)
main.match.fail
	output = 'failed match'				:(main.match.done)
main.match.done
	output = 'match over'
main.match.over
	counters()					:(return)
main.end

	define('match(you,foe)first,opn,move,players,i,li,offset,open.word,open.score,n,tiles,moves,li,passed,board') :(match.end)

*	Use fribble to play a match with another player. 
*	*foe* is the other player; *you* is you assisted by fribble.

*	Basic cycle is
*	  loop
*		enter foe's move
*		list the tiles in your rack
*		fribble makes your move
*		enter your updated rack
*		update board and other player-related info
*			:(loop)


*MATCH*
match

*	See if we are to start the game.

	ne(pid(you),1)					:s(match.turn)

*	We make the first move. Start by getting the rack

	g.turn = 1
	output = "Enter rack for first move:"
	g.turn = 1
	rack(you) = r()
	output = 'Move ' g.turn ' for player ' name(you) ', with tiles ' show.tiles(rack(you)) '.'
	move = start(rack(you))
	makemove(you,move)
	show.play(move)

match.turn

*	On each turn, get the foes's move, make your move, and update your rack.

	g.turn = g.turn + 1

	differ(g.trace) tracer()

	move = foe()						:f(foe.bad)
	makemove(foe,move)				:s(return)f(freturn)
	show.play(move)
*	Need to see if move is valid

*	Play the foe team's move.

	makemove(foe,move)

*	Get the current rack.

	rack = order(r())
	move = find(rack)					:f(you.bad)
	makemove(you,move)
	show.play(move)
								:(match.turn)
foe.bad
	output = 'foe is unable to make  move.'			:(freturn)
you.bad
	output = 'you are nable to make  move.'			:(freturn)
match.you

	output = eq(size(g.tiles)) 'Game over - no more tiles. '		:s(match.over)
	getrack(p,move)					:(match.turn)

match.fail

*	Here if no move found.

	output = 'No move found.'

*	Here if no move found, in which case the return value is a set of swapped tiles. If *move* is null, then pass.

	differ(move)					:s(match.swap)
	passed = passed + 1
	output = gt(passed,6) ' Too many passed moves.'	:s(match.over)
	output = 'Player ' name(g.one) ' passes.'		:(match.turn)
	
match.swap
	rack(p) = swap(rack(p),3)
	output = 'Player ' name(p) ' swapped tiles.'	
	output = 'Player ' name(p) ' now has tiles ' show.tiles(rack(p)) :(match.turn)
match.over						
	endgame()					:(return)
match.end

	main()
end
