* Copyright (c) 2017 dave shields

-include "lib.sbl"


	define('turn(pid,mode)')						:(turn.end)

*	Play a turn in a game.

*	Steps are

*	1.	Replenish tiles before making the move if managing the tiles by hand.

*	2.	Find or enter the move to be played.

*	3.	Make the move by updating the data structures, scores, etc.

*	4.	If not managing the tiles by hand, use fribble to update the rack.

turn
	g.turn = g.turn + 1
	player = g.players[pid]
	ne(f.trace) out('enter turn pid=' pid ' ' show.player(pid))

*	Replenish tiles before making the move. 

*	This is needed when playing in team mode. 
*	need to enter your tiles from the wwf board.
*

	ne(kind(player),player.kind.team)			:s(turn.move)

	rack(player) = replenish(pid)
	ne(f.trace) out('rack pid=' pid '   now ' rack(player))
	ne(f.trace) out(show.player(pid))

turn.move

*	2.	Find or enter the move to be played.

*	Here to pick the next move.
*	You need to enter the foe's move when playing as a team,
*	and your own move when playing a solo game.


	eq(kind(player),player.kind.foe)			:s(turn.manual)
	eq(kind(player),player.kind.solo)			:s(turn.manual)
	
turn.auto

*	Here to have fribble find the best move.

	ne(f.trace) out('fribble making move.')

	ne(kind(player),player.kind.auto) out('computing move ...')
	g.move = find(pid,g.turn)				:s(turn.auto.found)f(turn.auto.fail)
turn.auto.found
	ne(kind(player),player.kind.auto) out('... computed')
								:(turn.make)
turn.auto.fail
	out('...computed')					:(turn.fail)

turn.move.manual

	ne(f.trace) out('getting move manually')
*	Here to enter the move manually

turn.manual

turn.manual.in
	out('enter move')
	line = terminal						:f(end)
	move = eval(line)					:f(turn.manual.error)
	out('input: ' show.move(move) ' datatype ' datatype(move) )
	ident(datatype(move),'move')				:s(turn.validate)
	out('need to enter a move')				:(turn.manual)


turn.validate

	ne(f.trace) out('validating move ' show.move(move))
*	See if move is valid, except no test needed for initial move.

	g.move = move
	eq(g.turn,1)						:s(turn.make)
	out('validating gturn=' g.turn)
	valid(g.move)						:s(turn.make)

	out('invalid move - try again')				:(turn.manual.in)

turn.manual.error
	out('eval error ' &errtext)				:(turn.manual)

turn.make

*	3.	Make the move by updating the data structures, scores, etc.


	points(g.move) = scoremove(g.move)
	ne(f.trace) out('making move ' show.move(g.move))
	show.play(makemove(pid,g.move))

turn.replenish

*	4.	Replenish the tiles if managing the tiles automatically.


*	Replenish tiles if necessary. If doing this manually, don't do it here,
*	but at start of next turn.

	eq(g.tilemanager)					:s(turn.done)
	out('DAVE')
*	out('replenishing pid= ' pid ' ' show.player(player))
	ne(f.trace) out('replenishing pid= ' pid )


*	Here to update rack when fribble is managing the tiles.
*	Remove tiles played on move and then replenish the rack.

	ne(f.trace) out('updating rack pid=' pid)
	rack(player) = less(rack(player), lcase(text(g.move)))
	rack(player) = replenish(pid)			
	ne(f.trace) out('rack pid=' pid '   now ' rack(player))

turn.done
	ne(f.trace) out('turn done')
								:(return)
turn.fail
	out('turn failed - unable to find move.')		:(freturn)
turn.end 

	define('game(mode)players,player,opn,move,i,li,offset,open.word,open.score,n,tiles,moves,li,passed,board') :(game.end)

*	Play a game of fribble. *max* is the maximum number of moves.
*	Mode is one to let you play against fribble, two to let fribble play itself.

*GAME*
game

	pid = 2;* set to two so will become one when loop first entered

game.turn
	pid = (eq(pid,1) 2, 1)
	player = g.players[pid]


	eq(g.trace,g.turn) traceon()


	out('Move ' g.turn ' for player ' name(player) 
.		 (differ(g.tilemanager) ', with tiles ' show.tiles(rack(player),'A'),'')	'.')
	out(ne(g.showscore) 'B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 ')
	out('B 4 C 4 D 2 F 4 G 3 H 3 J 10 K 5 L 2 M 4 N 2 P 4 Q 10 U 2 V 5 W 4 X 8 Y 3 Z 10 ')


	turn(pid,mode)					:f(game.turn.fail)

	out(gt(g.turn,g.lastmove + 5) 
.		'Game over - too many turns with no move.') 	:s(game.over)

	out(ne(g.maxmoves) gt(g.turn,g.maxmoves) 
.		'Game over -- too many turns (' g.maxmoves ').') :s(game.over)

							:(game.turn)
game.turn.fail
*	Here if turn failed because no move could be found. Try to swap three tiles

	out('no move, swapping tiles.')
	rack(player) = swap(pid,3)			:(game.turn)
	
game.fail

*	Here if no move found.

	out('No move found.')

*	Here if no move found, in which case the return value is a set of swapped tiles. If *move* is null, then pass.

	differ(move)					:s(game.swap)
	passed = passed + 1
	out(gt(passed,6) ' Too many passed moves.')	:s(game.over)
	out('Player ' name(player) ' passes.')		:(game.turn)
	
game.swap
	out('swapping tiles pid=' pid)
	rack(player) = swap(pid,3)
	out('Player ' name(player) ' swapped tiles.')
	out('Player ' name(player) ' now has tiles ' show.tiles(rack(player))) :(game.turn)
game.over						
	endgame()					:(return)
game.end

*	Have fribble play itself.

	&stlimit = -1
	&anchor = &trim = 1

	init()


*	The program can now run in two modes.
*	f.mode = 1 for solo mode, where you play against fribble.
*	f.mode = 2 for self mode, where fribble moves for both players.
*	f.mode = 3 for match mode, where you use fribble to play another player.
	
	f.mode.foe  = 0
	f.mode.solo = 1
	f.mode.auto = 2
	f.mode.team = 3


	options = host(0) ' '
	options '-u' =
	output = 'host <' options '>'

options.loop
	options break(' ') . opt ' ' =			:f(options.loop.done)
	output = 'option ' opt
	f.mode = ident(opt,'auto') f.mode.auto			:s(options.loop)
	f.mode = ident(opt,'solo') f.mode.solo			:s(options.loop)
	f.mode = ident(opt,'team') f.mode.team			:s(options.loop)
	output = 'unknown option ' opt
							:(options.loop)
options.loop.done



	eq(f.mode,f.mode.solo)					:s(setup.solo)
	eq(f.mode,f.mode.auto)					:s(setup.auto)
	eq(f.mode,f.mode.team)					:s(setup.team)

								:(setup.auto);* default
setup.auto

*	Setup for mode 'auto'.

*	In auto mode, fribble plays against itself.

*	Fribble makes the moves for both players, each with kind player.kind.auto. 

	g.one = player(1,'Fribble I',	player.kind.auto)
	g.two = player(2,'Fribble II',	player.kind.auto)

*	Fribble manages the tiles for both players.

	g.tilemanager = 1
							:(setup.done)

setup.solo

*	Setup for mode 'solo'. 

*	In solo mode, you play against fribble. 

*	You are player one, of kind player.kind.solo. You make your own moves.
*	Fribble is player two, of kind player.kind.auto.

	g.one = player(1,'You',		player.kind.solo)
	g.two = player(2,'Fribble',	player.kind.auto)

*	Fribble manages the tiles for both players.

	g.tilemanager = 1
							:(setup.done)
setup.team

*	Setup for mode 'team'

*	In team mode, you work with fribble to play a foe, reporting the foe's moves
*	to fribble and playing the move fribble then suggests against the foe.

*	You are player one, of kind player.kind.team.
*	The foe is player two, of kind player.kind.foe.

*	You manage the tiles, entering your tiles as dealt by wwf before each move.
*	(The foe's tiles are unknown, as all that matters is the move they make.)

	g.one = player(1,'You',		player.kind.team)
	g.two = player(2,'Foe',		player.kind.foe)
	g.tilemanager =
							:(setup.done)
setup.done

	g.players[1] = g.one; g.players[2] = g.two

*	out('g.one ' show.player(1))
*	out('g.two ' show.player(2))

	g.turn = g.lastmove = total(g.one) = total(g.two) = 0
	
*	Set f.trace to trace fribble.

	f.trace = 1

	out('g.tilemanager=' g.tilemanager)
	ident(g.tilemanager)				:s(setup.game)

*	Program manages the tiles, so deal initial tiles.
	
	rack(g.one) = take(7)
	rack(g.two) = take(7)

setup.game

	game(f.mode)

end
