*	Copyright 2017, David Shields

* This file is part of the fribble project:
*		http://github.com/daveshields/fribble.
*
*	Fribble is free software: you can redistribute it and/or modify
*	it under the terms of the gnu general public license as
*	published by the free software foundation, either
*	version 2 of the license, or (at your option) any later version.
*
*	Fribble is distributed in the hope that it will be useful,
*	but without any warranty; without even the implied warranty of
*	merchantability or fitness for a particular purpose.  See the
*	gnu general public license for more details.
*
*	You should have received a copy of the gnu general public
*	license along with fribble.
*	If not, see <http://www.gnu.org/licenses/>.

*	Utility functions


	define('add1(name)exp')		:(add1.end)

*	Add one to argument, which must be a name.

add1

	exp = ' ' name ' = ' name ' + 1'
	add1 = eval(exp)
					:(return)
add1.end

	define('append(str,w,ch)')				:(append.end)

**	Append word W to string *str*, prefixing with *ch* if *str* is not null,
**	or using space if CH is null.

*APPEND*
append

	append = (ident(str) w, str (ident(ch) ' ' , ch) w)	:(return)

append.end


	define('avail(pair)line,spaces,c,i,oi')	:(avail.end)

*	Return array containing the indexes of the avail (blank) cells in line.
*	Fail if no cells are available.

*AVAIL*
avail
	line = line(pair)
	spaces = spaces(line)
	eq(spaces,0)					:s(freturn)
	avail = array(spaces)
	i = ai = 0

avail.c

	c = substr(line, add1(.i), 1)			:f(avail.done)
	differ(c,' ')					:s(avail.c)
	avail[add1(.oi)] = +i				:(avail.c)

avail.done

	eq(g.tracing)					:s(return)
	i = 0; c =

avail.done.ch

	c = c lpad(avail[add1(.i)],3)		:s(avail.done.ch)
*		show.hex(line) '|  |' show.line(line) '| is ' c)
							:(return)
avail.end


	define('cardinal(n,word)')			:(cardinal.end)

*	If N is one, returns 'one' followed by WORD.
*	Otherwise returns NUMBER(N) followed by WORD and 'S'.

cardinal

	cardinal = (eq(n,1) 'one ' word, number(n) ' '  word 's') :(return)

cardinal.end



	define('datename(date)s')				:(datename.end)

*	Convert date to form with no blanks, just dashes, to be
*	suitable for use as part of a file name.

datename

	datename = replace(date,' :/','---')
	datename = substr(datename,12,8) '-' substr(datename,1,10)
							:(return)
datename.end

	define('dt(obj)')				:(dt.end)

*	Shorthand for datatype(obj)

dt

	dt = (ident(obj) 'string',  datatype(obj))	:(return)

dt.end

	define('empty(line)')				:(empty.end)

*	Test if line is empty (null or all blanks).

*EMPTY*
empty

*	In most cases, the first character in line is not null.

	ident(line)					:s(return)
	differ(substr(line,1,1),' ')			:s(freturn)
	line span(' ') =
	ident(line)					:s(return)f(freturn)

empty.end


	define('lcase(s)')				:(lcase.end)

*	Convert argument to lower case.

*LCASE*
lcase

	lcase = replace(s,&ucase,&lcase)		:(return)

lcase.end

	define('less(str,sub)before,after')		:(less.end)

**	Less removes the first instance of each character in SUB from *str*,
**	where SUB is a substring of *str*.

*LESS*
less
	ident(str)					:s(return)
	less = str

less.ch
	sub len(1) . ch =				:f(return)
	less break(ch) . before  ch rem . after
	less = before after				:(less.ch)

less.end

	define('log(text)')				:(log.end)

*	Write text to logfile if making a log.

*LOG*
log
	eq(g.log)					:s(return)

	g.logfile = text				:(return)

log.end

	define('number(n)')				:(number.end)

**	If N can be represented as a string of one or two words
**	then return that string. Otherwise return N.

number
	number = eq(n) 'zero'				:s(return)
	number = g.numbers[n]
	differ(number)					:s(return)
	number = n					:(return)
number.end


	define('out(text1,text2,text3)type1,type2')	:(out.end)

*	Output a line conisting of TEXT1, TEXT2 enclosed
*	in brackets, followed by TEXT3.

*OUT*
out
	output = text1 (differ(text2) '[' text2 ']', '')  (differ(text3) text3, '') :(return)

	differ(text2)				:s(out.text2)

*	Here if just text1.

	output = text1				:(return)

out.text2

	type2 = dt(text2)
	type3 = dt(text3)
*	output = 'dt(type2) ' dt(type2)
*	output = 'dt(type3) ' dt(type3)
	ident(datatype(text2),'string')			:s(out.2)
*	output = 'out second argument not integer or string,'
*.	' but of type ' type2
*.						:(error)

out.2

	ident(type3,'integer')			:s(out.3)
	ident(type3,'string')			:s(out.3)

out.3
	type.ex(text3,'string')			:s(out.ok)
	type.ex(text3,'integer')			:s(out.ok)
*	output = 'out third argument not integer or string,'
*.	' but of type ' type3
*.						 :(error)

out.ok

	output = text1 ' [' text2 ']' text3		:(return)

out.end

	define('prefix(str,pre)word')			:(prefix.end)

*	Prefix takes a list of space-separated words str and prefixes each
*	with the string pre.

*PREFIX*
prefix

	str = str ' ';* so each word followed by space

prefix.1

	str break(' ') . word span(' ')  =		:f(return)
	add1(.prefixcount)
	prefix = append(prefix, pre word,'A')		:(prefix.1)

prefix.end

	define('random(n)')				:(random.end)

*	Return integer uniformly distributed in 1,2,...,n.
*	If n=0 returns real uniformly distributed in the interval [0,1].
*	The Algorithm is based on that in section 16.1 of "Algorithms in SNOBOL4,"
*	James F. Gimpel, John Wiley and Sons, 1976.

*RANDOM*
random

	g.random_var = remdr(g.random_var * 4676, 414971)
	random  = g.random_var / 414971.0
	random = ne(n) convert(random * n,'integer') + 1
							:(return)
random.end

	define('randomseed()s,c')			:(randomseed.end)

*	Compute seed for random number generator from date and time.

*RANDOMSEED*
randomseed
	g.random_var =
	s = g.date
	s = replace(s,'/:-','   ')

*	Get all the digits in s.

randomseed.loop

	s len(1) . c =					:f(randomseed.done)
	ident(c,' ')					:s(randomseed.loop)
	g.random_var = g.random_var c			:(randomseed.loop)

randomseed.done

*	Reverse the seed so digits depending on time come first.

	g.random_var = +reverse(g.random_var	)
							:(return)

randomseed.end

	define('reader(filename)n')			:(reader.end)

*	Return file as table of lines, with zero-th entry giving number
*	of lines.

*READER*
reader
	differ(filename) input(.file,g.channel.temp,filename)		:s(reader.opened)

	out('unable to open reader file ' filename '.') :(freturn)

reader.opened

	n = 0
	reader = table(100)

reader.next

	reader[add1(.n)] = (ident(filename) input, file) s:(reader.next)

*	Here at end of file, convert map to array of lines.

	reader[0] = n - 1;* line count

	differ(filename) endfile(g.channel.temp)
							:(return)
reader.end

	define('spaces(line)n')				:(spaces.end)

*	Count number of spaces in line.

*SPACES*
spaces

	line len(1) . c =				:f(return)
	spaces = ident(c,' ') spaces + 1		:(spaces)

spaces.end

	define('subarray(ara,start,len)i')		:(subarray.end)

**	Like substr, but returns the sub-array of ARA starting at
**	element START and consisting of *len* elements

*SUBARRAY*
subarray

	subarray = array(len)

subarray.1

	gt(add1(.i),len)				:s(return)
	subarray[i] = copy(ara[start + i - 1])		:(subarray.1)

subarray.end

	define('thousands(s)n')				:(thousands.end)

*	Format s with comma's every three digits from right.

*THOUSANDS*
thousands

	n = size(s)
	thousands = le(n,3) s				:s(return)
	thousands = thousands(substr(s,1,n - 3)) ',' substr(s, n - 2, 3) :(return)

thousands.end

	define('traceoff()')				:(traceoff.end)

*	Initiate tracing.

*TRACEOFF*
traceoff
	&ftrace = &trace =

	g.scoring = g.tracing = 0
	out('stop TRACING ')

traceoff.end

	define('traceon()')				:(traceon.end)

*	Initiate tracing.

*TRACEON*
traceon

	out('start TRACING')
*	&ftrace = &trace = 1500000
	g.scoring = g.tracing = 1
							:(return)
traceon.end

	define('ucase(s)')				:(ucase.end)

*	Convert argument to upper case.

*UCASE*
ucase

	ucase = replace(s,&lcase,&ucase)		:(return)

ucase.end


	define('unpack(line),c,i')			:(unpack.end)

**	Unpack the characters of line LINE to an array of characters.

*UNPACK*
unpack

	unpack = array(size(line))

unpack.ch

	c = substr(line,add1(.i),1)			:f(return)
	unpack[i] = c					:(unpack.ch)

unpack.end

	define('words(s)n,w,pos,i,sp')			:(words.end)

*	Return array of the words in s, fail if no words.
*	The first entry for an array element is the starting index;
*	the second is the word itself.

*WORDS*
words

*	Make sure we'll have blank to start off so initial span()
*	matches something, and also one at end to break to
*	in case last word extends to end of line.

	words = table(n)
	s = ' ' s ' '
	pos = 0
words.sp

*	Account for blank(s) between words.

	s span(' ') . sp =

	ident(s)					:s(words.done)

	pos = pos + size(sp);* point to start of next word

words.w

*	While it is customary to absorb the blank in the
*	usage below, we leave it in so there will be at least
*	one blank to satisfy span() when loop back to words.sp

	s break(' ') . w  = 	 			:f(words.done)
	words[pos] = w
	pos = pos + size(w)				:(words.sp)

words.done

	words = convert(words,'array')			:(return)

words.end

	:(error.end)
error
	output = 'error lastno ' &lastno
	output = 'ERROR'
	output = 'Fatal error: stopping the madness.'
*	&dump = 3
							:(end)
error.end

